<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>fafnir.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Fafnir 1.0.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="fafnir.core.html"><span>fafnir.core</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="fafnir.core.html#var-all"><span>all</span></a></li><li><a href="fafnir.core.html#var-assert-entity"><span>assert-entity</span></a></li><li><a href="fafnir.core.html#var-assoc-in-plan"><span>assoc-in-plan</span></a></li><li><a href="fafnir.core.html#var-assoc-plan"><span>assoc-plan</span></a></li><li><a href="fafnir.core.html#var-commit"><span>commit</span></a></li><li><a href="fafnir.core.html#var-gen-plan"><span>gen-plan</span></a></li><li><a href="fafnir.core.html#var-no-op"><span>no-op</span></a></li><li><a href="fafnir.core.html#var-query"><span>query</span></a></li><li><a href="fafnir.core.html#var-singleton"><span>singleton</span></a></li><li><a href="fafnir.core.html#var-update-all"><span>update-all</span></a></li><li><a href="fafnir.core.html#var-update-entity"><span>update-entity</span></a></li><li><a href="fafnir.core.html#var-update-in-plan"><span>update-in-plan</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>fafnir.core documentation</h2><pre class="doc"></pre><div class="public" id="var-all"><h3>all</h3><div class="usage"><code>(all itms)</code></div><pre class="doc">Given a list of plans, add them all to the current plan.

Example:

 (gen-plan
   [ids (all (map assert-entity ents))]
   ids)</pre></div><div class="public" id="var-assert-entity"><h3>assert-entity</h3><div class="usage"><code>(assert-entity ent)</code><code>(assert-entity ent key)</code></div><pre class="doc">Adds an entity to the DB, if no :db/id is provided one will be generated. Returns the :db/id of the new entity. 
</pre></div><div class="public" id="var-assoc-in-plan"><h3>assoc-in-plan</h3><div class="usage"><code>(assoc-in-plan path val)</code></div><pre class="doc">Like clojure.core/assoc-in but allows the user to assoc data into the plan
</pre></div><div class="public" id="var-assoc-plan"><h3>assoc-plan</h3><div class="usage"><code>(assoc-plan key val)</code></div><pre class="doc">Like assoc but uses the plan as the map
</pre></div><div class="public" id="var-commit"><h3>commit</h3><div class="usage"><code>(commit {:keys [conn db new-ents updates retractions valid-ids], :as plan})</code></div><pre class="doc">Commit processes the transaction with the associated connection, then updates all the tempids to match. You can then use plan-id to get the realized ent-ids
</pre></div><div class="public" id="var-gen-plan"><h3>gen-plan</h3><h4 class="macro">macro</h4><div class="usage"><code>(gen-plan binds id-expr)</code></div><pre class="doc">Takes a set of operations to perform to the DB and threads the state map through them all. This allows a transaction plan to be built without worrying about explicitly tracking the state map.
Example:
 (gen-plan
   [pid (assert-entity {:attr/code 42})
    cid (assert-entity {:attr/code 45 :parent/id pid})])</pre></div><div class="public" id="var-no-op"><h3>no-op</h3><div class="usage"></div><pre class="doc">Used to terminate the else leg of a if clause in a gen-plan.

Example:

(gen-plan
 [id (if pred?
        (assert-entity ent)
        no-op)])</pre></div><div class="public" id="var-query"><h3>query</h3><div class="usage"><code>(query clauses &amp; params)</code></div><pre class="doc">Executes a query against the :db found in the state
</pre></div><div class="public" id="var-singleton"><h3>singleton</h3><div class="usage"><code>(singleton sing)</code><code>(singleton sing key)</code></div><pre class="doc">Given an entity, returns either a tempid if the entity does not exist in the DB or returns the existing id. For a entity to be considered a &quot;singleton&quot; very attribute and value must exist in the DB version of the entity. That is to say, it must be a perfect match.
</pre></div><div class="public" id="var-update-all"><h3>update-all</h3><div class="usage"><code>(update-all itms)</code></div><pre class="doc">Takes a set of datoms and adds them to the list of datoms to be asserted in the transaction
</pre></div><div class="public" id="var-update-entity"><h3>update-entity</h3><div class="usage"><code>(update-entity ent &amp; attrs-vals)</code></div><pre class="doc">Updates an existing entity. This is the same as transacting [:db/add ent attr val].
</pre></div><div class="public" id="var-update-in-plan"><h3>update-in-plan</h3><div class="usage"><code>(update-in-plan path f &amp; args)</code></div><pre class="doc">Like clojure.core/update-in but allows the user to modify the state of the plan
</pre></div></div></body></html>