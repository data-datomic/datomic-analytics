;;;  -*- Package: cassandra_2.1.0 -*-
;;;
;;; Autogenerated by Thrift
;;; !!! DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
;;; This version declares the string fields for keys, column family names, etc to be binary
;;; fields which are exclusively strings (eg. keyspace names, or exception reasons) remain so.

(thrift:def-package :cassandra_2.1.0)

(cl:in-package :cassandra_2.1.0)

(thrift:def-enum "ConsistencyLevel"
  (("ZERO" . 0)
   ("ONE" . 1)
   ("QUORUM" . 2)
   ("DCQUORUM" . 3)
   ("DCQUORUMSYNC" . 4)
   ("ALL" . 5)
   ("ANY" . 6)))

(thrift:def-struct "column"
  "Basic unit of data within a ColumnFamily.
@param name. A column name can act both as structure (a label) or as data (like value). Regardless, the name of the column
       is used as a key to its value.
@param value. Some data
@param timestamp. Used to record when data was sent to be written.
"
  (("name" nil :id 1 :type binary)
   ("value" nil :id 2 :type binary)
   ("timestamp" nil :id 3 :type i64)))

(thrift:def-struct "supercolumn"
  "A named list of columns.
@param name. see Column.name.
@param columns. A collection of standard Columns.  The columns within a super column are defined in an adhoc manner.
                Columns within a super column do not have to have matching structures (similarly named child columns).
"
  (("name" nil :id 1 :type binary)
   ("columns" nil :id 2 :type (thrift:list (struct "column")))))

(thrift:def-struct "columnorsupercolumn"
  "Methods for fetching rows/records from Cassandra will return either a single instance of ColumnOrSuperColumn or a list
of ColumnOrSuperColumns (get_slice()). If you're looking up a SuperColumn (or list of SuperColumns) then the resulting
instances of ColumnOrSuperColumn will have the requested SuperColumn in the attribute super_column. For queries resulting
in Columns, those values will be in the attribute column. This change was made between 0.3 and 0.4 to standardize on
single query methods that may return either a SuperColumn or Column.

@param column. The Column returned by get() or get_slice().
@param super_column. The SuperColumn returned by get() or get_slice().
"
  (("column" nil :id 1 :type (struct "column") :optional t)
   ("super_column" nil :id 2 :type (struct "supercolumn") :optional t)))

(thrift:def-exception "notfoundexception"
  "A specific column was requested that does not exist.
"
  ())

(thrift:def-exception "invalidrequestexception"
  "Invalid request could mean keyspace or column family does not exist, required parameters are missing, or a parameter is malformed.
why contains an associated error message.
"
  (("why" nil :id 1 :type string)))

(thrift:def-exception "unavailableexception"
  "Not all the replicas required could be created and/or read.
"
  ())

(thrift:def-exception "timedoutexception"
  "RPC timeout was exceeded.  either a node failed mid-operation, or load was too high, or the requested op was too large.
"
  ())

(thrift:def-exception "authenticationexception"
  "invalid authentication request (user does not exist or credentials invalid)
"
  (("why" nil :id 1 :type string)))

(thrift:def-exception "authorizationexception"
  "invalid authorization request (user does not have access to keyspace)
"
  (("why" nil :id 1 :type string)))

(thrift:def-struct "columnparent"
  "ColumnParent is used when selecting groups of columns from the same ColumnFamily. In directory structure terms, imagine
ColumnParent as ColumnPath + '/../'.

See also <a href='cassandra.html#Struct_ColumnPath'>ColumnPath</a>
"
  (("column_family" nil :id 3 :type binary)
   ("super_column" nil :id 4 :type binary :optional t)))

(thrift:def-struct "columnpath"
  "The ColumnPath is the path to a single column in Cassandra. It might make sense to think of ColumnPath and
ColumnParent in terms of a directory structure.

ColumnPath is used to looking up a single column.

@param column_family. The name of the CF of the column being looked up.
@param super_column. The super column name.
@param column. The column name.
"
  (("column_family" nil :id 3 :type binary)
   ("super_column" nil :id 4 :type binary :optional t)
   ("column" nil :id 5 :type binary :optional t)))

(thrift:def-struct "slicerange"
  "A slice range is a structure that stores basic range, ordering and limit information for a query that will return
multiple columns. It could be thought of as Cassandra's version of LIMIT and ORDER BY

@param start. The column name to start the slice with. This attribute is not required, though there is no default value,
              and can be safely set to '', i.e., an empty byte array, to start with the first column name. Otherwise, it
              must a valid value under the rules of the Comparator defined for the given ColumnFamily.
@param finish. The column name to stop the slice at. This attribute is not required, though there is no default value,
               and can be safely set to an empty byte array to not stop until 'count' results are seen. Otherwise, it
               must also be a valid value to the ColumnFamily Comparator.
@param reversed. Whether the results should be ordered in reversed order. Similar to ORDER BY blah DESC in SQL.
@param count. How many keys to return. Similar to LIMIT 100 in SQL. May be arbitrarily large, but Thrift will
              materialize the whole result into memory before returning it to the client, so be aware that you may
              be better served by iterating through slices by passing the last value of one call in as the 'start'
              of the next instead of increasing 'count' arbitrarily large.
"
  (("start" nil :id 1 :type binary)
   ("finish" nil :id 2 :type binary)
   ("reversed" nil :id 3 :type bool)
   ("count" 100 :id 4 :type i32)))

(thrift:def-struct "slicepredicate"
  "A SlicePredicate is similar to a mathematic predicate (see http://en.wikipedia.org/wiki/Predicate_(mathematical_logic)),
which is described as 'a property that the elements of a set have in common.'

SlicePredicate's in Cassandra are described with either a list of column_names or a SliceRange.  If column_names is
specified, slice_range is ignored.

@param column_name. A list of column names to retrieve. This can be used similar to Memcached's 'multi-get' feature
                    to fetch N known column names. For instance, if you know you wish to fetch columns 'Joe', 'Jack',
                    and 'Jim' you can pass those column names as a list to fetch all three at once.
@param slice_range. A SliceRange describing how to range, order, and/or limit the slice.
"
  (("column_names" nil :id 1 :type (thrift:list binary) :optional t)
   ("slice_range" nil :id 2 :type (struct "slicerange") :optional t)))

(thrift:def-struct "keyrange"
  "The semantics of start keys and tokens are slightly different.
Keys are start-inclusive; tokens are start-exclusive.  Token
ranges may also wrap -- that is, the end token may be less
than the start one.  Thus, a range from keyX to keyX is a
one-element range, but a range from tokenY to tokenY is the
full ring.
"
  (("start_key" nil :id 1 :type binary :optional t)
   ("end_key" nil :id 2 :type binary :optional t)
   ("start_token" nil :id 3 :type string :optional t)
   ("end_token" nil :id 4 :type string :optional t)
   ("count" 100 :id 5 :type i32)))

(thrift:def-struct "keyslice"
  "A KeySlice is key followed by the data it maps to. A collection of KeySlice is returned by the get_range_slice operation.

@param key. a row key
@param columns. List of data represented by the key. Typically, the list is pared down to only the columns specified by
                a SlicePredicate.
"
  (("key" nil :id 1 :type binary)
   ("columns" nil :id 2 :type (thrift:list (struct "columnorsupercolumn")))))

(thrift:def-struct "deletion"
  (("timestamp" nil :id 1 :type i64)
   ("super_column" nil :id 2 :type binary :optional t)
   ("predicate" nil :id 3 :type (struct "slicepredicate") :optional t)))

(thrift:def-struct "mutation"
  "A Mutation is either an insert, represented by filling column_or_supercolumn, or a deletion, represented by filling the deletion attribute.
@param column_or_supercolumn. An insert to a column or supercolumn
@param deletion. A deletion of a column or supercolumn
"
  (("column_or_supercolumn" nil :id 1 :type (struct "columnorsupercolumn") :optional t)
   ("deletion" nil :id 2 :type (struct "deletion") :optional t)))

(thrift:def-struct "tokenrange"
  (("start_token" nil :id 1 :type string)
   ("end_token" nil :id 2 :type string)
   ("endpoints" nil :id 3 :type (thrift:list binary))))

(thrift:def-struct "authenticationrequest"
  "Authentication requests can contain any data, dependent on the AuthenticationBackend used
"
  (("credentials" nil :id 1 :type (thrift:map string string))))

(thrift:def-service "Cassandra" nil
  (:method "login" ((("keyspace" string 1) ("auth_request" (struct "authenticationrequest") 2)) void)
   :exceptions (("authnx" nil :id 1 :type (struct "authenticationexception"))
   ("authzx" nil :id 2 :type (struct "authorizationexception"))))
  (:method "get" ((("keyspace" string 1) ("key" binary 2) ("column_path" (struct "columnpath") 3) ("consistency_level" (enum "ConsistencyLevel") 4)) (struct "columnorsupercolumn"))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("nfe" nil :id 2 :type (struct "notfoundexception"))
   ("ue" nil :id 3 :type (struct "unavailableexception"))
   ("te" nil :id 4 :type (struct "timedoutexception")))
   :documentation "Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
the only method that can throw an exception under non-failure conditions.)
")
  (:method "get_slice" ((("keyspace" string 1) ("key" binary 2) ("column_parent" (struct "columnparent") 3) ("predicate" (struct "slicepredicate") 4) ("consistency_level" (enum "ConsistencyLevel") 5)) (thrift:list (struct "columnorsupercolumn")))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
")
  (:method "multiget" ((("keyspace" string 1) ("keys" (thrift:list binary) 2) ("column_path" (struct "columnpath") 3) ("consistency_level" (enum "ConsistencyLevel") 4)) (thrift:map binary (struct "columnorsupercolumn")))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "Perform a get for column_path in parallel on the given list<string> keys. The return value maps keys to the
ColumnOrSuperColumn found. If no value corresponding to a key is present, the key will still be in the map, but both
the column and super_column references of the ColumnOrSuperColumn object it maps to will be null.
@deprecated; use multiget_slice
")
  (:method "multiget_slice" ((("keyspace" string 1) ("keys" (thrift:list binary) 2) ("column_parent" (struct "columnparent") 3) ("predicate" (struct "slicepredicate") 4) ("consistency_level" (enum "ConsistencyLevel") 5)) (thrift:map binary (thrift:list (struct "columnorsupercolumn"))))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "Performs a get_slice for column_parent and predicate for the given keys in parallel.
")
  (:method "get_count" ((("keyspace" string 1) ("key" binary 2) ("column_parent" (struct "columnparent") 3) ("consistency_level" (enum "ConsistencyLevel") 4)) i32)
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "returns the number of columns for a particular <code>key</code> and <code>ColumnFamily</code> or <code>SuperColumn</code>.
")
  (:method "get_range_slice" ((("keyspace" string 1) ("column_parent" (struct "columnparent") 2) ("predicate" (struct "slicepredicate") 3) ("start_key" binary 4) ("finish_key" binary 5) ("row_count" i32 6) ("consistency_level" (enum "ConsistencyLevel") 7)) (thrift:list (struct "keyslice")))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "returns a subset of columns for a range of keys.
@Deprecated.  Use get_range_slices instead
")
  (:method "get_range_slices" ((("keyspace" string 1) ("column_parent" (struct "columnparent") 2) ("predicate" (struct "slicepredicate") 3) ("range" (struct "keyrange") 4) ("consistency_level" (enum "ConsistencyLevel") 5)) (thrift:list (struct "keyslice")))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "returns a subset of columns for a range of keys.
")
  (:method "insert" ((("keyspace" string 1) ("key" binary 2) ("column_path" (struct "columnpath") 3) ("value" binary 4) ("timestamp" i64 5) ("consistency_level" (enum "ConsistencyLevel") 6)) void)
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "Insert a Column consisting of (column_path.column, value, timestamp) at the given column_path.column_family and optional
column_path.super_column. Note that column_path.column is here required, since a SuperColumn cannot directly contain binary
values -- it can only contain sub-Columns.
")
  (:method "batch_insert" ((("keyspace" string 1) ("key" binary 2) ("cfmap" (thrift:map binary (thrift:list (struct "columnorsupercolumn"))) 3) ("consistency_level" (enum "ConsistencyLevel") 4)) void)
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "Insert Columns or SuperColumns across different Column Families for the same row key. batch_mutation is a
map<binary, list<ColumnOrSuperColumn>> -- a map which pairs column family names with the relevant ColumnOrSuperColumn
objects to insert.
@deprecated; use batch_mutate instead
")
  (:method "remove" ((("keyspace" string 1) ("key" binary 2) ("column_path" (struct "columnpath") 3) ("timestamp" i64 4) ("consistency_level" (enum "ConsistencyLevel") 5)) void)
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
")
  (:method "batch_mutate" ((("keyspace" string 1) ("mutation_map" (thrift:map binary (thrift:map binary (thrift:list (struct "mutation")))) 2) ("consistency_level" (enum "ConsistencyLevel") 3)) void)
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception"))
   ("ue" nil :id 2 :type (struct "unavailableexception"))
   ("te" nil :id 3 :type (struct "timedoutexception")))
   :documentation "  Mutate many columns or super columns for many row keys. See also: Mutation.

  mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
*
")
  (:method "get_string_property" ((("property" string 1)) string)
   :documentation "get property whose value is of type string. @Deprecated
")
  (:method "get_string_list_property" ((("property" string 1)) (thrift:list string))
   :documentation "get property whose value is list of strings. @Deprecated
")
  (:method "describe_keyspaces" (() (thrift:set string))
   :documentation "list the defined keyspaces in this cluster
")
  (:method "describe_cluster_name" (() string)
   :documentation "get the cluster name
")
  (:method "describe_version" (() string)
   :documentation "get the thrift api version
")
  (:method "describe_ring" ((("keyspace" string 1)) (thrift:list (struct "tokenrange")))
   :exceptions (("ire" nil :id 1 :type (struct "invalidrequestexception")))
   :documentation "get the token ring: a map of ranges to host addresses,
represented as a set of TokenRange instead of a map from range
to list of endpoints, because you can't use Thrift structs as
map keys:
https://issues.apache.org/jira/browse/THRIFT-162

for the same reason, we can't return a set here, even though
order is neither important nor predictable.
")
  (:method "describe_keyspace" ((("keyspace" string 1)) (thrift:map string (thrift:map string string)))
   :exceptions (("nfe" nil :id 1 :type (struct "notfoundexception")))
   :documentation "describe specified keyspace
")
  (:method "describe_splits" ((("start_token" string 1) ("end_token" string 2) ("keys_per_split" i32 3)) (thrift:list string))
   :documentation "experimental API for hadoop/parallel query support.
may change violently and without warning.

returns list of token strings such that first subrange is (list[0], list[1]],
next is (list[1], list[2]], etc.
"))
