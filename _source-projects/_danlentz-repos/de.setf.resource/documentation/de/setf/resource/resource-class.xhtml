<?xml version='1.0' standalone='no' ?><!DOCTYPE xhtml PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns='http://www.w3.org/1999/xhtml'>  <head>   <meta name='date' content='20100625T034720' />       <meta http-equiv='Content-Type' content='text/xhtml;charset=iso-8859-1' />       <link href='../../../documentation.css' rel='stylesheet' type='text/css' />       <title>FILE: resource-class    </title>   </head><body><div class='file'><div class='type'>File</div><div class='name'>resource-class.lisp</div><hr /><div class='indexHeading'><span><a href='#index_A'>A</a> </span><span><a href='#index_C'>C</a> </span><span><a href='#index_F'>F</a> </span><span><a href='#index_I'>I</a> </span><span><a href='#index_M'>M</a> </span><span><a href='#index_P'>P</a> </span><span><a href='#index_R'>R</a> </span><span><a href='#index_S'>S</a> </span><span><a href='#index_T'>T</a> </span><span><a href='#index_V'>V</a> </span></div><hr /><div class='documentation'>This file defines the meta-classes for the `de.setf.resource` CLOS linked data library.</div><div class='documentation'>`de.setf.resource` combines several precedents to layer CLOS-MOP metaclass support for RDF schemas onto  a Lisp triple store interface, to map typed, class-based CLOS models onto a persistent triple store, and project data between CLOS class extensions and RDF graphs. It allows class declarations to specify the correspondence between a class' attributes and RDF's predicated properties and uses a combination of default rules and CLOS / RDF-schema introspection provides internal/external identification both at the level of individual instances and at the class/type level. Eventual inconsistencies and adhoc variations are managed through a combination of convention and application-handled exceptions. The implementation draws on a number of precedents. On one hand the immediate Lisp-RDF interfaces like wilbur, swclos, and allegro-graph provide concrete statement-level access to <a href='../../../../../../../../#triple' class='reference class'>triple</a> stores. On the other, higher-level object-persistence libraries, such as the the CL-SQL, PLOB, Elephant packages in Lisp, and implementations such as spira in Ruby, and JDO in Java demonstrate how to use metadata to support object persistence. Each of the object persistence precedents is considered in turn, in order to provide some background to the implementation. - WOOD[6]: Neglecting proprietary implementation such as STATICE and Object-Store, of which the proprietary nature limits a technical evaluation, one of the earliest object-persistence implementation was WOOD for MCL. WOOD provided a runtime-specific mapping between Lisp data and a continuously updated disk projection. - PLOB[5] implemented metaclass-based persistence based on a ? backend by altering instantiation and slot accessors to map instance slots onto records on the <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> store. - CLSQL provided a instance-based coded similar to PLOB, but re-targeted the backend towards relational  databases with SQL interfaces. (backaneds?) BKNR Datastore[http://www.cl-user.net/asp/libs/bknr] CL-PREVELANCE[http://www.cl-user.net/asp/libs/cl-prevalence]  XML-based externalization. Suggested that the requirements of web service architectures were better served by a mechanism which just projected snapshots of a servers state onto a <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> image, resurrecting the WOOD proposition, but for a broader runtime range. instance/slot encoding as alternating elements. Elephant[3] : O-Btree - slot-value codec Rucksack[4] : another O-R instance-record codec, this time based on it's own <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> heap. The principal distinctions are in two dimensions: - record v/s attribute based - intrinsic keys Comparing general persistence architectures:[2] The RDF-based persistence architecture is analogous to that of elephant, in that the object is decimated into its slots. where elephant identifies each slot value with a _serialized descriptor_ which comprises the class, a class-relative oid, and the slot name, in an RDF store each subject is designated with an URI, which is logically independent of the class, and each slot value is specified with a predicate, which is logically independent of the slot name.  The mop issues are not strictly relevant, since any change is reflected in a <a href='utilities.xhtml#new' class='reference class'>new</a> vrsion. ! the elephant architecture description says that the oid designates the instance independent of the class facet. the latter is used only if necessary to instantiate - but then, there's no reason to indluce it in the slot key. ! the <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> slots have no in-memory, bound representation - all access is delegated to the respective storage controller. this means that a life-cycle like jdo - where the persistence is dynamic, cannot be implemented unless the conversion is effectively a change-class ! they also do not manage <a href='utilities.xhtml#transient' class='reference class'>transient</a> slots as part of a transaction. this is one thing which the jdo life-cycle does a persistence architecture: there are three aspects: - codecs/externalization/serialization - object identity / relationships / designation - transaction / lifecycle the ancillary issues are subsumed - caching by identity mechanisms - evolution by versioned identity - indexing is entirely handled by the store don't bother with slot-value-using-class, encode the protocol in the accessors. proxies are not necessary if the instance itself has a full life-cycle. extra prodicates can either signal an error or subclass with the additional slot - a single catchall class? property-value-using-class is also not necessary, as the properties are prototypical, which means they vary by instance. each instance is named. in the spira example the instance name and the value of the 'name' attribute were similar, but actually unrelated. The instane uri was extrinsic. In order to support intrinsic uri, the class requires a compute-uri operator which can be applied to the instance to generate the uri on demand in order to name the <a href='utilities.xhtml#new' class='reference class'>new</a> instance in the store and applied to an initialization argument list to find an external instance in the store. in which classes represents the direct content of a <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> relations as well as relational references on the basis of declared immediate data and foreign key attributes. The approach is similar to other object-relational mappings - such as CL-SQL, but stands apart in that the projection is expressed concisely in terms integrated with Ruby's object model. Elephant, sets a similar goal, to project CLOS class extensions onto a <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> store, but targets a key-value store, rather than relational. Which means that slot values exist as isolated attributes, each of which is independently associated with an instance. Any one of the direct Lisp RDF interfaces which make data available as triples, suffices as the primitive access layer for this projection. Both wilbur, and allegro-store afford sufficient access to a <a href='../../../../../../../../#triple' class='reference class'>triple</a> store. In the first case an in-memory store, in the second both immediate and  <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> stores. Identification -------------- The core of CLOS/RDF projection is a mechanism which correlates instances in the value and the type domains. In the type domain, it relates CLOS class names to resource identifiers for RDF schema classes. In the value domain, it relates CLOS object identity to RDF subject resource identifiers. By convention, URI are treated externally as _mostly_ opaque identifiers [http://rest.blueoxen.net/cgi-bin/wiki.pl?JeffBone][http://www.w3.org/DesignIssues/Axioms.html], with the exception, that a <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a> component is designated with a fragment identifier relative to absolute URI which designates the <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a> in its entirety. `de.setf.resource` follows this convention when managing class definitions by associating each <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a> with a package according to the absolute URI for the vocabulary namespace and using symbols constructed from vocabulary terms and interned in the respective package as the name for classes. The convention is extended to cover instances by identifying each with a URI which appends an UUID to the class URI as the fragment query parameter ID. For example, for a FOAF person, for which the scheam class uri is    http://xmlns.com/foaf/0.1/Person an instance would be identified as      http://xmlns.com/foaf/0.1/Person?UUID=1234567812345678 while a beer ontology brewery, for which the schema class URI is    http://www.purl.org/net/ontology/beer#Brewery would be    http://www.purl.org/net/ontology/beer#Brewery?UUID=8765432187654321 The ambiguity which arises between the query parameters and the fragment parameters could be avoided by adding url syntax rules specific to the identity, but it is simpler to just rely on its suffix position. generating uri - Java2RDF[http://www.agentgroup.unimo.it/wiki/index.php/Java2RDF_tool] class base + name with the default name being the result of hashcode(); - Jenabean[http://code.google.com/p/jenabean/] (ref from Java2RDF as the more popular), requierd the URI as a class construction parameter. - sayers-2002 : compute the identifier from the content [http://www.hpl.hp.com/techreports/2002/HPL-2002-216.pdf] enforces versioning implicitly, with the additions laterVersion / earlierVersion predicate; could be generated from the predicate+object content without subject uri replacement. - UUID combination: compute an uuid from the schema url for the class' term, use that as the namespace uri for a type 3/5 in combination with a time-based uuuid as the individual name Protocol -------- rdf:make-instance (class &amp;rest initargs) :  Create a <a href='utilities.xhtml#new' class='reference class'>new</a> instance. The default protocol is standard CLOS cl:standard-class instantiation protocol.  No additional slot value processing occurs beyond distinguishing the the initial state as modified-new  if arguments were provided.  The <a href='utilities.xhtml#new' class='reference class'>new</a> instance is <a href='utilities.xhtml#transient' class='reference class'>transient</a>. It must either be registered with the store or bound to a slot in an  already <a href='utilities.xhtml#persistent' class='reference class'>persistent</a> instance.  No identifier is generated until the instance is written to the store. rdf:find-instance (class . designators) :  Retrieve the designated instance from the class' persistence store. rdf:find-instance-with-store (class store . designators) :  Retrieve the designated instance of the given class from the given persistence store.  The resource can be designated with a URI, or it can be specified by associations, in which case  the related subject URI are retrieved, to be used as resource designators. count, offset, and order-by  parameters arrange and subset the result. an if-does-not-exist parameter determines whether a null result  signals an error. rdf:make-class (designator) :  instantiates a class. The designator can be a Lisp class designator, an RDF schema URI or symbol, or  a set of attributes. In the first case the standard CLOS protocol applies. In the case of a schema  class name, the designator is interned as the equivalent Lisp symbol and treated as such. In the case  of an attribute set, the closest structural match is found and that class is used - with possible  prototype extensions. rdf:project-graph (source destination)  Project data between instance and rdf models. Permitted (source x destination) combinations are    (<a href='resource-object.xhtml#resource-object' class='reference class'>resource-object</a> store)    ((set <a href='resource-object.xhtml#resource-object' class='reference class'>resource-object</a>) store)    ((set statement) (<a href='#resource-class' class='reference class'>resource-class</a> + <a href='resource-object.xhtml#resource-object' class='reference class'>resource-object</a>))    (query (store + <a href='#resource-class' class='reference class'>resource-class</a>))  When a <a href='resource-object.xhtml#resource-object' class='reference class'>resource-object</a> is projected onto a store, the first step is to construct a URI for it.  The operation is delegated from the respective instance's class to its bound class-compute-uri-function.  Two implementation are available: compute-temporal-uri and compute-content-uri.  The first method generates a time-dependent UUID based on the system time and the network node <a href='../../../../../../../../#id' class='reference function'>id</a>.  This is unique to the granularity if a type-1 UUID.  The second method computes a hash of the instance's state and combines that with the class' schema's  namespace as a type-5 UUID. In order to ensure uniqueness, one facet of the state is the previous  identity, for which the intial value is a type-1 UUID. Update conflicts are indicated by asserting a  nextVersion in the same transaction, for which a uniqueness constraint exists on the <a href='interface.xhtml#subject' class='reference function'>subject</a> <a href='interface.xhtml#uri' class='reference function'>URI</a>.  An alternative to the opaque <a href='interface.xhtml#uri' class='reference function'>URI</a> form, the UUID is attached to the namespace <a href='interface.xhtml#uri' class='reference function'>URI</a> for the class'  vocabulary as a fragment parameter.  The first forms provide the quality, that the <a href='interface.xhtml#uri' class='reference function'>URI</a> is completely opaque. In the first version it can be generated  entirely independent of the store. The latter three forms require knowledge of the schema <a href='interface.xhtml#uri' class='reference function'>URI</a> to form  the UUID and/or <a href='interface.xhtml#uri' class='reference function'>URI</a> stem. slot access (reader / writer ) :  Access to instance attributes is through accessor functions. The storage is implemented as slots for  attributes which are specified in a direct schema and/or class declaration. Other slots are bound as an  ad-hoc prototypical property list as they appear. These include slots which are defined external to the  primary <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a> specification, as their presence is not guaranteed, and thus cannot be an aspect of   the nominal typing.  The accessors use a method combination to wrap standard combination pattern for predicated slots.  If the instance is <a href='utilities.xhtml#new' class='reference class'>new</a>, slot modification effects a switch to modified-new state.  If the instance is <a href='utilities.xhtml#persistent' class='reference class'>persistent</a>, read access caues the transition <a href='utilities.xhtml#hollow' class='reference class'>hollow</a> -> <a href='utilities.xhtml#stored' class='reference class'>stored</a>, which reads immediate  triples associated with the instance as subject, interns and binds literal values, and caches <a href='interface.xhtml#uri' class='reference function'>URI</a>  values for eventual resolution. Support could be added for access attibutes and groups to delay/accellerate  access to individual slots or slot groups. decode-instance (instance slots source) :  decode the instance from the stream or tuple-set, instance can be a class.  in order to all hollow/stored loading, the slots can restrict the retrieval/modification to a subset of  the class' complement. the value, t, indicates all slots. encode-instance (instance slots destination) : send the instane's tuples to the destination  can also be used for list-tupls delete-instance (instance) : removes it from the cache ? ends it's temporal limit? save-instance (instance) : encodes the object to the store independent of transactions MOP Support ----------- The CLOS MOP class instantiation protocol offers exactly one opportunity in the slot definition process to elect the slot definition class and none to generate the initargs. this means that all effective slot definitions for a given class must be of the same class and the additional declaration attributes must be incorporated in an :after or :around method for the compute-effective-slot-definition function. some implementations add operators to compute the initargs, but they are not standard. Literal slot values are internalized/externalized according to a data flow implemented in the rdf:internalize-value and rdf:externalize-value functions. Reference slot values require further retrieval according to the immediate <a href='interface.xhtml#uri' class='reference function'>URI</a> and construction of the respective instances to comprise the related attributes. This process employes either the declared slot datatype, the type furnished by the store in relation to the subject, of introspective analysis of available classes (see rdf:find-class). Persistence Mediation --------------------- Despite the RDF </div><div class='documentation'><div class='name'><a href='#open-world' style='margin-right: 0.5em'>open-world </a></div></div><div class='documentation'>paradigm, which requires a processing mechanism accommodate unforseen data, it is imperative that a store mediator afford an application a stable projection of unpredicatable content. If a CLOS application is to rely on class and generic function definitions to behave as intended, they must be bound to data as it appears, `de.setf.resource` serves this goal in several ways: - it implements instance identity within a given mediation interface according to subject URI - it provides for automatic unique instance URI generation within a transactional context - it treats symbols, universal names, and URI as equivalent - it accepts resources descriptions without nominal type indications, reconciles them to the know class structure and admits additional prototypical attributes. + instance identity, indexing, and caching Each store mediator adopts the respective store's interened URI 'nodes' as unifying identifiers to ensure a one-to-one relation between identified objects and external resources. The URI serve as keys in an hash table which is used in query operations to yield identical instances for equivalent URI. The cache is not held weak, as the store's URI designator-to-node cache is itself static. Query operations are expressed either in terms of predicate property lists or query expressions. Both cases are translated into a store's native query interface without any additional internal indexing. The mediator only unifies resource designators with its identity cache when instantiating the resulting objects. + representing resources Every <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a> defines a base uri and a syntax which permits a specific uri reference for each resource class defined by the <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a>. As discussed above (see Identification), these type identifiers can either be augmented direct catenation with a UUID to serve as unique, structured instance identifiers, or they can be combined with an initial UUID to serve as an opaque identifier. Each store implementation supports its own representation for URI - which would include UUID.  URI references can be expressed in absolute terms in all implementations as inflected strings, that is, as character sequences adjacent to syntax markers in additon to or instead of the double quote characters used in the standard i/o syntax. Wilbur preceeeds a standard string representation with the additional '!' marker, while allegrograph encloses he URI namestring with '&lt;' '>' and preceeds tha sequence with a '!'. In addition the store implementations support the  RDF encoding as qualified names ('Q-Names') by permitting definition of namespace prefix bindings and interpreting the universal name designated by a Q-Name as equivalent to the URI with the same namestring. The representation models, one the other hand are not compatible, and, in the case of allegrograph, the model is not closed. That is a process cannot expect a URI decoded by wilbur to be recognized as such by allegrograph and even allegrograph itself is not consistent. For example, for wilbur,    ? (eq !"http://www.w3.org/1999/02/22-rdf-syntax-ns#type" !rdf:type)    t while for allegrograph suggests a similar equivalence exists here between uri and qualified names, but with the restriction that they are not actually eq:    TRIPLE-STORE-USER(31): (eq !&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type> !rdf:type)    NIL    TRIPLE-STORE-USER(32): (eq (triple-store:resource "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") !rdf:type)    NIL    TRIPLE-STORE-USER(33): (part= (triple-store:resource "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") !rdf:type)    t The representation for resources also differs markedly between implementations.  allegrograph represents _triples_ as an opaque byte sequence with five aspects: subject, predicate, object, graph, and triple id - almost as if the object is a displaced subsequence of the i/o buffers. Of these, URI, literals, and blank nodes are each reduced to a twelve-byte _part identifier_. Wilbur, on the other hand represents quads as sructures which comprise subject, predicate, object, and graph. The mediator implementation reconcile these differences by supporting symbols as the universal URI representation and providing standard operatro interfaces in terms of resource-object classes, instances, and propeties. --- [1] : http://github.com/datagraph/spira [2] : http://common-lisp.net/pipermail/elephant-devel/2006-June/000446.html [3] : http://common-lisp.net/project/elephant/documentation.html [4] : http://weitz.de/eclm2006/rucksack-eclm2006.txt [5] : http://plob.sourceforge.net/ [6] : http://www-cgi.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/ext/wood/0.html dc foaf doap skos sioc rdf rdfs owl 'rss 1.0' cc  ---</div><div class='documentation'><div class='name'><a href='#rdf-relation-definition' style='margin-right: 0.5em'>rdf-relation-definition </a></div></div><div class='documentation'>The essence of RDF is names relations between entities. The relation is asymmetrical, in that one entity, the 'subject', must be an identified resource, while the other can be either a resource of an anonymous literal. The relation predicate is always a resource. This library represents the resources as CLOS instances and designates them in RDF statements with symbols and UUID instances. The literals are represted with standard lisp data objects. A resource and its related entities, is defined with a CLOS class. The archetypal class' structure is captured in direct slot definitions which add several attributes to the standard CLOS complement: - predicate - datatype - element-datatype - reader - writer - encoder - decoder These slots are distinguished by the presence of datatype and/or predicate arguments in the slot declaration. Default values are computed for the other attributes is none is declared. The hierarchy distinguishes the archetypal from the prototypal properties, and the literal from the resource properties. A mirror slot is provided for the archetypal slot to describe respective slots to store statement instances. - rdf-relation-definition   - rdf-direct-relation-definition     - rdf:<a href='#archetypal-property-definition' class='reference class'>archetypal-property-definition</a>       ;; - rdf-archetypal-literal-property-definition       ;; - rdf-archetypal-resource-property-definition     - rdf:<a href='#prototypal-property-definition' class='reference class'>prototypal-property-definition</a>   - rdf-effective-property-definition   - rdf-statement-slot-definition The terms resource, property, literal, and reference and the respective definitions are taken from the various recommendations[1,2,3] The earliest of which makes an explict distinction between resources and literals, but the later ones fail to maintain it, and express it only indirectly. For example in the rdf schema explanatory figures 1 and 2, the rdfs:Literal _class_ is indicated to be of 'type' rdfs:Resource, but there are no examples which explain that an _instance_ the literal class is _not_ of _type_ rdfs:Resource. The names for these property definition classes are chosen consistent with the 1999 terms, as they are the most explicit. The most general description is of a `relation`. Of those, the primary distinction is between a direct definitions - those which represent the declaration for a specific class or instance, and an effective definition - those which combine all definitions from precedent classes into the complete set for a concrete class. The access protocol is governed by the direct definitions, which comprise the predicate and datatype specification. Of the direct definitions, the next distinction is between the archetypal definitions, which describe slots which are specified in a class definition to bind data objects, and the prototypal definitions, which are added to individual instances to bind data in addition to the respective class definition. Finally, of the archetypal property definitions, a distinction is made between literal and resource data. In addition a statement slot is associated with each archetypal property to bind the applied statement(s). The declared slot type distinguishes elementary resources from resource sets. Where the type cons or one of its structural subtypes appears, eg. (cons {foaf}Person), the collection relation is modeled as a list. Internal prototypal properties are managed with a specialized rdf:<a href='#prototypal-property-definition' class='reference class'>prototypal-property-definition</a> class in order to recognize them when unbinding values. The distinction between literal and resource properties can be specified in the declarations in terms of encoding and decoding operators. Absent declarations the distinction is made based on the type of the declared datatype with recourse to the respective store, should the type be unknown. The determination is delayed until the time of the first actual slot reference in order to permit circular type references. --- [1]: http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/#model [2]: http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/ [3]: http://www.w3.org/TR/2000/CR-rdf-schema-20000327/#s2.2 </div><div class='documentation'><div class='name'><a href='#class-source' style='margin-right: 0.5em'>class-source </a></div></div><div class='documentation'><div class='name'><a href='#class-datatype' style='margin-right: 0.5em'>class-datatype </a></div></div><div class='documentation'><div class='name'><a href='#class-vocabulary' style='margin-right: 0.5em'>class-vocabulary </a></div></div><div class='documentation'>Various class attributes are specified alternatively - in the class definition proper or via a superclass - as literal argument values or as designators to be resolved upon first reference. The first variation is handled by accessors which check if the slot is bound. If not they search the inheritance chain for an initial value. The second variation is handled by splitting the slot between the active slot and the direct slot. The active slot value is computed by resolving whatever value is inherited over direct slots. The resolution is delayed until first reference in order to permit values to depend on the existence of a source to mediate access to the store.</div><div class='documentation'>An archetypal model can be exteneded in two ways: declarative and ad-hoc. - Declarative concerns the  association between defined operators and instance properties. In this case, the function class prepares the operator to be self-extending to comprehend given classes. The generated operators delegate to the <a href='../../../../../../../../#(setf property-value)' class='reference function'>property-value</a> opertors to effect the access. This leaves operators which are not declared to be extending to signal errors. By default, any slot declared to be a resource slot is associated with self-extending accessors. - The ad-hoc aspect concerns the <a href='../../../../../../../../#(setf property-value)' class='reference function'>property-value</a> operator, which can be used on its own to cause prototype delegation and/or extension as well as the base operator for a slot reader/writer.</div><hr /><div class='indexLetter'><a name='index_A'>A</a></div><div class='function'><a name='archetypal-property-definition'><div class='type'>Generic Function</div><div class='name'>archetypal-property-definition</div><div class='parameters'> designator  &amp;rest  args </div></a><div class='documentation'>Construct a ARCHETYPAL-PROPERTY-DEFINITION given initialization arguments. The first argument may be a keyword, in which case the value of *CLASS.ARCHETYPAL-PROPERTY-DEFINITION* designate the class, or it may be a class designator. In other cases, the first argument is interpreted as a context to dereference the respective <a href='#archetypal-property-definition' class='reference class'>ARCHETYPAL-PROPERTY-DEFINITION</a>.</div></div><hr /><div class='class'><a name='archetypal-property-definition'><div class='type'>Class</div><div class='name'>archetypal-property-definition</div><div class='superclasses'>( rdf-direct-relation-definition )</div></a><div class='documentation'>Describes persistent property slots.  Each is paired with a statement slot which caches the statement and must arrange to synchronize that with any instance value.</div><div class='slots'><div class='slot'><div class='name'><a name='#statement-slot'>statement-slot</a></div>[t]</div><div class='slot'><div class='name'><a name='#list-type-p'>list-type-p</a></div>[t]</div></div></div><hr /><div class='method' name='archetypal-property-definition' ID='archetypal-property-definition'><div class='type'>Method</div><div class='name'><a href='#archetypal-property-definition'>archetypal-property-definition</a>   </div><div class='parameters'> (instance archetypal-property-definition) &amp;key &amp;allow-other-keys</div><div class='documentation'></div></div><hr /><div class='function'><a name='archetypal-property-definition-p'><div class='type'>Generic Function</div><div class='name'>archetypal-property-definition-p</div><div class='parameters'> datum </div></a><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_C'>C</a></div><div class='method' name='canonicalize-initarg' ID='canonicalize-initarg'><div class='type'>Method</div><div class='name'>canonicalize-initarg   </div><div class='parameters'> (class abstract-resource-class) (arg vocabulary) (value vocabulary)</div><div class='documentation'></div></div><hr /><div class='method' name='class-datatype' ID='class-datatype'><div class='type'>Method</div><div class='name'>class-datatype   </div><div class='parameters'> (class resource-class)</div><div class='documentation'></div></div><hr /><div class='function'><a name='class-direct-source'><div class='type'>Generic Function</div><div class='name'>class-direct-source</div><div class='parameters'> x </div></a><div class='documentation'>Augment the slot reader with alternative methods for designators and for other    classes in the precedence list.</div></div><hr /><div class='function'><a name='class-property-slots'><div class='type'>Generic Function</div><div class='name'>class-property-slots</div><div class='parameters'> class </div></a><div class='documentation'></div></div><hr /><div class='function'><a name='class-source'><div class='type'>Generic Function</div><div class='name'>class-source</div><div class='parameters'> class </div></a><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_F'>F</a></div><div class='method' name='finalize-inheritance' ID='finalize-inheritance'><div class='type'>Method</div><div class='name'>finalize-inheritance   </div><div class='parameters'> (class resource-class)</div><div class='documentation'></div></div><hr /><div class='method' name='find-class' ID='find-class'><div class='type'>Method</div><div class='name'><a href='interface.xhtml#find-class'>find-class</a>   </div><div class='parameters'> (class resource-class) (name symbol) &amp;key (error-p t)</div><div class='documentation'>GIven a concrete class, first delegate to the abstract version to look for sibling classes, then try the vocabularies loaded from the store. If none is found optionally signal an error.</div></div><hr /><div class='method' name='(setf find-instance)' ID='(setf find-instance)'><div class='type'>Method</div><div class='name'><a href='../../../../../../../../#(setf find-instance)'>(setf find-instance)</a>   </div><div class='parameters'> (instance t) (class resource-class) (identifier t)</div><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_I'>I</a></div><div class='method' name='initialize-instance' ID='initialize-instance'><div class='type'>Method</div><div class='name'>initialize-instance   </div><div class='parameters'> (instance prototypal-property-definition) &amp;rest initargs &amp;key name (predicate name)</div><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_M'>M</a></div><div class='function'><a name='make-archetypal-property-definition'><div class='type'>Function</div><div class='name'>make-archetypal-property-definition</div><div class='parameters'></div></a><div class='documentation'></div></div><hr /><div class='function'><a name='make-prototypal-property-definition'><div class='type'>Function</div><div class='name'>make-prototypal-property-definition</div><div class='parameters'></div></a><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_P'>P</a></div><div class='method' name='print-object' ID='print-object'><div class='type'>Method</div><div class='name'>print-object   </div><div class='parameters'> (object prototypal-property-definition) (stream t)</div><div class='documentation'></div></div><hr /><div class='function'><a name='prototypal-property-definition'><div class='type'>Generic Function</div><div class='name'>prototypal-property-definition</div><div class='parameters'> designator  &amp;rest  args </div></a><div class='documentation'>Construct a PROTOTYPAL-PROPERTY-DEFINITION given initialization arguments. The first argument may be a keyword, in which case the value of *CLASS.PROTOTYPAL-PROPERTY-DEFINITION* designate the class, or it may be a class designator. In other cases, the first argument is interpreted as a context to dereference the respective <a href='#prototypal-property-definition' class='reference class'>PROTOTYPAL-PROPERTY-DEFINITION</a>.</div></div><hr /><div class='class'><a name='prototypal-property-definition'><div class='type'>Class</div><div class='name'>prototypal-property-definition</div><div class='superclasses'>( rdf-relation-definition )</div></a><div class='documentation'>The rdf:prototypal-property-definition class combines the RDF predicate and datatype information with standard slot attributes, and augments them with a values facet in order to represent prototypal properties in addition to archetypal definitions which follow from the class definition.</div><div class='slots'><div class='slot'><div class='name'><a name='#name'>name</a></div>[t]</div><div class='slot'><div class='name'><a name='#type'>type</a></div>[t]</div><div class='slot'><div class='name'><a name='#statement'>statement</a></div>[t]</div><div class='slot'><div class='name'><a name='#value'>value</a></div>[t]</div><div class='slot'><div class='name'><a name='#permission'>permission</a></div>[(member t read-only)]</div></div></div><hr /><div class='function'><a name='prototypal-property-definition-p'><div class='type'>Generic Function</div><div class='name'>prototypal-property-definition-p</div><div class='parameters'> datum </div></a><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_R'>R</a></div><div class='class'><a name='rdf-slot-reader'><div class='type'>Class</div><div class='name'>rdf-slot-reader</div><div class='superclasses'>( standard-generic-function  rdf-slot-operator )</div></a><div class='documentation'></div><div class='slots'></div></div><hr /><div class='class'><a name='rdf-slot-writer'><div class='type'>Class</div><div class='name'>rdf-slot-writer</div><div class='superclasses'>( standard-generic-function  rdf-slot-operator )</div></a><div class='documentation'></div><div class='slots'></div></div><hr /><div class='class'><a name='resource-class'><div class='type'>Class</div><div class='name'>resource-class</div><div class='superclasses'>( abstract-resource-class )</div></a><div class='documentation'>The resource-class is the concrete metaclass for instantiated resource classes.    It adds the slots for concrete values for source, datatype, and <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a>.</div><div class='slots'><div class='slot'><div class='name'><a name='#source'>source</a></div>[t]<div class='documentation'>The default source for persistent instances of this individual class.     An initialized class may bind value to this slot. If not, it is determined on-demand as the most-specific     declared source in the class' precedence list.  The base class <a href='resource-object.xhtml#resource-object' class='reference class'>resource-object</a> specifies t as the base     value.</div></div><div class='slot'><div class='name'><a name='#vocabulary'>vocabulary</a></div>[t]<div class='documentation'>Attaches the vocabulary which includes this class, the namespace/package, and the     related class and datatype definitions. By default the <a href='vocabulary.xhtml#vocabulary' class='reference class'>vocabulary</a> which comprises the datatype.</div></div></div></div><hr /><div class='indexLetter'><a name='index_S'>S</a></div><div class='function'><a name='slot-definition-datatype'><div class='type'>Generic Function</div><div class='name'>slot-definition-datatype</div><div class='parameters'> definition </div></a><div class='documentation'></div></div><hr /><div class='function'><a name='slot-definition-predicate'><div class='type'>Generic Function</div><div class='name'>slot-definition-predicate</div><div class='parameters'> definition </div></a><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_T'>T</a></div><div class='method' name='type-of' ID='type-of'><div class='type'>Method</div><div class='name'><a href='interface.xhtml#type-of'>type-of</a>   </div><div class='parameters'> (class resource-class) (identifier t)</div><div class='documentation'></div></div><hr /><div class='indexLetter'><a name='index_V'>V</a></div><div class='method' name='validate-superclass' ID='validate-superclass'><div class='type'>Method</div><div class='name'>validate-superclass   </div><div class='parameters'> (c1 standard-class) (c2 resource-class)</div><div class='documentation'></div></div><hr /></div><hr /><div class='footer'><div style='float: left;'><img src='http://www.digitool.com/img/mcl-made-1.gif' /></div><div style='float: right;'> Copyright 2010 setf.de</div></div></body></html>