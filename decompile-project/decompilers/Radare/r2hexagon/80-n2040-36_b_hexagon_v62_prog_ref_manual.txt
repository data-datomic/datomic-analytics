Qualcomm Technologies, Inc.




Hexagon V62 Programmer's
Reference Manual

80-N2040-36 B
December 19, 2016




Qualcomm Hexagon is a product of Qualcomm Technologies, Inc. Other Qualcomm products referenced herein are products of Qualcomm
Technologies, Inc. or its subsidiaries.

Qualcomm and Hexagon are trademarks of Qualcomm Incorporated, registered in the United States and other countries. Other product and
brand names may be trademarks or registered trademarks of their respective owners.

This technical data may be subject to U.S. and international export, re-export, or transfer ("export"80-N2040-36 B) laws. Diversion contrary to
U.S. and international law is strictly prohibited.

                                                        Qualcomm Technologies, Inc.
                                                          5775 Morehouse Drive
                                                           San Diego, CA 92121
                                                                  U.S.A.

                                           Â© 2016 Qualcomm Technologies, Inc. All rights reserved.
Contents

                Figures .............................................................................................................................. 14
                Tables ................................................................................................................................ 15

                1 Introduction......................................................................................... 17
                1.1 Features....................................................................................................................... 17
                1.2 Functional units .......................................................................................................... 19
                    1.2.1 Memory............................................................................................................. 20
                    1.2.2 Registers............................................................................................................ 20
                    1.2.3 Sequencer.......................................................................................................... 20
                    1.2.4 Execution units.................................................................................................. 20
                    1.2.5 Load/store units................................................................................................. 20
                1.3 Instruction set ............................................................................................................. 21
                    1.3.1 Addressing modes............................................................................................. 21
                    1.3.2 Scalar operations............................................................................................... 22
                    1.3.3 Vector operations .............................................................................................. 22
                    1.3.4 Floating-point operations .................................................................................. 23
                    1.3.5 Program flow .................................................................................................... 24
                    1.3.6 Instruction packets ............................................................................................ 24
                    1.3.7 Dot-new instructions......................................................................................... 25
                    1.3.8 Compound instructions ..................................................................................... 25
                    1.3.9 Duplex instructions ........................................................................................... 25
                    1.3.10 Instruction classes ........................................................................................... 25
                    1.3.11 Instruction intrinsics........................................................................................ 26
                1.4 Processor versions ...................................................................................................... 27
                1.5 Notation ...................................................................................................................... 27
                    1.5.1 Instruction syntax.............................................................................................. 27
                    1.5.2 Register operands.............................................................................................. 28
                    1.5.3 Numeric operands ............................................................................................. 30
                1.6 Terminology ............................................................................................................... 31
                1.7 Technical assistance.................................................................................................... 31

                2 Registers ............................................................................................. 32
                2.1 General registers......................................................................................................... 33
                2.2 Control registers ......................................................................................................... 35
                    2.2.1 Program counter................................................................................................ 37



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                2
Hexagon V62 Programmer's Reference Manual                                                                                               Contents



                      2.2.2 Loop registers.................................................................................................... 38
                      2.2.3 User status register............................................................................................ 38
                      2.2.4 Modifier registers.............................................................................................. 41
                      2.2.5 Predicate registers ............................................................................................. 42
                      2.2.6 Circular start registers ....................................................................................... 43
                      2.2.7 User general pointer register............................................................................. 43
                      2.2.8 Global pointer ................................................................................................... 43
                      2.2.9 Cycle count registers......................................................................................... 44
                      2.2.10 Frame limit register......................................................................................... 44
                      2.2.11 Frame key register........................................................................................... 45
                      2.2.12 Packet count registers ..................................................................................... 45
                      2.2.13 Qtimer registers............................................................................................... 46

                3 Instructions ......................................................................................... 47
                3.1 Instruction syntax ....................................................................................................... 47
                3.2 Instruction classes....................................................................................................... 49
                3.3 Instruction packets...................................................................................................... 50
                    3.3.1 Packet execution semantics............................................................................... 51
                    3.3.2 Sequencing semantics ....................................................................................... 51
                    3.3.3 Resource constraints ......................................................................................... 52
                    3.3.4 Grouping constraints......................................................................................... 53
                    3.3.5 Dependency constraints .................................................................................... 54
                    3.3.6 Ordering constraints.......................................................................................... 54
                    3.3.7 Alignment constraints ....................................................................................... 55
                3.4 Instruction intrinsics ................................................................................................... 55
                3.5 Compound instructions............................................................................................... 56
                3.6 Duplex instructions..................................................................................................... 56

                4 Data Processing ................................................................................. 57
                4.1 Data types ................................................................................................................... 58
                    4.1.1 Fixed-point data ................................................................................................ 58
                    4.1.2 Floating-point data ............................................................................................ 58
                    4.1.3 Complex data .................................................................................................... 58
                    4.1.4 Vector data ........................................................................................................ 58
                4.2 Instruction options ...................................................................................................... 60
                    4.2.1 Fractional scaling .............................................................................................. 60
                    4.2.2 Saturation .......................................................................................................... 60
                    4.2.3 Arithmetic rounding.......................................................................................... 61
                    4.2.4 Convergent rounding ........................................................................................ 61
                    4.2.5 Scaling for divide and square-root.................................................................... 61
                4.3 XTYPE operations...................................................................................................... 62
                    4.3.1 ALU .................................................................................................................. 62



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                           3
Hexagon V62 Programmer's Reference Manual                                                                                                 Contents



                      4.3.2 Bit manipulation................................................................................................ 63
                      4.3.3 Complex............................................................................................................ 63
                      4.3.4 Floating point .................................................................................................... 64
                      4.3.5 Multiply............................................................................................................. 65
                      4.3.6 Permute ............................................................................................................. 67
                      4.3.7 Predicate............................................................................................................ 67
                      4.3.8 Shift................................................................................................................... 68
                4.4   ALU32 operations ...................................................................................................... 69
                4.5   Vector operations ........................................................................................................ 70
                4.6   CR operations ............................................................................................................. 72
                4.7   Compound operations................................................................................................. 72
                4.8   Special operations....................................................................................................... 72
                      4.8.1 H.264 CABAC processing................................................................................ 73
                          4.8.1.1 CABAC implementation ......................................................................... 74
                          4.8.1.2 Code example .......................................................................................... 75
                      4.8.2 IP internet checksum......................................................................................... 76
                          4.8.2.1 Code example .......................................................................................... 77
                      4.8.3 Software-defined radio...................................................................................... 78
                          4.8.3.1 Rake despreading .................................................................................... 78
                          4.8.3.2 Polynomial operations............................................................................. 79

                5 Memory................................................................................................ 81
                5.1 Memory model ........................................................................................................... 82
                    5.1.1 Address space.................................................................................................... 82
                    5.1.2 Byte order.......................................................................................................... 82
                    5.1.3 Alignment ......................................................................................................... 82
                5.2 Memory loads............................................................................................................. 83
                5.3 Memory stores ............................................................................................................ 84
                5.4 Dual stores .................................................................................................................. 84
                5.5 New-value stores ........................................................................................................ 85
                5.6 Mem-ops..................................................................................................................... 85
                5.7 Addressing modes ...................................................................................................... 86
                    5.7.1 Absolute ............................................................................................................ 86
                    5.7.2 Absolute-set ...................................................................................................... 86
                    5.7.3 Absolute with register offset ............................................................................. 87
                    5.7.4 Global pointer relative ...................................................................................... 87
                    5.7.5 Indirect .............................................................................................................. 88
                    5.7.6 Indirect with offset ............................................................................................ 88
                    5.7.7 Indirect with register offset ............................................................................... 89
                    5.7.8 Indirect with auto-increment immediate........................................................... 89
                    5.7.9 Indirect with auto-increment register................................................................ 89
                    5.7.10 Circular with auto-increment immediate ........................................................ 90
                    5.7.11 Circular with auto-increment register ............................................................. 92


80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                             4
Hexagon V62 Programmer's Reference Manual                                                                                              Contents



                    5.7.12 Bit-reversed with auto-increment register ...................................................... 93
                5.8 Conditional load/stores............................................................................................... 94
                5.9 Cache memory............................................................................................................ 95
                    5.9.1 Uncached memory ............................................................................................ 96
                    5.9.2 Tightly coupled memory ................................................................................... 96
                    5.9.3 Cache maintenance operations.......................................................................... 97
                    5.9.4 L2 cache operations .......................................................................................... 98
                    5.9.5 Cache line zero.................................................................................................. 98
                    5.9.6 Cache prefetch .................................................................................................. 99
                5.10 Memory ordering.................................................................................................... 102
                5.11 Atomic operations................................................................................................... 103

                6 Conditional Execution..................................................................... 105
                6.1 Scalar predicates....................................................................................................... 105
                    6.1.1 Generating scalar predicates ........................................................................... 106
                    6.1.2 Consuming scalar predicates........................................................................... 108
                    6.1.3 Auto-AND predicates ..................................................................................... 109
                    6.1.4 Dot-new predicates ......................................................................................... 110
                    6.1.5 Dependency constraints .................................................................................. 111
                6.2 Vector predicates ...................................................................................................... 111
                    6.2.1 Vector compare ............................................................................................... 111
                    6.2.2 Vector mux instruction.................................................................................... 113
                    6.2.3 Using vector conditionals ............................................................................... 114
                6.3 Predicate operations.................................................................................................. 115

                7 Program Flow.....................................................................................116
                7.1 Conditional instructions............................................................................................ 116
                7.2 Hardware loops......................................................................................................... 117
                    7.2.1 Loop setup....................................................................................................... 118
                    7.2.2 Loop end ......................................................................................................... 119
                    7.2.3 Loop execution................................................................................................ 120
                    7.2.4 Pipelined hardware loops................................................................................ 121
                    7.2.5 Loop restrictions ............................................................................................. 124
                7.3 Software branches .................................................................................................... 124
                    7.3.1 Jumps .............................................................................................................. 125
                    7.3.2 Calls ................................................................................................................ 125
                    7.3.3 Returns ............................................................................................................ 126
                    7.3.4 Extended branches .......................................................................................... 127
                    7.3.5 Branches to and from packets ......................................................................... 127
                7.4 Speculative jumps..................................................................................................... 128
                7.5 Compare jumps......................................................................................................... 129
                    7.5.1 New-value compare jumps ............................................................................. 130



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                          5
Hexagon V62 Programmer's Reference Manual                                                                                                Contents



                7.6 Register transfer jumps............................................................................................. 131
                7.7 Dual jumps................................................................................................................ 132
                7.8 Hint indirect jump target .......................................................................................... 133
                7.9 Pauses ....................................................................................................................... 134
                7.10 Exceptions .............................................................................................................. 134

                8 Software Stack .................................................................................. 138
                8.1 Stack structure .......................................................................................................... 138
                8.2 Stack frames ............................................................................................................. 140
                8.3 Stack protection ........................................................................................................ 140
                    8.3.1 Stack bounds checking.................................................................................... 140
                    8.3.2 Stack smashing protection .............................................................................. 141
                8.4 Stack registers........................................................................................................... 141
                8.5 Stack instructions...................................................................................................... 142

                9 PMU Events....................................................................................... 143
                9.1 V62 processor event symbols................................................................................... 144

                10 Instruction Encoding...................................................................... 151
                10.1 Instructions ............................................................................................................. 152
                10.2 Sub-instructions...................................................................................................... 153
                10.3 Duplexes ................................................................................................................. 156
                10.4 Instruction classes................................................................................................... 158
                10.5 Instruction packets.................................................................................................. 159
                10.6 Loop packets........................................................................................................... 160
                10.7 Immediate values.................................................................................................... 161
                10.8 Scaled immediates .................................................................................................. 161
                10.9 Constant extenders.................................................................................................. 162
                10.10 New-value operands ............................................................................................. 165
                10.11 Instruction mapping .............................................................................................. 166

                11 Instruction Set................................................................................. 167
                    11.0.1 Instruction categories .................................................................................... 168
                11.1 ALU32 .................................................................................................................... 171
                    11.1.1 ALU32/ALU ................................................................................................. 171
                          Add ................................................................................................................. 171
                          Logical operations .......................................................................................... 173
                          Negate............................................................................................................. 175
                          Nop ................................................................................................................. 176
                          Subtract........................................................................................................... 177
                          Sign extend ..................................................................................................... 179
                          Transfer immediate......................................................................................... 180


80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                            6
Hexagon V62 Programmer's Reference Manual                                                                                                   Contents



                            Transfer register ............................................................................................. 182
                            Vector add halfwords ..................................................................................... 183
                            Vector average halfwords............................................................................... 184
                            Vector subtract halfwords .............................................................................. 185
                            Zero extend..................................................................................................... 187
                    11.1.2 ALU32/PERM .............................................................................................. 188
                            Combine words into doubleword ................................................................... 188
                            Mux ................................................................................................................ 191
                            Shift word by 16 ............................................................................................. 193
                            Pack high and low halfwords ......................................................................... 195
                    11.1.3 ALU32/PRED ............................................................................................... 196
                            Conditional add .............................................................................................. 196
                            Conditional shift halfword.............................................................................. 198
                            Conditional combine ...................................................................................... 200
                            Conditional logical operations........................................................................ 201
                            Conditional subtract ....................................................................................... 203
                            Conditional sign extend.................................................................................. 204
                            Conditional transfer ........................................................................................ 206
                            Conditional zero extend.................................................................................. 207
                            Compare ......................................................................................................... 209
                            Compare to general register ........................................................................... 211
                11.2 CR........................................................................................................................... 212
                            End loop instructions...................................................................................... 212
                            Corner detection acceleration ......................................................................... 214
                            Logical reductions on predicates .................................................................... 215
                            Looping instructions....................................................................................... 216
                            Add to PC ....................................................................................................... 218
                            Pipelined loop instructions ............................................................................. 219
                            Logical operations on predicates .................................................................... 221
                            User control register transfer .......................................................................... 223
                11.3 JR ............................................................................................................................ 225
                            Call subroutine from register.......................................................................... 225
                            Hint an indirect jump address......................................................................... 227
                            Jump to address from register ........................................................................ 228
                11.4 J............................................................................................................................... 229
                            Call subroutine ............................................................................................... 229
                            Compare and jump ......................................................................................... 231
                            Jump to address .............................................................................................. 236
                            Jump to address conditioned on new predicate .............................................. 238
                            Jump to address condition on register value .................................................. 239
                            Transfer and jump .......................................................................................... 241
                11.5 LD........................................................................................................................... 242
                            Load doubleword............................................................................................ 242



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                               7
Hexagon V62 Programmer's Reference Manual                                                                                                 Contents



                          Load doubleword conditionally...................................................................... 244
                          Load byte ........................................................................................................ 246
                          Load byte conditionally.................................................................................. 248
                          Load byte into shifted vector.......................................................................... 250
                          Load half into shifted vector .......................................................................... 253
                          Load halfword ................................................................................................ 256
                          Load halfword conditionally .......................................................................... 258
                          Load unsigned byte ........................................................................................ 260
                          Load unsigned byte conditionally .................................................................. 262
                          Load unsigned halfword ................................................................................. 264
                          Load unsigned halfword conditionally........................................................... 266
                          Load word....................................................................................................... 268
                          Load word conditionally ................................................................................ 270
                          Deallocate stack frame ................................................................................... 272
                          Deallocate frame and return ........................................................................... 274
                          Load and unpack bytes to halfwords .............................................................. 276
                11.6 MEMOP.................................................................................................................. 285
                          Operation on memory byte............................................................................. 286
                          Operation on memory halfword ..................................................................... 287
                          Operation on memory word ........................................................................... 288
                11.7 NV .......................................................................................................................... 289
                    11.7.1 NV/J .............................................................................................................. 289
                          Jump to address condition on new register value........................................... 289
                    11.7.2 NV/ST ........................................................................................................... 293
                          Store new-value byte ...................................................................................... 293
                          Store new-value byte conditionally ................................................................ 295
                          Store new-value halfword .............................................................................. 298
                          Store new-value halfword conditionally ........................................................ 300
                          Store new-value word..................................................................................... 303
                          Store new-value word conditionally............................................................... 305
                11.8 ST............................................................................................................................ 308
                          Store doubleword ........................................................................................... 308
                          Store doubleword conditionally ..................................................................... 310
                          Store byte........................................................................................................ 312
                          Store byte conditionally.................................................................................. 314
                          Store halfword ................................................................................................ 317
                          Store halfword conditionally .......................................................................... 320
                          Store word ...................................................................................................... 324
                          Store word conditionally ................................................................................ 326
                          Allocate stack frame ....................................................................................... 329
                11.9 SYSTEM ................................................................................................................ 331
                    11.9.1 SYSTEM/GUEST ......................................................................................... 331
                          Guest control register transfer ........................................................................ 331



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                             8
Hexagon V62 Programmer's Reference Manual                                                                                           Contents



                   11.9.2 SYSTEM/MONITOR ................................................................................... 333
                         Clear interrupt auto disable ............................................................................ 333
                         Swap SGP control register ............................................................................. 334
                         Cancel pending interrupts............................................................................... 335
                         Data cache kill ................................................................................................ 336
                         Data cache maintenance monitor instructions................................................ 337
                         Read the interrupt mask for a thread .............................................................. 339
                         Acquire hardware lock ................................................................................... 340
                         Release hardware lock.................................................................................... 341
                         Interrupt to thread assignment read ................................................................ 342
                         Interrupt to thread assignment write............................................................... 344
                         Instruction cache maintenance supervisor operations .................................... 346
                         Instruction cache maintenance operations (single-thread) ............................. 347
                         L2 cache operations by index ......................................................................... 348
                         L2 cache global operations............................................................................. 349
                         L2 cache operations by address...................................................................... 351
                         L2 tag read/write ............................................................................................ 353
                         Load from physical address............................................................................ 355
                         Raise NMI on threads..................................................................................... 356
                         Resume from wait mode................................................................................. 357
                         Return from exception.................................................................................... 358
                         Return from exception and unlock TLB......................................................... 359
                         Set the interrupt mask for a thread ................................................................. 360
                         Set interrupt auto disable ................................................................................ 361
                         Start threads .................................................................................................... 362
                         Stop threads .................................................................................................... 363
                         Software interrupt........................................................................................... 364
                         TLB read/write/probe operations ................................................................... 365
                         System control register transfer...................................................................... 368
                         Transition threads to wait mode ..................................................................... 370
                   11.9.3 SYSTEM/USER............................................................................................ 371
                         Load locked .................................................................................................... 371
                         Store conditional............................................................................................. 372
                         Zero a cache line............................................................................................. 374
                         Memory barrier............................................................................................... 375
                         Breakpoint ...................................................................................................... 376
                         Data cache prefetch ........................................................................................ 377
                         Data cache maintenance user operations........................................................ 378
                         Instruction cache maintenance user operations .............................................. 379
                         Instruction synchronization ............................................................................ 380
                         L2 cache prefetch ........................................................................................... 381
                         Pause............................................................................................................... 384
                         Memory thread synchronization..................................................................... 385



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                          9
Hexagon V62 Programmer's Reference Manual                                                                                              Contents



                          Send value to ETM trace ................................................................................ 386
                          Trap ................................................................................................................ 387
                11.10 XTYPE ................................................................................................................. 388
                    11.10.1 XTYPE/ALU .............................................................................................. 388
                          Absolute value doubleword............................................................................ 388
                          Absolute value word....................................................................................... 389
                          Add and accumulate ....................................................................................... 390
                          Add doublewords ........................................................................................... 392
                          Add halfword.................................................................................................. 394
                          Add or subtract doublewords with carry ........................................................ 397
                          Logical doublewords ...................................................................................... 398
                          Logical-logical doublewords .......................................................................... 400
                          Logical-logical words..................................................................................... 401
                          Maximum words............................................................................................. 403
                          Maximum doublewords.................................................................................. 404
                          Minimum words ............................................................................................. 405
                          Minimum doublewords .................................................................................. 406
                          Modulo wrap .................................................................................................. 407
                          Negate............................................................................................................. 408
                          Round ............................................................................................................. 409
                          Subtract doublewords ..................................................................................... 411
                          Subtract and accumulate words ...................................................................... 412
                          Subtract halfword ........................................................................................... 413
                          Sign extend word to doubleword.................................................................... 416
                          Vector absolute value halfwords .................................................................... 417
                          Vector absolute value words .......................................................................... 418
                          Vector absolute difference bytes .................................................................... 419
                          Vector absolute difference halfwords............................................................. 420
                          Vector absolute difference words................................................................... 421
                          Vector add compare and select maximum bytes ............................................ 422
                          Vector add compare and select maximum halfwords .................................... 423
                          Vector add halfwords ..................................................................................... 425
                          Vector add halfwords with saturate and pack to unsigned bytes ................... 427
                          Vector reduce add unsigned bytes.................................................................. 428
                          Vector reduce add unsigned halfwords .......................................................... 430
                          Vector add bytes ............................................................................................. 432
                          Vector add words............................................................................................ 433
                          Vector average halfwords............................................................................... 434
                          Vector average unsigned bytes....................................................................... 436
                          Vector average words ..................................................................................... 437
                          Vector conditional negate............................................................................... 439
                          Vector maximum bytes .................................................................................. 441
                          Vector maximum halfwords ........................................................................... 442



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                        10
Hexagon V62 Programmer's Reference Manual                                                                                           Contents



                         Vector reduce maximum halfwords ............................................................... 443
                         Vector reduce maximum words ..................................................................... 445
                         Vector maximum words ................................................................................. 447
                         Vector minimum bytes ................................................................................... 448
                         Vector minimum halfwords............................................................................ 450
                         Vector reduce minimum halfwords ................................................................ 451
                         Vector reduce minimum words ...................................................................... 453
                         Vector minimum words.................................................................................. 455
                         Vector sum of absolute differences unsigned bytes ....................................... 456
                         Vector subtract halfwords .............................................................................. 458
                         Vector subtract bytes ...................................................................................... 460
                         Vector subtract words..................................................................................... 461
                   11.10.2 XTYPE/BIT ................................................................................................ 462
                         Count leading ................................................................................................. 462
                         Count population ............................................................................................ 465
                         Count trailing.................................................................................................. 466
                         Extract bitfield ................................................................................................ 467
                         Insert bitfield .................................................................................................. 470
                         Interleave/deinterleave ................................................................................... 472
                         Linear feedback-shift iteration ....................................................................... 473
                         Masked parity ................................................................................................. 474
                         Bit reverse....................................................................................................... 475
                         Set/clear/toggle bit.......................................................................................... 476
                         Split bitfield .................................................................................................... 478
                         Table index ..................................................................................................... 480
                   11.10.3 XTYPE/COMPLEX.................................................................................... 483
                         Complex add/sub halfwords ........................................................................... 483
                         Complex add/sub words ................................................................................. 486
                         Complex multiply........................................................................................... 488
                         Complex multiply real or imaginary .............................................................. 491
                         Complex multiply with round and pack ......................................................... 493
                         Complex multiply 32x16................................................................................ 495
                         Vector complex multiply real or imaginary ................................................... 497
                         Vector complex conjugate.............................................................................. 500
                         Vector complex rotate .................................................................................... 501
                         Vector reduce complex multiply real or imaginary........................................ 503
                         Vector reduce complex multiply by scalar..................................................... 506
                         Vector reduce complex multiply by scalar with round and pack ................... 509
                         Vector reduce complex rotate......................................................................... 512
                   11.10.4 XTYPE/FP .................................................................................................. 515
                         Floating point addition ................................................................................... 516
                         Classify floating-point value .......................................................................... 517
                         Compare floating-point value......................................................................... 519



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                        11
Hexagon V62 Programmer's Reference Manual                                                                                           Contents



                         Convert floating-point value to other format ................................................. 521
                         Convert integer to floating-point value .......................................................... 522
                         Convert floating-point value to integer .......................................................... 524
                         Floating point extreme value assistance ......................................................... 527
                         Floating point fused multiply-add .................................................................. 528
                         Floating point fused multiply-add with scaling.............................................. 529
                         Floating point reciprocal square root approximation ..................................... 530
                         Floating point fused multiply-add for library routines ................................... 531
                         Create floating-point constant ........................................................................ 533
                         Floating point maximum ................................................................................ 534
                         Floating point minimum ................................................................................. 535
                         Floating point multiply ................................................................................... 536
                         Floating point reciprocal approximation ........................................................ 537
                         Floating point subtraction............................................................................... 538
                   11.10.5 XTYPE/MPY .............................................................................................. 539
                         Multiply and use lower result ......................................................................... 539
                         Vector multiply word by signed half (32x16) ................................................ 542
                         Vector multiply word by unsigned half (32x16) ............................................ 546
                         Multiply signed halfwords.............................................................................. 550
                         Multiply unsigned halfwords.......................................................................... 558
                         Polynomial multiply words ............................................................................ 563
                         Vector reduce multiply word by signed half (32x16) .................................... 565
                         Multiply and use upper result ......................................................................... 567
                         Multiply and use full result ............................................................................ 570
                         Vector dual multiply....................................................................................... 572
                         Vector dual multiply with round and pack ..................................................... 575
                         Vector reduce multiply bytes ......................................................................... 577
                         Vector dual multiply signed by unsigned bytes ............................................. 580
                         Vector multiply even halfwords ..................................................................... 582
                         Vector multiply halfwords.............................................................................. 584
                         Vector multiply halfwords with round and pack............................................ 586
                         Vector multiply halfwords, signed by unsigned............................................. 588
                         Vector reduce multiply halfwords .................................................................. 590
                         Vector multiply bytes ..................................................................................... 592
                         Vector polynomial multiply halfwords .......................................................... 594
                   11.10.6 XTYPE/PERM............................................................................................ 597
                         CABAC decode bin........................................................................................ 597
                         Saturate ........................................................................................................... 599
                         Swizzle bytes .................................................................................................. 601
                         Vector align .................................................................................................... 602
                         Vector round and pack ................................................................................... 604
                         Vector saturate and pack ................................................................................ 606
                         Vector saturate without pack .......................................................................... 609



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                        12
Hexagon V62 Programmer's Reference Manual                                                                                               Contents



                            Vector shuffle ................................................................................................. 611
                            Vector splat bytes ........................................................................................... 613
                            Vector splat halfwords.................................................................................... 614
                            Vector splice................................................................................................... 615
                            Vector sign extend.......................................................................................... 616
                            Vector truncate ............................................................................................... 618
                            Vector zero extend.......................................................................................... 621
                     11.10.7 XTYPE/PRED ............................................................................................ 623
                            Bounds check ................................................................................................. 623
                            Compare byte ................................................................................................. 625
                            Compare half .................................................................................................. 627
                            Compare doublewords.................................................................................... 629
                            Compare bit mask........................................................................................... 630
                            Mask generate from predicate ........................................................................ 632
                            Check for TLB match..................................................................................... 633
                            Predicate transfer ............................................................................................ 634
                            Test bit ............................................................................................................ 635
                            Vector compare halfwords ............................................................................. 636
                            Vector compare bytes for any match.............................................................. 638
                            Vector compare bytes ..................................................................................... 639
                            Vector compare words.................................................................................... 641
                            Viterbi pack even and odd predicate bits ....................................................... 643
                            Vector mux ..................................................................................................... 644
                     11.10.8 XTYPE/SHIFT............................................................................................ 645
                            Shift by immediate ......................................................................................... 645
                            Shift by immediate and accumulate ............................................................... 647
                            Shift by immediate and add............................................................................ 650
                            Shift by immediate and logical....................................................................... 651
                            Shift right by immediate with rounding ......................................................... 655
                            Shift left by immediate with saturation .......................................................... 657
                            Shift by register .............................................................................................. 658
                            Shift by register and accumulate .................................................................... 661
                            Shift by register and logical............................................................................ 664
                            Shift by register with saturation ..................................................................... 668
                            Vector shift halfwords by immediate ............................................................. 670
                            Vector arithmetic shift halfwords with round ................................................ 672
                            Vector arithmetic shift halfwords with saturate and pack .............................. 674
                            Vector shift halfwords by register .................................................................. 676
                            Vector shift words by immediate ................................................................... 678
                            Vector shift words by register ........................................................................ 680
                            Vector shift words with truncate and pack ..................................................... 682
                Instruction Index ............................................................................................................. 684
                Intrinsics Index ............................................................................................................... 699



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                         13
Hexagon V62 Programmer's Reference Manual                                                                                      Figures



                Figures
                   Figure 1-1     Hexagon V62 processor architecture ................................................... 19
                   Figure 1-2     Vector instruction example .................................................................. 23
                   Figure 1-3     Instruction classes and combinations................................................... 26
                   Figure 1-4     Register field symbols.......................................................................... 29
                   Figure 2-1     General registers .................................................................................. 33
                   Figure 2-2     Control registers................................................................................... 35
                   Figure 3-1     Packet grouping combinations ............................................................. 52
                   Figure 4-1     Vector byte operation........................................................................... 59
                   Figure 4-2     Vector halfword operation ................................................................... 59
                   Figure 4-3     Vector word operation ......................................................................... 60
                   Figure 4-4     64-bit shift and add/sub/logical............................................................ 68
                   Figure 4-5     Vector halfword shift right................................................................... 71
                   Figure 5-1     Hexagon processor byte order ............................................................. 82
                   Figure 5-2     L2FETCH instruction ........................................................................ 100
                   Figure 6-1     Vector byte compare .......................................................................... 112
                   Figure 6-2     Vector halfword compare .................................................................. 112
                   Figure 6-3     Vector mux instruction ...................................................................... 113
                   Figure 8-1     Stack structure.................................................................................... 139
                   Figure 10-1    Instruction packet encoding ............................................................... 159




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                 14
Hexagon V62 Programmer's Reference Manual                                                                                        Tables



                Tables
                   Table 1-1      Register symbols .................................................................................. 28
                   Table 1-2      Register bit field symbols .................................................................... 29
                   Table 1-3      Instruction operands............................................................................. 30
                   Table 1-4      Data symbols........................................................................................ 31
                   Table 2-1      General register aliases ........................................................................ 34
                   Table 2-2      General register pairs ........................................................................... 34
                   Table 2-3      Aliased control registers ...................................................................... 36
                   Table 2-4      Control register pairs............................................................................ 37
                   Table 2-5      Loop registers....................................................................................... 38
                   Table 2-6      User status register ............................................................................... 39
                   Table 2-7      Modifier registers (indirect auto-increment addressing)...................... 41
                   Table 2-8      Modifier registers (circular addressing)............................................... 41
                   Table 2-9      Modifier registers (bit-reversed addressing) ........................................ 42
                   Table 2-10     Predicate registers ................................................................................ 42
                   Table 2-11     Circular start registers .......................................................................... 43
                   Table 2-12     User general pointer register ................................................................ 43
                   Table 2-13     Global pointer register ......................................................................... 43
                   Table 2-14     Cycle count registers............................................................................ 44
                   Table 2-15     Frame limit register.............................................................................. 44
                   Table 2-16     Frame key register................................................................................ 45
                   Table 2-17     Packet count registers .......................................................................... 45
                   Table 2-18     Qtimer registers.................................................................................... 46
                   Table 3-1      Instruction symbols .............................................................................. 47
                   Table 3-2      Instruction classes ................................................................................ 49
                   Table 4-1      Single-precision multiply options ........................................................ 66
                   Table 4-2      Double precision multiply options....................................................... 66
                   Table 4-3      Control register transfer instructions ................................................... 72
                   Table 5-1      Memory alignment restrictions ............................................................ 83
                   Table 5-2      Load instructions.................................................................................. 83
                   Table 5-3      Store instructions.................................................................................. 84
                   Table 5-4      Mem-ops .............................................................................................. 85
                   Table 5-5      Addressing modes ................................................................................ 86
                   Table 5-6      Offset ranges (Global pointer relative) ................................................ 88
                   Table 5-7      Offset ranges (Indirect with offset) ...................................................... 88
                   Table 5-8      Increment ranges (Indirect with auto-inc immediate).......................... 89
                   Table 5-9      Increment ranges (Circular with auto-inc immediate) ......................... 91
                   Table 5-10     Increment ranges (Circular with auto-inc register) .............................. 92
                   Table 5-11     Addressing modes (Conditional load/store)......................................... 94
                   Table 5-12     Conditional offset ranges (Indirect with offset) ................................... 95
                   Table 5-13     Hexagon processor cache size ............................................................. 96
                   Table 5-14     Cache instructions (User-level)............................................................ 97



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                  15
Hexagon V62 Programmer's Reference Manual                                                                                        Tables



                   Table 5-15     Memory ordering instructions............................................................ 102
                   Table 5-16     Atomic instructions ............................................................................ 103
                   Table 6-1      Scalar predicate-generating instructions ............................................ 106
                   Table 6-2      Vector mux instruction ....................................................................... 113
                   Table 6-3      Predicate register instructions ............................................................ 115
                   Table 7-1      Loop instructions ............................................................................... 118
                   Table 7-2      Software pipelined loop ..................................................................... 122
                   Table 7-3      Software pipelined loop (using spNloop0) ........................................ 123
                   Table 7-4      Software branch instructions.............................................................. 124
                   Table 7-5      Jump instructions ............................................................................... 125
                   Table 7-6      Call instructions ................................................................................. 125
                   Table 7-7      Return instructions ............................................................................. 126
                   Table 7-8      Speculative jump instructions ............................................................ 128
                   Table 7-9      Compare jump instructions ................................................................ 130
                   Table 7-10     New-value compare jump instructions .............................................. 131
                   Table 7-11     Register transfer jump instructions .................................................... 132
                   Table 7-12     Dual jump instructions ....................................................................... 132
                   Table 7-13     Jump hint instruction.......................................................................... 133
                   Table 7-14     Pause instruction ................................................................................ 134
                   Table 7-15     V60/61 exceptions ............................................................................. 135
                   Table 8-1      Stack registers .................................................................................... 141
                   Table 8-2      Stack instructions ............................................................................... 142
                   Table 9-1      V62 processor event symbols ............................................................ 144
                   Table 10-1     Instruction fields ................................................................................ 152
                   Table 10-2     Sub-instructions ................................................................................. 153
                   Table 10-3     Sub-instruction registers .................................................................... 155
                   Table 10-4     Duplex instruction.............................................................................. 156
                   Table 10-5     Duplex ICLASS field......................................................................... 156
                   Table 10-6     Instruction class encoding.................................................................. 158
                   Table 10-7     Loop packet encoding ........................................................................ 160
                   Table 10-8     Scaled immediate encoding (indirect offsets) .................................... 161
                   Table 10-9     Constant extender encoding ............................................................... 162
                   Table 10-10    Constant extender instructions ........................................................... 163
                   Table 10-11    Instruction mapping ........................................................................... 166
                   Table 11-1     Instruction syntax symbols ................................................................ 169
                   Table 11-2     Instruction operand symbols .............................................................. 169
                   Table 11-3     Instruction behavior symbols ............................................................. 170




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                  16
         1 Introduction


                The Qualcomm Hexagonâ¢ processor is a general-purpose digital signal processor
                designed for high performance and low power across a wide variety of multimedia and
                modem applications. V62 is a member of the sixth version of the Hexagon processor
                architecture.


       1.1      Features
                    â    Memory
                        Program code and data are stored in a unified 32-bit address space. The load/store
                        architecture supports a complete set of addressing modes for both compiler code
                        generation and DSP application programming.
                    â    Registers
                        Thirty two 32-bit general purpose registers can be accessed as single registers or
                        as 64-bit register pairs. The general registers hold all data including scalar,
                        pointer, and packed vector data.
                    â    Data types
                        Instructions can perform a wide variety of operations on fixed-point or floating-
                        point data. The fixed-point operations support scalar and vector data in a variety
                        of sizes. The floating-point operations support single-precision data.
                    â    Parallel execution
                        Instructions can be grouped into very long instruction word (VLIW) packets for
                        parallel execution, with each packet containing from one to four instructions.
                        Vector instructions operate on single instruction multiple data (SIMD) vectors.
                    â    Program flow
                        Nestable zero-overhead hardware loops are supported. Conditional/unconditional
                        jumps and subroutine calls support both PC-relative and register indirect
                        addressing. Two program flow instructions can be grouped into one packet.
                    â    Instruction pipeline
                        Pipeline hazards are resolved by the hardware: instruction scheduling is not
                        constrained by pipeline restrictions.
                    â    Code compression




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     17
Hexagon V62 Programmer's Reference Manual                                                       Introduction



                        Compound instructions merge certain common operation sequences (add-
                        accumulate, shift-add, etc.) into a single instruction. Duplex encodings express
                        two parallel instructions in a single 32-bit word.
                    â    Cache memory
                        Memory accesses can be cached or uncached. Separate L1 instruction and data
                        caches exist for program code and data. A unified L2 cache can be partly or
                        wholly configured as tightly-coupled memory (TCM).
                    â    Virtual memory
                        Memory is addressed virtually, with virtual-to-physical memory mapping handled
                        by a resident OS. Virtual memory supports the implementation of memory
                        management and memory protection in a hardware-independent manner.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      18
Hexagon V62 Programmer's Reference Manual                                                          Introduction



       1.2      Functional units
                Figure 1-1 shows the major functional units of the Hexagon V62 processor architecture:

                     â     Memory and registers
                     â     Instruction sequencer
                     â     Execution units
                     â     Load/store units


                                                         Memory
                                                 (unified address space)

                                                                               Load/               Load/
                                                                                              64
                                    4x32 bit                                   Store     64        Store
                      128         Instructions             S3: X Unit
                                                        XTYPE Instructions
                                                        ALU32 Instructions
                                                        J Instructions
                     Sequencer                          CR Instructions

                       Packets of
                    1-4 instructions
                                                           S2: X Unit
                                                        XTYPE Instructions
                                                        ALU32 Instructions
                                                        J Instructions
                                                        JR Instructions
                                                                                       General
                  Control Registers
                  Hardware Loop Regs
                                                                                       Registers
                  Modifier Registers                     S1: Load/Store
                  Status Register                             Unit                       R0-R31
                  Program Counter                       LD Instructions
                  Predicate Registers                   ST Instructions
                  User General Pointer                  ALU32 Instructions
                  Global Pointer
                  Circular Start Registers

                                                        S0: Load/Store
                                                             Unit
                                                        LD Instructions
                                                        ST Instructions
                                                        ALU32 Instructions
                                                        MEMOP Instructions
                                                        NV Instructions
                                                        SYSTEM Instructions




                Figure 1-1      Hexagon V62 processor architecture




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      19
Hexagon V62 Programmer's Reference Manual                                                         Introduction



     1.2.1      Memory
                The Hexagon processor features a unified byte-addressable memory. This memory has a
                single 32-bit virtual address space which holds both instructions and data. It operates in
                little-endian mode.


     1.2.2      Registers
                The Hexagon processor has two sets of registers: general registers and control registers.

                The general registers include thirty-two 32-bit registers (named R0 through R31) which
                can be accessed either as single registers or as aligned 64-bit register pairs. The general
                registers are used to contain all pointer, scalar, vector, and accumulator data.

                The control registers include special-purpose registers such as program counter, status
                register, loop registers, etc.


     1.2.3      Sequencer
                The instruction sequencer processes packets of one to four instructions in each cycle. If a
                packet contains more than one instruction, the instructions are executed in parallel.

                The instruction combinations allowed in a packet are limited to the instruction types that
                can be executed in parallel in the four execution units (as shown in Figure 1-1).


     1.2.4      Execution units
                The dual execution units are identical: each includes a 64-bit shifter and a vector
                multiply/accumulate unit with four 16x16 multipliers to support both scalar and vector
                instructions.

                These units also perform 32- and 64-bit ALU instructions, and jump and loop instructions.

                   NOTE     Each execution unit supports floating-point instructions.


     1.2.5      Load/store units
                The two load/store units can operate on signed or unsigned bytes, halfwords (16-bit),
                words (32-bit), or double words (64-bit).

                To increase the number of instruction combinations allowed in packets, the load units also
                support 32-bit ALU instructions.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        20
Hexagon V62 Programmer's Reference Manual                                                        Introduction



       1.3      Instruction set
                In order for the Hexagon processor to achieve large amounts of work per cycle, the
                instruction set was designed with the following properties:

                     â    Static grouping (VLIW) architecture
                     â    Static fusing of simple dependent instructions
                     â    Extensive compound instructions
                     â    A large set of SIMD and application-specific instructions

                To support efficient compilation, the instruction set is designed to be orthogonal with
                respect to registers, addressing modes, and load/store access size.


     1.3.1      Addressing modes
                The Hexagon processor supports the following memory addressing modes:
                    â  32-bit absolute

                     â    32-bit absolute-set
                     â    Absolute with register offset
                     â    Global pointer relative
                     â    Indirect
                     â    Indirect with offset
                     â    Indirect with register offset
                     â    Indirect with auto-increment (immediate or register)
                     â    Circular with auto-increment (immediate or register)
                     â    Bit-reversed with auto-increment register

                For example:
                    R2   =   memw(##myvariable)
                    R2   =   memw(R3=##myvariable)
                    R2   =   memw(R4<<#3+##myvariable)
                    R2   =   memw(GP+#200)
                    R2   =   memw(R1)
                    R2   =   memw(R3+#100)
                    R2   =   memw(R3+R4<<#2)
                    R2   =   memw(R3++#4)
                    R2   =   memw(R0++M1)
                    R0   =   memw(R2++#8:circ(M0))
                    R0   =   memw(R2++I:circ(M0))
                    R2   =   memw(R0++M1:brev)

                Auto-increment with register addressing uses one of the two dedicated address-modify
                registers M0 and M1 (which are part of the control registers).




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     21
Hexagon V62 Programmer's Reference Manual                                                        Introduction



                   NOTE      Atomic memory operations (load locked/store conditional) are supported to
                             implement multi-thread synchronization.


     1.3.2      Scalar operations
                The Hexagon processor includes the following scalar operations on fixed-point data:
                    â  Multiplication of 16-bit, 32-bit, and complex data

                     â    Addition and subtraction of 16-, 32-, and 64-bit data (with and without saturation)
                     â    Logical operations on 32- and 64-bit data (AND, OR, XOR, NOT)
                     â    Shifts on 32- and 64-bit data (arithmetic and logical)
                     â    Min/max, negation, absolute value, parity, norm, swizzle
                     â    Compares of 8-, 16-, 32-, and 64-bit data
                     â    Sign and zero extension (8- and 16- to 32-bit, 32- to 64-bit)
                     â    Bit manipulation
                     â    Predicate operations


     1.3.3      Vector operations
                The Hexagon processor includes the following vector operations on fixed-point data:
                    â  Multiplication (halfwords, word by half, vector reduce, dual multiply)

                     â    Addition and subtraction of word and halfword data
                     â    Shifts on word and halfword data (arithmetic and logical)
                     â    Min/max, average, negative average, absolute difference, absolute value
                     â    Compares of word, halfword, and byte data
                     â    Reduce, sum of absolute differences on unsigned bytes
                     â    Special-purpose data arrangement (such as pack, splat, shuffle, align, saturate,
                         splice, truncate, complex conjugate, complex rotate, zero extend)

                   NOTE      Certain vector operations support automatic scaling, saturation, and rounding.

                For example, the following instruction performs a vector operation:
                    R1:0 += vrmpyh(R3:2,R5:4)

                It is defined to perform the following operations in one cycle:
                    R1:0 += ((R2.L * R4.L) +
                       (R2.H * R4.H) +
                       (R3.L * R5.L) +
                       (R3.H * R5.H)
                            )




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       22
Hexagon V62 Programmer's Reference Manual                                                     Introduction



                Figure 1-2 shows a schematic of this instruction type.


                                                                                        Rss


                                                                                        Rtt




                           *                *                *              *
                               32                                          32
                                                32           32




                                                     Add

                                                                                              64

                                                                                        Rdd
                                            64-bit Register Pair

                Figure 1-2 Vector instruction example


     1.3.4      Floating-point operations
                The Hexagon processor includes the following operations on floating-point data:
                    â  Addition and subtraction

                    â    Multiplication (with optional scaling)
                    â    Min/max/compare
                    â    Reciprocal/square root approximation
                    â    Format conversion




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  23
Hexagon V62 Programmer's Reference Manual                                                           Introduction



     1.3.5      Program flow
                The Hexagon processor supports zero-overhead hardware loops. For example:
                      loop0(start,#3)      // loop 3 times
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0

                The loop instructions support nestable loops, with few restrictions on their use.

                Software branches use a predicated branch mechanism. Explicit compare instructions
                generate a predicate bit, which is then tested by conditional branch instructions. For
                example:
                    P1 = cmp.eq(R2, R3)
                    if (P1) jump end

                Jumps and subroutine calls can be conditional or unconditional, and support both PC-
                relative and register indirect addressing modes. For example:
                    jump end
                    jumpr R1
                    call function
                    callr R2

                The subroutine call instructions store the return address in register R31. Subroutine
                returns are performed using a jump indirect instruction through this register. For example:
                    jumpr R31           // subroutine return



     1.3.6      Instruction packets
                Sequences of instructions can be explicitly grouped into packets for parallel execution.
                For example:
                    {
                           R8 = memh(R3++#2)
                           R12 = memw(R1++#4)
                           R = mpy(R10,R6):<<1:sat
                           R7 = add(R9,#2)
                    }

                Brace characters are used to delimit the start and end of an instruction packet.

                Packets can be from one to four instructions long. Packets of varying length can be freely
                mixed in a program.

                Packets have various restrictions on the allowable instruction combinations. The primary
                restriction is determined by the instruction class of the instructions in a packet.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     24
Hexagon V62 Programmer's Reference Manual                                                         Introduction



     1.3.7      Dot-new instructions
                In many cases, a predicate or general register can be both generated and used in the same
                instruction packet. This feature is expressed in assembly language by appending the suffix
                â.newâ to the specified register. For example:
                    {
                    P0 = cmp.eq(R2,#4)
                    if (P0.new) R3 = memw(R4)
                    if (!P0.new) R5 = #5
                    }

                    {
                    R2 = memh(R4+#8)
                    memw(R5) = R2.new
                    }



     1.3.8      Compound instructions
                Certain common operation pairs (add-accumulate, shift-add, deallocframe-return, etc.) can
                be performed by compound instructions. Using compound instructions reduces code size
                and improves code performance.


     1.3.9      Duplex instructions
                A subset of the most common instructions (load, store, branch, ALU) can be packed
                together in pairs into single 32-bit instructions known as duplex instructions. Duplex
                instructions reduce code size.


   1.3.10       Instruction classes
                The instructions are assigned to specific instruction classes. Classes are important for two
                reasons:
                     â  Only certain combinations of instructions can be written in parallel (as shown in
                         Figure 1-1), and the allowable combinations are specified by instruction class.
                     â    Instruction classes logically correspond with instruction types, so they serve as
                         mnemonics for looking up specific instructions.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        25
Hexagon V62 Programmer's Reference Manual                                                                   Introduction



                Figure 1-3 presents an overview of the instruction classes and how they can be grouped
                together.


                         Slot 0                         Slot 1             Slot 2                       Slot 3
                 LD Instructions               LD Instructions
                                                                     XTYPE Instructions         XTYPE Instructions
                 ST Instructions               ST Instructions
                                                                     ALU32 Instructions         ALU32 Instructions
                 ALU32 Instructions            ALU32 Instructions
                                                                     J Instructions             J Instructions
                 MEMOP Instructions            Some J Instructions
                                                                     JR Instructions            CR Instructions
                 NV Instructions
                 SYSTEM Instructions
                 Some J Instructions



                        XTYPE Instructions (32/64 bit)                        J Instructions
                        Arithmetic, Logical, Bit Manipulation                 Jump/Call PC-relative
                        Multiply (Integer, Fractional, Complex)
                        Floating-point Operations
                                                                              JR Instructions
                        Permute / Vector Permute Operations
                        Predicate Operations                                  Jump/Call Register
                        Shift / Shift with Add/Sub/Logical
                        Vector Byte ALU                                       LD Instructions
                        Vector Halfword (ALU, Shift, Multiply)                Loads (8/16/32/64 bit)
                        Vector Word (ALU, Shift)                              Deallocframe

                        ALU32 Instructions                                    ST Instructions
                        Arithmetic / Logical (32 bit)                         Stores (8/16/32/64 bit)
                        Vector Halfword                                       Allocframe

                        CR Instructions                                       MEMOP Instructions
                        Control-Register Transfers                            Operation on memory (8/16/32 bit)
                        Hardware Loop Setup
                        Predicate Logicals & Reductions                       SYSTEM Instructions
                                                                              Prefetch
                        NV Instructions                                       Cache Maintenance
                        New-value Jumps                                       Bus Operations
                        New-value Stores

                Figure 1-3 Instruction classes and combinations


   1.3.11       Instruction intrinsics
                To support efficient coding of the time-critical sections of a program (without resorting to
                assembly language), the C compilers support intrinsics which are used to directly express
                Hexagon processor instructions from within C code. For example:
                    int main()
                    {
                        long long v1 = 0xFFFF0000FFFF0000;
                        long long v2 = 0x0000FFFF0000FFFF;
                        long long result;

                           // find the minimum for each half-word in 64-bit vector
                           result = Q6_P_vminh_PP(v1,v2);
                    }

                Intrinsics are defined for most of the Hexagon processor instructions.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             26
Hexagon V62 Programmer's Reference Manual                                                          Introduction



       1.4      Processor versions
                The V62 Hexagon processor is a member of the sixth version of the Hexagon processor
                architecture. While remaining functionally equivalent to V51 at the user level, V62 adopts
                a new micro-architecture, which provides higher performance for modem and audio
                applications.

                V62 extends the V61 architecture with the following features:

                     â    Dual-cluster micro-architecture
                     â    Simultaneous multi-threading (SMT)

                For more information on V61, see the Hexagon V60/V61 Programmer's Reference
                Manual.


       1.5      Notation
                This section presents the notational conventions used in this document to describe
                Hexagon processor instructions:
                     â  Instruction syntax

                     â    Register operands
                     â    Numeric operands

                   NOTE      The notation described here does not appear in actual assembly language
                             instructions. It is used only to specify the instruction syntax and behavior.


     1.5.1      Instruction syntax
                The following notation is used to describe the syntax of instructions:
                     â    Monospaced font is used for instructions
                     â    Square brackets enclose optional items (e.g., [:sat], means that saturation is
                         optional)
                     â    Braces indicate a choice of items (e.g., {Rs,#s16}, means that either Rs or a
                         signed 16-bit immediate can be used)




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        27
Hexagon V62 Programmer's Reference Manual                                                         Introduction



     1.5.2      Register operands
                The following notation describes register operands in the syntax and behavior of
                instructions:
                     Rds[.elst]

                The ds field indicates the register operand type and bit size (as defined in Table 1-1).

                Table 1-1     Register symbols
                     Symbol             Operand Type           Size (in Bits)
                d                 Destination                       32
                dd                                                  64
                s                 First source                      32
                ss                                                  64
                t                 Second source                     32
                tt                                                  64
                u                 Third source                      32
                uu                                                  64
                x                 Source and destination            32
                xx                                                  64


                Examples of ds field (describing instruction syntax):
                     Rd = neg(Rs)                  // Rd -> 32-bit dest, Rs 32-bit source
                     Rd = xor(Rs,Rt)               // Rt -> 32-bit second source
                     Rx = insert(Rs,Rtt)           // Rx -> both source and dest

                Examples of ds field (describing instruction behavior):
                     Rdd = Rss + Rtt               // Rdd, Rss, Rtt -> 64-bit registers




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     28
Hexagon V62 Programmer's Reference Manual                                                                             Introduction



                The optional elst field (short for âelement size and typeâ) specifies parts of a register when
                the register is used as a vector. It can specify the following values:
                     â  A signed or unsigned byte, halfword, or word within the register (as defined in
                         Figure 1-4)
                      â    A bit-field within the register (as defined in Table 1-2)


                               Rds.elst
                                      s, t, u = 32-bit source register
                                      d          = 32-bit register destination
                                      x          = 32-bit register source/destination
                                      ss, tt, uu = 64-bit source register pair
                                      dd         = 64-bit register destination
                                      xx         = 64-bit register source/destination
         Rds.elst

                       .b[7]       .b[6]      .b[5]       .b[4]   .b[3]       .b[2]      .b[1]       .b[0]   Signed Bytes

                      .ub[7]      .ub[6]   .ub[5]     .ub[4]      .ub[3]    .ub[2]    .ub[1]     .ub[0] Unsigned Bytes

                          .h[3]                   .h[2]               .h[1]                  .h[0]           Signed Halfwords

                          .uh[3]                 .uh[2]              .uh[1]                 .uh[0]           Unsigned Halfwords

                                      .w[1]                                      .w[0]                       Signed Words

                                     .uw[1]                                     .uw[0]                       Unsigned Words


                Figure 1-4 Register field symbols

                Table 1-2      Register bit field symbols
                      Symbol                                              Meaning
                .sN                   Bits [N-1:0] are treated as a N-bit signed number.
                                      For example, R0.s16 means that the least significant 16-bits of R0
                                      are treated as a 16-bit signed number.
                .uN                   Bits [N-1:0] are treated as a N-bit unsigned number.
                .H                    The most-significant 16 bits of a 32-bit register.
                .L                    The least-significant 16 bits of a 32-bit register.


                Examples of elst field:
                      EA = Rt.h[1]                                 // .h[1] -> bit field 31:16 in Rt
                      Pd = (Rss.u64 > Rtt.u64)                     // .u64 -> unsigned 64-bit value
                      Rd = mpyu(Rs.L,Rt.H)                         // .L/.H -> low/high 16-bit fields

                     NOTE      The control and predicate registers use the same notation as the general
                               registers, but are written as Cx and Px (respectively) instead of Rx.



80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                         29
Hexagon V62 Programmer's Reference Manual                                                             Introduction



     1.5.3      Numeric operands
                Table 1-3 lists the notation used to describe numeric operands in the syntax and behavior
                of instructions:

                Table 1-3      Instruction operands
                     Symbol                         Meaning                             Min           Max
                #uN               Unsigned N-bit immediate value                0              2N-1
                #sN               Signed N-bit immediate value                  -2N-1          2N-1-1
                #mN               Signed N-bit immediate value                  -(2N-1-1)      2N-1-1
                #uN:S             Unsigned N-bit immediate value representing   0              (2N-1) ï´ 2S
                                  integral multiples of 2S in specified range
                #sN:S             Signed N-bit immediate value representing     (-2N-1) ï´ 2S   (2N-1-1) ï´ 2S
                                  integral multiples of 2S in specified range
                #rN:S             Same as #sN:S, but value is offset from PC    (-2N-1) ï´ 2S   (2N-1-1) ï´ 2S
                                  of current packet
                ##                Same as #, but associated value (u,s,m,r)     â              â
                                  is 32 bits
                usatN             Saturate value to unsigned N-bit number       0              2N-1
                satN              Saturate value to signed N-bit number         -2N-1          2N-1-1

                #uN, #sN, and #mN specify immediate operands in instructions. The # symbol appears in
                the actual instruction to indicate the immediate operand.

                #rN specifies loop and branch destinations in instructions. In this case the # symbol does
                not appear in the actual instruction; instead, the entire #rN symbol (including its :S suffix)
                is expressed as a loop or branch symbol whose numeric value is determined by the
                assembler and linker. For example:
                     call my_proc                    // instruction example

                The :S suffix indicates that the S least-significant bits in a value are implied zero bits and
                therefore not encoded in the instruction. The implied zero bits are called scale bits.

                For example, #s4:2 denotes a signed immediate operand represented by four bits encoded
                in the instruction, and two scale bits. The possible values for this operand are -32, -28, -24,
                -20, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, and 28.

                ## specifies a 32-bit immediate operand in an instruction (including a loop or branch
                destination). The ## symbol appears in the actual instruction to indicate the operand.

                Examples of operand symbols:
                     Rd =   add(Rs,#s16)            //   #s16      ->   signed 16-bit imm value
                     Rd =   memw(Rs++#s4:2)         //   #s4:2     ->   scaled signed 4-bit imm value
                     call   #r22:2                  //   #r22:2    ->   scaled 22-bit PC-rel addr value
                     Rd =   ##u32                   //   ##u32     ->   unsigned 32-bit imm value




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       30
Hexagon V62 Programmer's Reference Manual                                                        Introduction



                   NOTE       When an instruction contains more than one immediate operand, the operand
                              symbols are specified in upper and lower case (e.g., #uN and #UN) to indicate
                              where they appear in the instruction encodings


       1.6      Terminology
                Table 1-4 lists the symbols used in Hexagon processor instruction names to specify the
                supported data types.

                Table 1-4      Data symbols
                    Size            Symbol                Type
                8-bit           B             Byte
                8-bit           UB            Unsigned Byte
                16-bit          H             Half word
                16-bit          UH            Unsigned Half word
                32-bit          W             Word
                32-bit          UW            Unsigned Word
                64-bit          D             Double word




       1.7      Technical assistance
                For assistance or clarification on information in this document, submit a case to
                Qualcomm Technologies at https://support.cdmatech.com.

                If you do not have access to the CDMATech Support website, register for access or send
                email to support.cdmatech@qti.qualcomm.com.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  31
         2 Registers


                This chapter describes the Hexagon processor registers:

                    ï®   General registers
                    ï®   Control registers

                General registers are used for all general-purpose computation including address
                generation and scalar and vector arithmetic.

                Control registers support special-purpose processor features such as hardware loops and
                predicates.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     32
Hexagon V62 Programmer's Reference Manual                                                         Registers



       2.1      General registers
                The Hexagon processor has thirty-two 32-bit general-purpose registers (named R0 through
                R31). These registers are used to store operands in virtually all the instructions:

                    ï®    Memory addresses for load/store instructions
                    ï®    Data operands for arithmetic/logic instructions
                    ï®    Vector operands for vector instructions

                For example:
                    R1 = memh(R0)                             // Load from address R0
                    R4 = add(R2,R3)                           // Add
                    R28 = vaddh(R11,R10)                      // Vector add halfword

                Figure 2-1 shows the general registers.


                    R3           R2        R1           R0



                         R3:2                    R1:0

                                      ..
                                       .
                   R31          R30        R29          R28



                        R31:30               R29:28

                Figure 2-1 General registers

                Aliased registers

                Three of the general registers â R29 through R31 â are used to support subroutines
                (Section 7.3.2) and the software stack (Chapter 8). These registers are modified implicitly
                by the subroutine and stack instructions. They have symbol aliases which are used to
                indicate when these registers are being accessed as subroutine and stack registers.

                For example:
                    SP = add(SP, #-8)                   // SP is alias of R29
                    allocframe                          // Modifies SP (R29) and FP (R30)
                    call init                           // Modifies LR (R31)




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    33
Hexagon V62 Programmer's Reference Manual                                                                      Registers



                Table 2-1 defines the aliased general registers.

                Table 2-1     General register aliases
                  Register        Alias              Name                            Description
                      R29          SP         Stack pointer      Points to topmost element of stack in memory.
                      R30          FP         Frame pointer      Points to current procedure frame on stack.

                                                                 Used by external debuggers to examine the stack
                                                                 and determine call sequence, parameters, local
                                                                 variables, etc.
                      R31          LR         Link register      Stores return address of a subroutine call.


                Register pairs

                The general registers can be specified as register pairs which represent a single 64-bit
                register. For example:
                     R1:0 = memd(R3)                                   // Load doubleword
                     R7:6 = valignb(R9:8,R7:6, #2)                     // Vector align

                     NOTE    The first register in a register pair must always be odd-numbered, and the
                             second must be the next lower register.

                Table 2-2 lists the general register pairs.

                Table 2-2     General register pairs
                       Register                  Register Pair
                R0                        R1:0
                R1
                R2                        R3:2
                R3
                R4                        R5:4
                R5
                R6                        R7:6
                R7
                                          â¦
                R24                       R25:24
                R25
                R26                       R27:26
                R27
                R28                       R29:28
                R29 (SP)
                R30 (FP)                  R31:30 (LR:FP)
                R31 (LR)




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                              34
Hexagon V62 Programmer's Reference Manual                                                               Registers



       2.2      Control registers
                The Hexagon processor includes a set of 32-bit control registers which provide access to
                processor features such as the program counter, hardware loops, and vector predicates.

                Unlike general registers, control registers can be used as instruction operands only in the
                following cases:

                     ï®   Instructions that require a specific control register as an operand
                     ï®   Register transfer instructions

                For example:
                    R2 = memw(R0++M1)               // Auto-increment addressing mode (M1)
                    R9 = PC                         // Get program counter (PC)
                    LC1 = R3                        // Set hardware loop count (LC1)

                   NOTE      When a control register is used in a register transfer, the other operand must
                             be a general register.

                Figure 2-2 shows the control registers.


                     LC0       SA0                               UPCYCLELO
                                                Loop Registers                       Cycle Count Registers
                     LC1       SA1                               UPCYCLEHI


                     PC        Program Counter                   FRAMELIMIT    Stack Bounds Register


                     USR      User Status Register               FRAMEKEY      Stack Smash Register


                     M0                                          PKTCOUNTLO
                                      Modifier Registers                             Packet Count Registers
                     M1                                          PKTCOUNTHI


                     P3:0     Predicate Registers                 UTIMERLO
                                                                                     Qtimer Registers
                     UGP      User General Pointer                UTIMERHI


                     GP       Global Pointer


                     CS0                                                       = V61 or greater
                                     Circular Start Registers
                     CS1



                Figure 2-2 Control registers




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         35
Hexagon V62 Programmer's Reference Manual                                                            Registers



                Aliased registers

                The control registers have numeric aliases (C0 through C31).

                Table 2-3 lists the aliased control registers.


                Table 2-3       Aliased control registers
                     Register           Alias                      Name
                       SA0               C0      Loop start address register 0
                       LC0               C1      Loop count register 0
                       SA1               C2      Loop start address register 1
                       LC1               C3      Loop count register 1
                       P3:0              C4      Predicate registers 3:0
                     reserved            C5      â
                        M0               C6      Modifier register 0
                        M1               C7      Modifier register 1
                       USR               C8      User status register
                        PC               C9      Program counter
                       UGP              C10      User general pointer
                        GP               C11     Global pointer
                       CS0              C12      Circular start register 0
                       CS1              C13      Circular start register 1
                   UPCYCLELO            C14      Cycle count register (low)
                   UPCYCLEHI            C15      Cycle count register (high)
                    UPCYCLE            C15:14    Cycle count register
                   FRAMELIMIT           C16      Frame limit register
                   FRAMEKEY             C17      Frame key register
                  PKTCOUNTLO            C18      Packet count register (low)
                  PKTCOUNTHI            C19      Packet count register (high)
                   PKTCOUNT            C19:18    Packet count register
                     reserved          C20-29    â
                    UTIMERLO            C30      Qtimer register (low)
                    UTIMERHI            C31      Qtimer register (high)
                     UTIMER            C31:30    Qtimer register


                   NOTE       The control register numbers (0-31) are used to specify the control registers in
                              instruction encodings (Chapter 10).

                              The registers shown in gray are supported only in processor versions V61 or
                              greater.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      36
Hexagon V62 Programmer's Reference Manual                                                            Registers



                Register pairs

                The control registers can be specified as register pairs which represent a single 64-bit
                register. Control registers specified as pairs must use their numeric aliases. For example:
                     C1:0 = R5:4          // C1:0 specifies the LC0/SA0 register pair

                     NOTE    The first register in a control register pair must always be odd-numbered, and
                             the second must be the next lower register.

                Table 2-4 lists the control register pairs.


                Table 2-4     Control register pairs
                      Register               Register Pair
                C0                    C1:0
                C1
                C2                    C3:2
                C3
                C4                    C5:4
                C5
                C6                    C7:6
                C7
                                      â¦
                C30                   C31:30
                C31



     2.2.1      Program counter
                The Program Counter (PC) register points to the next instruction packet to execute
                (Section 3.3). It is modified implicitly by instruction execution, but can be read directly.
                For example:
                     R7 = PC          // Get program counter

                     NOTE    The PC register is read-only: writing to it has no effect.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         37
Hexagon V62 Programmer's Reference Manual                                                           Registers



     2.2.2      Loop registers
                The Hexagon processor includes two sets of loop registers to support nested hardware
                loops (Section 7.2). Each hardware loop is implemented with a pair of registers containing
                the loop count and loop start address. The loop registers are modified implicitly by the
                loop instruction, but can also be accessed directly. For example:
                    loop0(start, R4)        // Modifies LC0 and SA0 (LC0=R4, SA0=&start)
                    LC1 = R22               // Set loop1 count
                    R9 = SA1                // Get loop1 start address

                Table 2-5 defines the loop registers.

                Table 2-5    Loop registers
                     Register               Name                                Description
                    LC0, LC1        Loop count              Number of loop iterations to execute.

                    SA0, SA1        Loop start address      Address of first instruction in loop.



     2.2.3      User status register
                The user status register (USR) stores processor status and control bits that are accessible
                by user programs. The status bits contain the status results of certain instructions, while
                the control bits contain user-settable processor modes for hardware prefetching. For
                example:
                    R9:8 = vaddw(R9:8, R3:2):sat                 // Vector add words
                    R6 = USR                                     // Get saturation status

                USR stores the following status and control values:
                ï®   Cache prefetch enable (Section 5.9.6)
                ï®   Cache prefetch status (Section 5.9.6)
                ï®   Floating point modes (Section 4.3.4)
                ï®   Floating point status (Section 4.3.4)
                ï®   Hardware loop configuration (Section 7.2)
                ï®   Sticky saturation overflow (Section 4.2.2)

                    NOTE    A user control register transfer to USR cannot be grouped in an instruction
                            packet with a floating point instruction (Section 4.3.4).

                            Whenever a transfer to USR changes the Enable trap bits [29:25], an isync
                            instruction (Section 5.10) must be executed before the new exception
                            programming can take effect.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         38
Hexagon V62 Programmer's Reference Manual                                                                 Registers



                Table 2-6 defines the user status register.

                Table 2-6    User status register
                  Name      R/W     Bits      Field                            Description
                USR                  32                 User Status Register
                             R       31    PFA          L2 Prefetch Active.
                                                        1: l2fetch instruction in progress
                                                        0: l2fetch finished (or inactive)
                                                        Set when non-blocking l2fetch instruction is prefetching
                                                        requested data.
                                                        Remains set until l2fetch prefetch operation is completed
                                                        (or not active).
                             R       30    reserved     Return 0 if read.
                                                        Reserved for future expansion. To remain compatible
                                                        with future processor versions, software should always
                                                        write this field with the same value read from the field.
                            R/W      29    FPINEE       Enable trap on IEEE Inexact.
                            R/W      28    FPUNFE       Enable trap on IEEE Underflow.
                            R/W      27    FPOVFE       Enable trap on IEEE Overflow.
                            R/W      26    FPDBZE       Enable trap on IEEE Divide-By-Zero.
                            R/W      25    FPINVE       Enable trap on IEEE Invalid.
                             R       24    reserved     Reserved
                            R/W    23:22 FPRND          Rounding Mode for Floating-Point Instructions.
                                                        00: Round to nearest, ties to even (default)
                                                        01: Toward zero
                                                        10: Downward (toward negative infinity)
                                                        11: Upward (toward positive infinity)
                             R     21:20 reserved       Return 0 if read.
                                                        Reserved for future expansion. To remain compatible
                                                        with future processor versions, software should always
                                                        write this field with the same value read from the field.
                             R     19:18 reserved       Reserved
                             R       17    reserved     Return 0 if read.
                                                        Reserved for future expansion. To remain compatible
                                                        with future processor versions, software should always
                                                        write this field with the same value read from the field.
                            R/W    16:15 HFI            L1 Instruction Prefetch.
                                                        00: Disable
                                                        01: Enable (1 line)
                                                        10: Enable (2 lines)




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                              39
Hexagon V62 Programmer's Reference Manual                                                               Registers



                Table 2-6   User status register (Continued)
                  Name      R/W    Bits     Field                           Description
                            R/W   14:13 HFD           L1 Data Cache Prefetch.
                                                      Four levels are defined from disabled to Aggressive. It is
                                                      implementation-defined how these levels should be
                                                      interpreted.
                                                      00: Disable
                                                      01: Conservative
                                                      10: Moderate
                                                      11: Aggressive
                            R/W     12    PCMME       Enable packet counting in Monitor mode.
                            R/W     11    PCGME       Enable packet counting in Guest mode.
                            R/W     10    PCUME       Enable packet counting in User mode.
                            R/W    9:8    LPCFGE      Hardware Loop Configuration.
                                                      Number of loop iterations (0-3) remaining before pipeline
                                                      predicate should be set.
                            R      7:6    reserved    Return 0 if read.
                                                      Reserved for future expansion. To remain compatible
                                                      with future processor versions, software should always
                                                      write this field with the same value read from the field.
                            R/W     5     FPINPF      Floating-point IEEE Inexact Sticky Flag.
                            R/W     4     FPUNFF      Floating-point IEEE Underflow Sticky Flag.
                            R/W     3     FPOVFF      Floating-point IEEE Overflow Sticky Flag.
                            R/W     2     FPDBZF      Floating-point IEEE Divide-By-Zero Sticky Flag.
                            R/W     1     FPINVF      Floating-point IEEE Invalid Sticky Flag.
                            R/W     0     OVF         Sticky Saturation Overflow.
                                                      1: Saturation occurred
                                                      0: No saturation
                                                      Set when saturation occurs while executing instruction
                                                      that specifies optional saturation.
                                                      Remains set until explicitly cleared by a USR = Rs
                                                      instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             40
Hexagon V62 Programmer's Reference Manual                                                           Registers



     2.2.4      Modifier registers
                The modifier registers (M0-M1) are used in the following addressing modes:

                     ï®   Indirect auto-increment register addressing
                     ï®   Circular addressing
                     ï®   Bit-reversed addressing

                Indirect auto-increment

                In indirect auto-increment register addressing (Section 5.7.9) the modifier registers store a
                signed 32-bit value which specifies the increment (or decrement) value. For example:
                    M1 = R0                         // Set modifier register
                    R3 = memw(R2++M1)               // Load word

                Table 2-7 defines the modifier registers as used in auto-increment register addressing.

                Table 2-7    Modifier registers (indirect auto-increment addressing)
                     Register                Name                            Description
                      M0, M1          Increment           Signed auto-increment value.


                Circular

                In circular addressing (Section 5.7.10) the modifier registers store the circular buffer
                length and related âKâ and âIâ values. For example:
                    M0 = R7                                // Set modifier register
                    R0 = memb(R2++#4:circ(M0))             // Load from circ buffer pointed
                                                           // to by R2 with size/K vals in M0

                    R0 = memb(R7++I:circ(M1))              // Load from circ buffer pointed
                                                           // to by R7 with size/K/I vals in M1

                Table 2-8 defines the modifier registers as used in circular addressing.

                Table 2-8    Modifier registers (circular addressing)
                   Name         R/W     Bits      Field                          Description
                  M0, M1                32                 Circular buffer specifier.

                                R/W    31:28 I[10:7]       I value (MSB - see Section 5.7.11)
                                R/W    27:24 K             K value (Section 5.7.10)
                                R/W    23:17 I[6:0]        I value (LSB)
                                R/W     16:0   Length      Circular buffer length




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     41
Hexagon V62 Programmer's Reference Manual                                                           Registers



                Bit-reversed

                In bit-reversed addressing (Section 5.7.12) the modifier registers store a signed 32-bit
                value which specifies the increment (or decrement) value. For example:
                    M1 = R7                 // Set modifier register
                    R2 = memub(R0++M1:brev) // The address is (R0.H | bitrev(R0.L))
                                            // The orginal R0 (not reversed) is added
                                            // to M1 and written back to R0

                Table 2-9 defines the modifier registers as used in bit-reversed addressing.

                Table 2-9     Modifier registers (bit-reversed addressing)
                     Register                Name                           Description
                      M0, M1        Increment             Signed auto-increment value.



     2.2.5      Predicate registers
                The predicate registers (P0-P3) store the status results of the scalar and vector compare
                instructions (Chapter 6). For example:
                    P1 = cmp.eq(R2, R3)                 //    Scalar compare
                    if (P1) jump end                    //    Jump to address (conditional)
                    R8 = P1                             //    Get compare status (P1 only)
                    P3:0 = R4                           //    Set compare status (P0-P3)

                The four predicate registers can be specified as a register quadruple (P3:0) which
                represents a single 32-bit register.

                   NOTE     Unlike the other control registers, the predicate registers are only 8 bits wide
                            because vector compares return a maximum of 8 status results.

                Table 2-10 defines the predicate registers.

                Table 2-10 Predicate registers
                     Register          Bits                   Description
                   P0, P1,P2, P3        8       Compare status results.
                       P3:0            32       Compare status results.
                                      31:24     P3 register
                                      23:16     P2 register
                                       15:8     P1 register
                                       7:0      P0 register




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       42
Hexagon V62 Programmer's Reference Manual                                                                   Registers



     2.2.6      Circular start registers
                The circular start registers (CS0 - CS1) store the start address of a circular buffer in
                circular addressing (Section 5.7.10). For example:
                     CS0 = R5                                     // Set circ start register
                     M0 = R7                                      // Set modifier register
                     R0 = memb(R2++#4:circ(M0))                   // Load from circ buffer pointed
                                                                  // to by CS0 with size/K vals in M0

                Table 2-11 defines the circular start registers.

                Table 2-11      Circular start registers
                       Register                  Name                               Description
                     CS0, CS1           Circular Start         Circular buffer start address.



     2.2.7      User general pointer register
                The user general pointer (UGP) register is a general-purpose control register. For example:
                     R9 = UGP             // Get UGP
                     UGP = R3             // Set UGP

                     NOTE       UGP is typically used to store the address of thread local storage.

                Table 2-12 defines the user general pointer register.

                Table 2-12 User general pointer register
                     Register                   Name                            Description
                      UGP          User General Pointer           General-purpose control register.



     2.2.8      Global pointer
                The Global Pointer (GP) is used in GP-relative addressing. For example:
                     GP = R7                             // Set GP
                     R2 = memw(GP+#200)                  // GP-relative load

                Table 2-13 defines the global pointer register.

                Table 2-13 Global pointer register
                     Name         R/W     Bits         Field                          Description
                GP                         32                   Global Pointer Register
                                  R/W     31:7    GDP           Global Data Pointer (Section 5.7.4).
                                   R       6:0    reserved      Return 0 if read.
                                                                Reserved for future expansion. To remain forward-
                                                                compatible with future processor versions, software
                                                                should always write this field with the same value
                                                                read from the field.



80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                               43
Hexagon V62 Programmer's Reference Manual                                                             Registers



     2.2.9      Cycle count registers
                The cycle count registers (UPCYCLELO - UPCYCLEHI) store a 64-bit value containing the
                current number of processor cycles executed since the Hexagon processor was last reset.
                For example:
                    R5 = UPCYCLEHI           // Get cycle count (high)
                    R4 = UPCYCLELO           // Get cycle count (low)
                    R5:4 = UPCYCLE           // Get cycle count

                   NOTE     The RTOS must grant permission to access these registers. Without this
                            permission, reading these registers from user code always returns zero.

                Table 2-14 defines the cycle count registers.

                Table 2-14 Cycle count registers
                      Register               Name                               Description
                   UPCYCLELO          Cycle count (low)        Processor cycle count (low 32 bits)

                   UPCYCLEHI          Cycle count (high)       Processor cycle count (high 32 bits)

                     UPCYCLE          Cycle count              Processor cycle count (64 bits)



   2.2.10       Frame limit register
                The frame limit register (FRAMELIMIT) stores the low address of the memory area
                reserved for the software stack (Section 8.3.1). For example:
                    R9 = FRAMELIMIT                // Get frame limit register
                    FRAMELIMIT = R3                // Set frame limit register

                Table 2-15 defines the frame limit register.

                Table 2-15 Frame limit register
                     Register              Name                          Description
                  FRAMELIMIT         Frame Limit           Low address of software stack area.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       44
Hexagon V62 Programmer's Reference Manual                                                             Registers



   2.2.11       Frame key register
                The frame key register (FRAMEKEY) stores the key value that is used to XOR-scramble
                return addresses when they are stored on the software stack (Section 8.3.2). For example:
                    R2 = FRAMEKEY            // Get frame key register
                    FRAMEKEY = R1            // Set frame key register

                Table 2-16 defines the frame key register.

                Table 2-16 Frame key register
                     Register              Name                         Description
                   FRAMEKEY         Frame Key              Key used to scramble return addresses
                                                           stored on software stack.



   2.2.12       Packet count registers
                The packet count registers (PKTCOUNTLO - PKTCOUNTHI) store a 64-bit value
                containing the current number of instruction packets executed since a PKTCOUNT register
                was last written to. For example:
                    R9 = PKTCOUNTHI           // Get packet count (high)
                    R8 = PKTCOUNTLO           // Get packet count (low)
                    R9:8 = PKTCOUNT           // Get packet count

                Packet counting can be configured to operate only in specific sets of processor modes
                (e.g., user mode only, or guest and monitor modes only). The configuration for each mode
                is controlled by bits [12:10] in the user status register (Section 2.2.3).

                Packets with exceptions are not counted as committed packets.

                   NOTE     Each hardware thread has its own set of packet count registers.

                            The RTOS must grant permission to access these registers. Without this
                            permission, reading these registers from user code always returns zero.

                            When a value is written to a PKTCOUNT register, the 64-bit packet count
                            value is incremented before the value is stored in the register.

                Table 2-17 defines the packet count registers.

                Table 2-17 Packet count registers
                      Register               Name                             Description
                  PKTCOUNTLO         Packet count (low)       Processor packet count (low 32 bits)

                  PKTCOUNTHI         Packet count (high)      Processor packet count (high 32 bits)

                    PKTCOUNT         Cycle count              Processor packet count (64 bits)




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       45
Hexagon V62 Programmer's Reference Manual                                                             Registers



   2.2.13       Qtimer registers
                The Qtimer registers (UTIMERLO - UTIMERHI) provide access to the Qtimer global
                reference count value. They enable Hexagon software to read the 64-bit time value
                without having to perform an expensive AHB load. For example:
                    R5 = UTIMERHI           // Get Qtimer reference count (high)
                    R4 = UTIMERLO           // Get Qtimer reference count (low)
                    R5:4 = UTIMER           // Get Qtimer reference count

                These registers are read-only â they are automatically updated by hardware to always
                contain the current Qtimer value.

                   NOTE     The RTOS must grant permission to access these registers. Without this
                            permission, reading these registers from user code always returns zero.

                Table 2-18 defines the packet count registers.

                Table 2-18 Qtimer registers
                      Register             Name                          Description
                    UTIMERLO         Qtimer (low)      Qtimer global reference count (low 32 bits)

                    UTIMERHI         Qtimer (high)     Qtimer global reference count (high 32 bits)

                      UTIMER         Qtimer            Qtimer global reference count (64 bits)




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       46
         3 Instructions


                  This chapter covers the following topics:
                       ï® Instruction syntax

                       ï®   Instruction classes
                       ï®   Instruction packets
                       ï®   Instruction intrinsics
                       ï®   Compound instructions
                       ï®   Duplex instructions

                  The instruction encoding is described in Chapter 10.

                  For detailed descriptions of the Hexagon processor instructions see Chapter 11.


       3.1        Instruction syntax
                  Most Hexagon processor instructions have the following syntax:
                      dest = instr_name(source1,source2,...)[:option1][:option2]...

                  The item specified on the left-hand side (LHS) of the equation is assigned the value
                  specified by the right-hand side (RHS). For example:
                      R2 = add(R3,R1)            // Add R3 and R1, assign result to R2

                  Table 3-1 lists symbols commonly used in Hexagon processor instructions.

Table 3-1       Instruction symbols
     Symbol                            Example                                    Meaning
=                    R2 = R3                                    Assignment of RHS to LHS
#                    R1 = #1                                    Immediate value
0x                   0xBABE                                     Hexadecimal number prefix
memXX                R2 = memub(R3)                             Memory access
                                                                XX specifies access size and type




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  47
Hexagon V62 Programmer's Reference Manual                                                               Instructions



Table 3-1       Instruction symbols (Continued)
       Symbol                        Example                                         Meaning
;                    R2 = R3; R4 = R5;                          Instruction delimiter, or end of instruction
{â¦}                  {R2 = R3; R5 = R6}                         Instruction packet delimiter
(â¦)                  R2 = memw(R0 + #100)                       Source list delimiter
:endloopX            :endloop0                                  Loop end
                                                                X specifies loop instruction (0 or 1)
:t                   if (P0.new) jump:t target                  Direction hint (jump taken)
:nt                  if (!P1.new) jump:nt target                Direction hint (jump not taken)
:sat                 R2 = add(R1,R2):sat                        Saturate result
:rnd                 R2 = mpy(R1.H,R2.H):rnd                    Round result
:carry               R5:4=add(R1:0,R3:2,P1):carry               Predicate used as carry input and output
:<<16                R2 = add(R1.L,R2.L):<<16                   Shift result left by halfword




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          48
Hexagon V62 Programmer's Reference Manual                                                              Instructions



        3.2          Instruction classes
                     The Hexagon processor instructions are assigned to specific instruction classes. Classes
                     determine what combinations of instructions can be written in parallel (Section 3.3).

                     Instruction classes logically correspond with instruction types. For instance, the ALU32
                     class contains ALU instructions which operate on 32-bit operands.

                     Table 3-2 lists the instruction classes and subclasses.

Table 3-2       Instruction classes
     Class                 Subclass                            Description                        Section
XTYPE           â                              Various operations                             Section 11.10
                ALU                               64-bit ALU operations                       Section 11.10.1
                Bit                               Bit operations                              Section 11.10.2
                Complex                           Complex math (using real and                Section 11.10.3
                                                  imaginary numbers)
                Floating point                    Floating point operations                   Section 11.10.4
                Multiply                          Multiply operations                         Section 11.10.5
                Permute                           Vector permute and format conversion        Section 11.10.6
                                                  (pack, splat, swizzle)
                Predicate                         Predicate operations                        Section 11.10.7
                Shift                             Shift operations                            Section 11.10.8
                                                  (with optional ALU operations)
ALU32           â                              32-bit ALU operations                          Section 11.1
                ALU                               Arithmetic and logical                      Section 11.1.1
                Permute                           Permute                                     Section 11.1.2
                Predicate                         Predicate operations                        Section 11.1.3
CR              â                              Control register access, loops                 Section 11.2
JR              â                              Jumps (register indirect addressing mode)      Section 11.3
J               â                              Jumps (PC-relative addressing mode)            Section 11.4
LD              â                              Memory load operations                         Section 11.5
MEMOP           â                              Memory operations                              Section 11.6
NV              â                              New-value operations                           Section 11.7
                Jump                              New-value jumps                             Section 11.7.1
                Store                             New-value stores                            Section 11.7.2
ST              â                              Memory store operations;                       Section 11.8
                                               alloc stack frame
SYSTEM           â                             Operating system access                        Section 11.9
                USER                              Application-level access                    Section 11.9.3




80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     49
Hexagon V62 Programmer's Reference Manual                                                         Instructions



       3.3      Instruction packets
                Instructions can be grouped together to form packets of independent instructions which
                are executed together in parallel. The packets can contain 1, 2, 3, or 4 instructions.

                Instruction packets must be explicitly specified in software. They are expressed in
                assembly language by enclosing groups of instructions in curly braces. For example:
                    { R0 = R1; R2 = R3 }

                Various rules and restrictions exist on what types of instructions can be grouped together,
                and in what order they can appear in the packet. In particular, packet formation is subject
                to the following constraints:

                     ï®   Resource constraints determine how many instructions of a specific type can
                         appear in a packet. The Hexagon processor has a fixed number of execution units:
                         each instruction is executed on a particular type of unit, and each unit can process
                         at most one instruction at a time. Thus, for example, because the Hexagon
                         processor contains only two load units, an instruction packet with three load
                         instructions is invalid. The resource constraints are described in Section 3.3.3
                     ï®   Grouping constraints are a small set of rules that apply above and beyond the
                         resource constraints. These rules are described in Section 3.3.4.
                     ï®   Dependency constraints ensure that no write-after-write hazards exist in a packet.
                         These rules are described in Section 3.3.5.
                     ï®   Ordering constraints dictate the ordering of instructions within a packet. These
                         rules are described in Section 3.3.6.
                     ï®   Alignment constraints dictate the placement of packets in memory. These rules are
                         described in Section 3.3.7.

                   NOTE      Individual instructions (which are not explicitly grouped in packets) are
                             executed by the Hexagon processor as packets containing a single instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       50
Hexagon V62 Programmer's Reference Manual                                                             Instructions



     3.3.1      Packet execution semantics
                Packets are defined to have parallel execution semantics. Specifically, the execution
                behavior of a packet is defined as follows:

                     ï®   First, all instructions in the packet read their source registers in parallel.
                     ï®   Next, all instructions in the packet execute.
                     ï®   Finally, all instructions in the packet write their destination registers in parallel.

                For example, consider the following packet:
                    { R2 = R3; R3 = R2; }

                In the first phase, registers R3 and R2 are read from the register file. Then, after execution,
                R2 is written with the old value of R3 and R3 is written with the old value of R2. In effect,
                the result of this packet is that the values of R2 and R3 are swapped.

                   NOTE      Dual stores (Section 5.4), dual jumps (Section 7.7), new-value stores
                             (Section 5.5), new-value compare jumps (Section 7.5.1), and dot-new
                             predicates (Section 6.1.4) have non-parallel execution semantics.


     3.3.2      Sequencing semantics
                Packets of any length can be freely mixed in code. A packet is considered an atomic unit:
                in essence, a single large âinstructionâ. From the program perspective a packet either
                executes to completion or not at all; it never executes only partially. For example, if a
                packet causes a memory exception, the exception point is established before the packet.

                A packet containing multiple load/store instructions may require service from the external
                system. For instance, consider the case of a packet which performs two load operations
                that both miss in the cache. The packet requires the data to be supplied by the memory
                system:

                     ï®   From the memory system perspective the two resulting load requests are
                         processed serially.
                     ï®   From the program perspective, however, both load operations must complete
                         before the packet can complete.

                Thus, the packet is atomic from the program perspective.

                Packets have a single PC address which is the address of the start of the packet. Branches
                cannot be performed into the middle of a packet.

                Architecturally, packets execute to completion â including updating all registers and
                memory â before the next packet begins. As a result, application programs are not exposed
                to any pipeline artifacts.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            51
Hexagon V62 Programmer's Reference Manual                                                                Instructions



     3.3.3      Resource constraints
                A packet cannot use more hardware resources than are physically available on the
                processor. For instance, because the Hexagon processor has only two load units, a packet
                with three load instructions is invalid. The behavior of such a packet is undefined. The
                assembler automatically rejects packets that oversubscribe the hardware resources.

                The processor supports up to four parallel instructions. The instructions are executed in
                four parallel pipelines which are referred to as slots.The four slots are named Slot 0,
                Slot 1, Slot 2, and Slot 3. (For more information see Section 1.2.)

                   NOTE      endloopN instructions (Section 7.2.2) do not use any slots.

                Each instruction belongs to a specific instruction class (Section 3.2). For example, jumps
                belong to instruction class J, while loads belong to instruction class LD. An instructionâs
                class determines which slot it can execute in.

                Figure 3-1 shows which instruction classes can be assigned to each of the four slots.


                       Slot 0                         Slot 1             Slot 2                       Slot 3
                 LD Instructions             LD Instructions
                                                                   XTYPE Instructions         XTYPE Instructions
                 ST Instructions             ST Instructions
                                                                   ALU32 Instructions         ALU32 Instructions
                 ALU32 Instructions          ALU32 Instructions
                                                                   J Instructions             J Instructions
                 MEMOP Instructions          Some J Instructions
                                                                   JR Instructions            CR Instructions
                 NV Instructions
                 SYSTEM Instructions
                 Some J Instructions



                      XTYPE Instructions (32/64 bit)                        J Instructions
                      Arithmetic, Logical, Bit Manipulation                 Jump/Call PC-relative
                      Multiply (Integer, Fractional, Complex)
                      Floating-point Operations
                                                                            JR Instructions
                      Permute / Vector Permute Operations
                      Predicate Operations                                  Jump/Call Register
                      Shift / Shift with Add/Sub/Logical
                      Vector Byte ALU                                       LD Instructions
                      Vector Halfword (ALU, Shift, Multiply)                Loads (8/16/32/64 bit)
                      Vector W ord (ALU, Shift)                             Deallocframe

                      ALU32 Instructions                                    ST Instructions
                      Arithmetic / Logical (32 bit)                         Stores (8/16/32/64 bit)
                      Vector Halfword                                       Allocfram e

                      CR Instructions                                       MEMOP Instructions
                      Control-Register Transfers                            Operation on memory (8/16/32 bit)
                      Hardware Loop Setup
                      Predicate Logicals & Reductions                       SYSTEM Instructions
                                                                            Prefetch
                      NV Instructions                                       Cache Maintenance
                      New-value Jumps                                       Bus Operations
                      New-value Stores


                Figure 3-1 Packet grouping combinations




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                              52
Hexagon V62 Programmer's Reference Manual                                                          Instructions



     3.3.4      Grouping constraints
                A small number of restrictions determines what constitutes a valid packet. The assembler
                ensures that all packets follow valid grouping rules. If a packet is executed which violates
                a grouping rule, the behavior is undefined. The following rules must be followed:

                     ï®   Dot-new conditional instructions (Section 6.1.4) must be grouped in a packet with
                         an instruction that generates dot-new predicates.
                     ï®   ST-class instructions can be placed in Slot 1. In this case Slot 0 normally must
                         contain a second ST-class instruction (Section 5.4).
                     ï®   J-class instructions can be placed in Slots 2 or 3. However, only certain
                         combinations of program flow instructions (J or JR) can be grouped together in a
                         packet (Section 7.7). Otherwise, at most one program flow instruction is allowed
                         in a packet. Some Jump and Compare-Jump instructions can execute on slots 0 or
                         1, excluding calls, such as the following:
                         ï²   Instructions of the form âPd=cmp.xx(); if(Pd.new)jump:hint <target>â
                         ï²   Instructions of the form âIf(Pd[.new]) jump[:hint] <target>â
                         ï²   The âjump<target>â instruction
                     ï®   JR-class instructions can be placed in Slot 2. However, when encoded in a duplex
                         jumpr R31 can be placed in Slot 0 (Section 10.3).

                     ï®   Restrictions exist which limit the instructions that can appear in a packet at the
                         setup or end of a hardware loop (Section 7.2.4).
                     ï®   A user control register transfer to the control register USR cannot be grouped with
                         a floating point instruction (Section 2.2.3).
                     ï®   The SYSTEM-class instructions include prefetch, cache operations, bus
                         operations, load locked, and store conditional instructions (Section 5.9). These
                         instructions have the following grouping rules:
                         ï²   brkpt, trap, pause, icinva, isync, and syncht are solo instructions. They
                             must not be grouped with other instructions in a packet.
                         ï²   memw_locked, memd_locked, l2fetch, and trace must execute on Slot 0.
                             They must be grouped only with ALU32 or (non-FP) XTYPE instructions.
                         ï²   dccleana, dcinva, dccleaninva, and dczeroa must execute on Slot 0. Slot
                             1 must be empty or an ALU32 instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         53
Hexagon V62 Programmer's Reference Manual                                                           Instructions



     3.3.5      Dependency constraints
                Instructions in a packet cannot write to the same destination register. The assembler
                automatically flags such packets as invalid. If the processor executes a packet with two
                writes to the same general register, an error exception is raised.

                If the processor executes a packet which performs multiple writes to the same predicate or
                control register, the behavior is undefined. Three special cases exist for this rule:

                     ï®   Conditional writes are allowed to target the same destination register only if at
                         most one of the writes is actually performed (Section 6.1.5).
                     ï®   The overflow flag in the status register has defined behavior when multiple
                         instructions write to it (Section 2.2.3). Note that instructions that write to the
                         entire user status register (for example, USR=R2) are not allowed to be grouped in
                         a packet with any instruction that writes to a bit in the user status register.
                     ï®   Multiple compare instructions are allowed to target the same predicate register in
                         order to perform a logical AND of the results (Section 6.1.3).


     3.3.6      Ordering constraints
                In assembly code, instructions can appear in a packet in any order (with the exception of
                dual jumps â Section 7.7). The assembler automatically encodes instructions in the packet
                in the proper order.

                In the binary encoding of a packet, the instructions must be ordered from Slot 3 down to
                Slot 0. If the packet contains less than four instructions, any unused slot is skipped â a
                NOP is unnecessary as the hardware handles the proper spacing of the instructions.

                In memory, instructions in a packet must appear in strictly decreasing slot order.
                Additionally, if an instruction can go in a higher-numbered slot, and that slot is empty,
                then it must be moved into the higher-numbered slot.

                For example, if a packet contains three instructions and Slot 1 is not used, the instructions
                should be encoded in the packet as follows:

                     ï®   Slot 3 instruction at lowest address
                     ï®   Slot 2 instruction follows Slot 3 instruction
                     ï®   Slot 0 instructions at the last (highest) address

                If a packet contains a single load or store instruction, that instruction must go in Slot 0,
                which is the highest address. As an example, a packet containing both LD and ALU32
                instructions must be ordered so the LD is in Slot 0 and the ALU32 in another slot.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         54
Hexagon V62 Programmer's Reference Manual                                                          Instructions



     3.3.7      Alignment constraints
                Packets have the following constraints on their placement or alignment in memory:
                    ï® Packets must be word-aligned (32-bit). If the processor executes an improperly
                        aligned packet, it will raise an error exception (Section 7.10).
                     ï®    Packets should not wrap the 4GB address space. If address wraparound occurs,
                          the processor behavior is undefined.

                No other core-based restrictions exist for code placement or alignment.

                If the processor branches to a packet which crosses a 16-byte address boundary, the
                resulting instruction fetch will stall for one cycle. Packets that are jump targets or loop
                body entries can be explicitly aligned to ensure this does not occur (Section 9.5.2).


       3.4      Instruction intrinsics
                To support efficient coding of the time-critical sections of a program (without resorting to
                assembly language), the C compilers support intrinsics which are used to directly express
                Hexagon processor instructions from within C code.

                The following example shows how an instruction intrinsic is used to express the XTYPE
                instruction âRdd = vminh(Rtt,Rss)â:
                    #include <hexagon_protos.h>

                    int main()
                    {
                        long long v1 = 0xFFFF0000FFFF0000LL;
                        long long v2 = 0x0000FFFF0000FFFFLL;
                        long long result;

                           // find the minimum for each half-word in 64-bit vector
                           result = Q6_P_vminh_PP(v1,v2);
                    }

                Intrinsics are provided for instructions in the following classes:

                     ï®    ALU32
                     ï®    XTYPE
                     ï®    CR (predicate operations only)
                     ï®    SYSTEM (dcfetch only)

                For more information on intrinsics see Chapter 11.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      55
Hexagon V62 Programmer's Reference Manual                                                           Instructions



       3.5      Compound instructions
                The Hexagon processor supports compound instructions, which encode pairs of
                commonly-used operations in a single instruction. For example, each of the following is a
                single compound instruction:
                    dealloc_return                              //   deallocate frame and return
                    R2 &= and(R1, R0)                           //   and and and
                    R7 = add(R4, sub(#15, R3))                  //   subtract and add
                    R3 = sub(#20, asl(R3, #16))                 //   shift and subtract
                    R5 = add(R2, mpyi(#8, R4))                  //   multiply and add
                    {                                           //   compare and jump
                       P0 = cmp.eq (R2, R5)
                       if (P0.new) jump:nt target
                    }
                    {                                           // register transfer and jump
                          R2 = #15
                          jump target
                    }

                Using compound instructions reduces code size and improves code performance.

                   NOTE      Compound instructions (with the exception of X-and-jump, as shown above)
                             have distinct assembly syntax from the instructions they are composed of.


       3.6      Duplex instructions
                To reduce code size the Hexagon processor supports duplex instructions, which encode
                pairs of commonly-used instructions in a 32-bit instruction container.

                Unlike compound instructions (Section 3.5), duplex instructions do not have distinctive
                syntax â in assembly code they appear identical to the instructions they are composed of.
                The assembler is responsible for recognizing when a pair of instructions can be encoded as
                a single duplex rather than a pair of regular instruction words.

                In order to fit two instructions into a single 32-bit word, duplexes are limited to a subset of
                the most common instructions (load, store, branch, ALU), and the most common register
                operands.

                For more information on duplexes, see Section 10.2 and Section 10.3.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       56
         4 Data Processing


                The Hexagon processor provides a rich set of operations for processing scalar and vector
                data.

                This chapter presents an overview of the operations provided by the following Hexagon
                processor instruction classes:

                    ï®   XTYPE â General-purpose data operations
                    ï®   ALU32 â Arithmetic/logical operations on 32-bit data

                   NOTE     For detailed descriptions of these instruction classes see Chapter 11.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   57
Hexagon V62 Programmer's Reference Manual                                                  Data Processing



       4.1      Data types
                The Hexagon processor provides operations for processing the following data types:

                     ï®   Fixed-point data
                     ï®   Floating-point data
                     ï®   Complex data
                     ï®   Vector data


     4.1.1      Fixed-point data
                The Hexagon processor provides operations to process 8-, 16-, 32-, or 64-bit fixed-point
                data. The data can be either integer or fractional, and in signed or unsigned format.


     4.1.2      Floating-point data
                The Hexagon processor provides operations to process 32-bit floating-point numbers. The
                numbers are stored in IEEE single-precision floating-point format.

                Per the IEEE standard, certain floating-point values are defined to represent positive or
                negative infinity, as well as "Not-a-Number" (NaN), which represents values that have no
                mathematical meaning.

                Floating-point numbers can be held in a general register.


     4.1.3      Complex data
                The Hexagon processor provides operations to process 32- or 64-bit complex data.

                Complex numbers include a signed real portion and a signed imaginary portion. Given
                two complex numbers (a+bi) and (c+di), the complex multiply operations computes both
                the real portion (ac-bd) and the imaginary portion (ad+bc) in a single instruction.

                Complex numbers can be packed in a general register or register pair. When packed, the
                imaginary portion occupies the most-significant portion of the register or register pair.


     4.1.4      Vector data
                The Hexagon processor provides operations to process 64-bit vector data.

                Vector data types pack multiple data items â bytes, halfwords, or words â into 64-bit
                registers. Vector data operations are common in video and image processing.

                Eight 8-bit bytes can be packed into a 64-bit register.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       58
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



                Figure 4-1 shows an example of a vector byte operation.


                                                                                          Rss


                                                                                          Rtt


                    Op        Op     Op        Op     Op        Op     Op        Op




                                                                                         Rdd

                Figure 4-1 Vector byte operation

                Four 16-bit halfword values can be packed in a single 64-bit register pair.

                Figure 4-2 shows an example of a vector halfword operation.


                                                                                          Rss


                                                                                          Rtt



                         Op               Op               Op               Op




                                                                                         Rdd

                Figure 4-2 Vector halfword operation

                Two 32-bit word values can be packed in a single 64-bit register pair.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     59
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



                Figure 4-3 shows an example of a vector word operation.


                                                                                           Rss


                                                                                           Rtt



                                 Op                                Op




                                                                                           Rdd

                Figure 4-3 Vector word operation



       4.2      Instruction options
                Some instructions support optional scaling, saturation, and rounding. There are no mode
                bits controlling these options â instead, they are explicitly specified as part of the
                instruction name. The options are described in this section.


     4.2.1      Fractional scaling
                In fractional data format, data is treated as fixed-point fractional values whose range is
                determined by the word length and radix point position.

                Fractional scaling is specified in an instruction by adding the :<<1 specifier. For
                example:
                    R3:2 = cmpy(R0,R1):<<1:sat

                When two fractional numbers are multiplied, the product must be scaled to restore the
                original fractional data format. The Hexagon processor allows fractional scaling of the
                product to be specified in the instruction for shifts of 0 and 1. A shift of 1 should be done
                for Q1.15 numbers, while a shift of 0 should be done for integer multiplication.


     4.2.2      Saturation
                Certain instructions are available in saturating form. If a saturating arithmetic instruction
                has a result which is smaller than the minimum value, then the result is set to the minimum
                value. Similarly, if the operation has a result which is greater than the maximum value,
                then the result is set to the maximum value.

                Saturation is specified in an instruction by adding the :sat specifier. For example:
                    R2 = abs(R1):sat




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       60
Hexagon V62 Programmer's Reference Manual                                                    Data Processing



                The OVF bit in the user status register (Section 2.2.3) is set whenever a saturating
                operation saturates to the maximum or minimum value. It remains set until explicitly
                cleared by a control register transfer to USR. For vector-type saturating operations, if any
                of the individual elements of the vector saturate, then OVF is set.


     4.2.3      Arithmetic rounding
                Certain signed multiply instructions support optional arithmetic rounding (also known as
                biased rounding). The arithmetic rounding operation takes a double precision fractional
                value and adds 0x8000 to the low 16-bits (least significant 16-bit halfword).

                Rounding is specified in an instruction by adding the :rnd specifier. For example:
                    R2 = mpy(R1.h,R2.h):rnd

                   NOTE      Arithmetic rounding can accumulate numerical errors, especially when the
                             number to be rounded is exactly 0.5. This happens most frequently when
                             dividing by 2 or averaging.


     4.2.4      Convergent rounding
                To address the problem of error accumulation in arithmetic rounding (Section 4.2.3), the
                Hexagon processor includes four instructions that support positive and negative averaging
                with a convergent rounding option.

                These instructions work as follows:

                 1. Compute (A+B) or (A-B) for AVG and NAVG respectively.
                 2. Based on the two least-significant bits of the result, add a rounding constant as
                    follows:
                     ï® If the two LSBs are 00, add 0

                     ï®   If the two LSBs are 01, add 0
                     ï®   If the two LSBs are 10, add 0
                     ï®   If the two LSBs are 11, add 1
                 3. Shift the result right by one bit.


     4.2.5      Scaling for divide and square-root
                On the Hexagon processor, floating point divide and square-root operations are
                implemented in software using library functions. To enable the efficient implementation of
                these operations, the processor supports special variants of the multiply-accumulate
                instruction. These are named scale FMA.

                Scale FMA supports optional scaling of the product generated by the floating-point fused
                multiply-add instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     61
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



                Scaling is specified in the instruction by adding the :scale specifier and a predicate
                register operand. For example:
                    R3 += sfmpy(R0,R1,P2):scale

                For single precision, the scaling factor is two raised to the power specified by the contents
                of the predicate register (which is treated as an 8-bit two's complement value). For double
                precision, the predicate register value is doubled before being used as a power of two.

                   NOTE      Scale FMA instructions should not be used outside of divide and square-root
                             library routines. No guarantee is provided that future versions of the Hexagon
                             processor will implement these instructions using the same semantics. Future
                             versions assume only that compatibility for scale FMA is limited to the needs
                             of divide and square-root library routines.


       4.3      XTYPE operations
                The XTYPE instruction class includes most of the data-processing operations performed
                by the Hexagon processor. These operations are categorized by their operation type:

                     ï®   ALU
                     ï®   Bit manipulation
                     ï®   Complex
                     ï®   Floating point
                     ï®   Multiply
                     ï®   Permute
                     ï®   Predicate
                     ï®   Shift


     4.3.1      ALU
                ALU operations modify 8-, 16-, 32-, and 64-bit data. These operations include:

                     ï®   Add and subtract with and without saturation
                     ï®   Add and subtract with accumulate
                     ï®   Absolute value
                     ï®   Logical operations
                     ï®   Min, max, negate instructions
                     ï®   Register transfers of 64-bit data
                     ï®   Word to doubleword sign extension
                     ï®   Comparisons

                For more information see Section 11.1.1 and Section 11.10.1.


80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      62
Hexagon V62 Programmer's Reference Manual                                                    Data Processing



     4.3.2      Bit manipulation
                Bit manipulation operations modify bit fields in a register or register pair. These
                operations include:

                     ï®   Bit field insert
                     ï®   Bit field signed and unsigned extract
                     ï®   Count leading and trailing bits
                     ï®   Compare bit masks
                     ï®   Set / Clear / Toggle bit
                     ï®   Test bit operation
                     ï®   Interleave/deinterleave bits
                     ï®   Bit reverse
                     ï®   Split bitfield
                     ï®   Masked parity and Linear Feedback shift
                     ï®   Table index formation

                For more information see Section 11.10.2.


     4.3.3      Complex
                Complex operations manipulate complex numbers. These operations include:

                     ï®   Complex add and subtract
                     ï®   Complex multiply with optional round and pack
                     ï®   Vector complex multiply
                     ï®   Vector complex conjugate
                     ï®   Vector complex rotate
                     ï®   Vector reduce complex multiply real or imaginary

                For more information see Section 11.10.3.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    63
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



     4.3.4      Floating point
                Floating-point operations manipulate single-precision floating point numbers. These
                operations include:

                     ï®   Addition and subtraction
                     ï®   Multiplication (with optional scaling)
                     ï®   Min/max/compare
                     ï®   Format conversion

                The Hexagon floating-point operations are defined to support the IEEE floating-point
                standard. However, certain IEEE-required operations â such as divide and square root â
                are not supported directly. Instead, special instructions are defined to support the
                implementation of the required operations as library routines. These instructions include:

                     ï®   A special version of the fused multiply-add instruction (designed specifically for
                         use in library routines)
                     ï®   Reciprocal/square root approximations (which compute the approximate initial
                         values used in reciprocal and reciprocal-square-root routines)
                     ï®   Extreme value assistance (which adjusts input values if they cannot produce
                         correct results using convergence algorithms)

                For more information see Section 11.10.4.

                   NOTE      The special floating-point instructions are not intended for use directly in user
                             code â they should be used only in the floating point library.

                Format conversion

                The floating-point conversion instructions sfmake and dfmake convert an unsigned 10-bit
                immediate value into the corresponding floating-point value.

                The immediate value must be encoded so bits [5:0] contain the significand, and bits [9:6]
                the exponent. The exponent value is added to the initial exponent value (bias - 6).

                For example, to generate the single-precision floating point value 2.0, bits [5:0] must be
                set to 0, and bits [9:6] set to 7. Performing sfmake on this immediate value yields the
                floating point value 0x40000000, which is 2.0.

                   NOTE      The conversion instructions are designed to handle common floating point
                             values, including most integers and many basic fractions (1/2, 3/4, etc.).

                Rounding

                The Hexagon user status register (Section 2.2.3) includes the FPRND field, which is used
                to specify the IEEE-defined floating-point rounding mode.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        64
Hexagon V62 Programmer's Reference Manual                                                    Data Processing



                Exceptions

                The Hexagon user status register (Section 2.2.3) includes five status fields, which work as
                sticky flags for the five IEEE-defined exception conditions: inexact, overflow, underflow,
                divide by zero, and invalid. A sticky flag is set when the corresponding exception occurs,
                and remains set until explicitly cleared.

                The user status register also includes five mode fields which are used to specify whether
                an operating-system trap should be performed if one of the floating-point exceptions
                occur. For every instruction packet containing a floating-point operation, if a floating-
                point sticky flag and the corresponding trap-enable bit are both set, then a floating-point
                trap is generated. After the packet commits, the Hexagon processor then automatically
                traps to the operating system.

                   NOTE     Non-floating-point instructions never generate a floating-point trap,
                            regardless of the state of the sticky flag and trap-enable bits.


     4.3.5      Multiply
                Multiply operations support fixed-point multiplication, including both single- and double-
                precision multiplication, and polynomial multiplication.

                Single precision

                In single-precision arithmetic a 16-bit value is multiplied by another 16-bit value. These
                operands can come from the high portion or low portion of any register. Depending on the
                instruction, the result of the 16 ï´ 16 operation can optionally be accumulated, saturated,
                rounded, or shifted left by 0-1 bits.

                The instruction set supports operations on signed ï´ signed, unsigned ï´ unsigned, and
                signed ï´ unsigned data.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     65
Hexagon V62 Programmer's Reference Manual                                                          Data Processing



                Table 4-1 summarizes the options available for 16 ï´ 16 single precision multiplications.
                The symbols used in the table are as follows:

                    ï®   SS â Perform signed ï´ signed multiply
                    ï®   UU â Perform unsigned ï´ unsigned multiply
                    ï®   SU â Perform signed ï´ unsigned multiply
                    ï®   A+ â Result added to accumulator
                    ï®   A- â Result subtracted from accumulator
                    ï®   0 â Result not added to accumulator

                Table 4-1     Single-precision multiply options
                   Multiply       Result       Sign       Accumulate       Sat         Rnd         Scale
                    16 ï´ 16        32           SS            A+, A-       Yes          No          0-1
                    16 ï´ 16        32           SS              0          Yes         Yes          0-1
                    16 ï´ 16        64           SS            A+, A-        No          No          0-1
                    16 ï´ 16        64           SS              0           No         Yes          0-1
                    16 ï´ 16        32           UU          A+, A-, 0       No          No          0-1
                    16 ï´ 16        64           UU          A+, A-, 0       No          No          0-1
                    16 ï´ 16        32           SU            A+, 0        Yes          No          0-1


                Double precision

                Double precision instructions are available for both 32 ï´ 32 and 32 ï´ 16 multiplication:

                    ï®   For 32 ï´ 32 multiplication the result can be either 64 or 32 bits. The 32-bit result
                        can be either the high or low portion of the 64-bit product.
                    ï®   For 32 ï´ 16 multiplication the result is always taken as the upper 32 bits.

                The operands can be either signed or unsigned.

                Table 4-2 summarizes the options available in double precision multiply.

                Table 4-2     Double precision multiply options
                   Multiply       Result         Sign        Accumulate          Sat         Rnd       Scale
                   32 ï´ï 32          64         SS, UU          A+, A-, 0         No          No            0

                   32 ï´ï 32      32 (upper)     SS, UU               0            No          Yes           0

                   32 ï´ï 32       32 (low)      SS, UU            A+, 0           No          No            0

                   32 ï´ï 16      32 (upper)     SS, UU            A+, 0           Yes         Yes          0-1

                   32 ï´ï 32      32 (upper)       SU                 0            No          No            0


                Polynomial

                Polynomial multiply instructions are available for both words and vector halfwords.



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           66
Hexagon V62 Programmer's Reference Manual                                                   Data Processing



                These instructions are useful for many algorithms including scramble code generation,
                cryptographic algorithms, convolutional, and Reed Solomon code.

                For more information on multiply operations, see Section 11.10.5.


     4.3.6      Permute
                Permute operations perform various operations on vector data, including arithmetic,
                format conversion, and rearrangement of vector elements. Many types of conversions are
                supported:

                    ï®   Swizzle bytes
                    ï®   Vector shuffle
                    ï®   Vector align
                    ï®   Vector saturate and pack
                    ï®   Vector splat bytes
                    ï®   Vector splice
                    ï®   Vector sign extend halfwords
                    ï®   Vector zero extend bytes
                    ï®   Vector zero extend halfwords
                    ï®   Scalar saturate to byte, halfword, word
                    ï®   Vector pack high and low halfwords
                    ï®   Vector round and pack
                    ï®   Vector splat halfwords

                For more information, see Section 11.1.2 and Section 11.10.6.


     4.3.7      Predicate
                Predicate operations modify predicate source data. The categories of instructions available
                include:

                    ï®   Vector mask generation
                    ï®   Predicate transfers
                    ï®   Viterbi packing

                For more information, see Section 11.1.3 and Section 11.10.7.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    67
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



     4.3.8      Shift
                Scalar shift operations perform a variety of 32 and 64-bit shifts followed by an optional
                add/sub or logical operation. Figure 4-4 shows the general operation.


                                                                                              Rss


                                                                                             # / Rt

                                                                                Shift
                                                                               amount


                                                  64-bit Shifter




                                            64-bit Add/Sub/Logical




                                                                                           Rxx


                Figure 4-4 64-bit shift and add/sub/logical

                Four shift types are supported:

                     ï®   ASR â Arithmetic shift right
                     ï®   ASL â Arithmetic shift left
                     ï®   LSR â Logical shift right
                     ï®   LSL â Logical shift left

                In register-based shifts, the Rt register is a signed twoâs-complement number. If this value
                is positive, then the instruction opcode tells the direction of shift (right or left). If this
                value is negative, then the shift direction indicated by the opcode is reversed.

                When arithmetic right shifts are performed, the sign bit is shifted in, whereas logical right
                shifts shift in zeros. Left shifts always shift in zeros.

                Some shifts are available with saturation and rounding options.

                For more information see Section 11.10.8.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      68
Hexagon V62 Programmer's Reference Manual                                                  Data Processing



       4.4      ALU32 operations
                The ALU32 instruction class includes general arithmetic/logical operations on 32-bit data:

                    ï®   Add, subtract, negate without saturation on 32-bit data
                    ï®   Logical operations such as AND, OR, XOR, AND with immediate, and OR with
                        immediate
                    ï®   Scalar 32-bit compares
                    ï®   Combine halfwords, combine words, combine with immediates, shift halfwords,
                        and Mux
                    ï®   Conditional add, combine, logical, subtract, and transfer.
                    ï®   NOP
                    ï®   Sign and zero-extend bytes and halfwords
                    ï®   Transfer immediates and registers
                    ï®   Vector add, subtract, and average halfwords

                For more information see Section 11.1.

                   NOTE     ALU32 instructions can be executed on any slot (Section 3.3.3).

                            Chapter 6 describes the conditional execution and compare instructions.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  69
Hexagon V62 Programmer's Reference Manual                                                  Data Processing



       4.5      Vector operations
                Vector operations support arithmetic operations on vectors of bytes, halfwords, and words.

                The vector operations belong to the XTYPE instruction class (except for vector add,
                subtract, and average halfwords, which are ALU32).

                Vector byte operations

                The vector byte operations process packed vectors of signed or unsigned bytes. They
                include the following operations:

                    ï®   Vector add and subtract signed or unsigned bytes
                    ï®   Vector min and max signed or unsigned bytes
                    ï®   Vector compare signed or unsigned bytes
                    ï®   Vector average unsigned bytes
                    ï®   Vector reduce add unsigned bytes
                    ï®   Vector sum of absolute differences unsigned bytes

                Vector halfword operations

                The vector halfword operations process packed 16-bit halfwords. They include the
                following operations:

                    ï®   Vector add and subtract halfwords
                    ï®   Vector average halfwords
                    ï®   Vector compare halfwords
                    ï®   Vector min and max halfwords
                    ï®   Vector shift halfwords
                    ï®   Vector dual multiply
                    ï®   Vector dual multiply with round and pack
                    ï®   Vector multiply even halfwords with optional round and pack
                    ï®   Vector multiply halfwords
                    ï®   Vector reduce multiply halfwords




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   70
Hexagon V62 Programmer's Reference Manual                                                        Data Processing



                For example, Figure 4-5 shows the operation of the vector arithmetic shift right halfword
                (vasrh) instruction. In this instruction, each 16-bit half-word is shifted right by the same
                amount which is specified in a register or with an immediate value. Because the shift is
                arithmetic, the bits shifted in are copies of the sign bit.


                                                                               Shift Amount     Rt / #u4


                                  lost             lost             lost                 lost   Rss




                  s/z ext                s/z ext          s/z ext          s/z ext              Rdd

                Figure 4-5 Vector halfword shift right

                Vector word operations

                The vector word operations process packed vectors of two words. They include the
                following operations:

                      ï®     Vector add and subtract words
                      ï®     Vector average words
                      ï®     Vector compare words
                      ï®     Vector min and max words
                      ï®     Vector shift words with optional truncate and pack

                For more information on vector operations see Section 11.1.1 and Section 11.10.1.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     71
Hexagon V62 Programmer's Reference Manual                                                             Data Processing



       4.6      CR operations
                The CR instruction class includes operations that access the control registers (Section 2.2).

                Table 4-3 lists the instructions that access the control registers.

                Table 4-3     Control register transfer instructions
                            Syntax                                         Operation
                Rd = Cs                         Move control register to / from a general register.
                Cd = Rs
                                                NOTE - PC is not a valid destination register.
                Rdd = Css                       Move control register pair to / from a general register pair.
                Cdd = Rss
                                                NOTE - PC is not a valid destination register.


                   NOTE      In register-pair transfers, control registers must be specified using their
                             numeric alias names â see Section 2.2 for details.

                For more information see Section 11.2.


       4.7      Compound operations
                The instruction set includes a number of instructions which perform multiple logical or
                arithmetic operations in a single instruction. They include the following operations:

                     ï®   And/Or with inverted input
                     ï®   Compound logical register
                     ï®   Compound logical predicate
                     ï®   Compound add-subtract with immediates
                     ï®   Compound shift-operation with immediates (arithmetic or logical)
                     ï®   Multiply-add with immediates

                For more information see Section 11.10.1.


       4.8      Special operations
                The instruction set includes a number of special-purpose instructions to support specific
                applications:

                     ï®   H.264 CABAC processing
                     ï®   IP internet checksum
                     ï®   Software-defined radio




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            72
Hexagon V62 Programmer's Reference Manual                                                    Data Processing



     4.8.1      H.264 CABAC processing
                H.264/AVC is adopted in a diverse range of multimedia applications:

                     ï®       HD-DVDs
                     ï®       HDTV broadcasting
                     ï®       Internet video streaming

                Context Adaptive Binary Arithmetic Coding (CABAC) is one of the two alternative
                entropy coding methods specified in the H.264 main profile. CABAC offers superior
                coding efficiency at the expense of greater computational complexity. The Hexagon
                processor includes a dedicated instruction (decbin) to support CABAC decoding.

                Binary arithmetic coding is based on the principle of recursive interval subdivision, and its
                state is characterized by two quantities:

                     ï®       The current interval range
                     ï®       The current offset in the current code interval

                The offset is read from the encoded bit stream. When decoding a bin, the interval range is
                subdivided in two intervals based on the estimation of the probability pLPS of LPS: one
                interval with width of rLPS = range x pLPS, and another with width of rMPS = range x
                pMPS = range -rLPS, where LPS stands for Least Probable Symbol, and MPS for Most
                Probable Symbol.

                Depending on which subinterval the offset falls into, the decoder decides whether the bin
                is decoded as MPS or LPS, after which the two quantities are iteratively updated, as shown
                in Figure 4-1.


                             MPS occurs                     LPS occurs


                                            rLPS                         rLPS
                         range




                                                        range




                                            rMPS                         rMPS
                                 offset




                                                                offset




                         rangeNew = rMPS               rangeNew = rLPS
                         offsetNew = offset            offsetNew = offset-rMPS




                Figure 4-1                Arithmetic decoding for one bin




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      73
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



    4.8.1.1     CABAC implementation
                In H.264 range is a 9-bit quantity, and offset is 9-bits in regular mode and 10-bits in bypass
                mode during the whole decoding process. The calculation of rLPS is approximated by a
                64Ã4 table of 256 bytes, where the range and the context state (selected for the bin to be
                decoded) are used to address the lookup table. To maintain the precision of the whole
                decoding process, the new range must be renormalized to ensure that the most significant
                bit is always 1, and that the offset is synchronously refilled from the bit stream.

                To simplify the renormalization/refilling process, the decoding scheme shown in
                Figure 4-2 was created to significantly reduce the frequency of renormalization and
                refilling bits from the bit-stream, while also being suitable for DSP implementation.


                        range: 32 bit register     18=29-bitpos
                            0000 0000 0001 xxxx xxxx 0000 0000 0000
                                bitpos=11         9         12=23-bitpos
                        offset: 32 bit register
                            0000 0000 000x xxxx xxxx xxxx xxxx xxxx
                                                  Decode Decision
                                                (ctxIdx, range, offset)


                                      bitpos=Count_leading_zeros(range)
                        rLPS=lutLPS[ctxIdx->state][(range>>(29-bitpos))&3]<<(23-bitpos)
                                              rMPS=range-rLPS


                                   Yes             offset >= rMPS                 No


                     bin = !ctxIdx->valMPS
                                                                            bin = ctxIdx->valMPS
                          range = rLPS
                                                                                range = rMPS
                      offset = offset - rMPS


                        ctxIdx->state == 0            Yes


                                       ctxIdx->valMPS=!ctxIdx->valMPS
                                No

                         ctxIdx->state =                                       ctxIdx->state =
                  TransIndexLPS(ctxIdx->state)                         TransIndexMPS(ctxIdx->state)



                                                  Renormalization1
                                                   (range, offset)

                                                         Done

                Figure 4-2       CABAC decoding engine for regular bin



80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      74
Hexagon V62 Programmer's Reference Manual                                                Data Processing



                By using the decbin instruction, the Hexagon processor is able to decode one regular bin
                in 2 cycles (not counting the bin refilling process).

                For more information on the decbin instruction see Section 11.10.6.

                For example:
                    Rdd = decbin(Rss,Rtt)

                    INPUT: Rss and Rtt register pairs as:
                    Rtt.w1[5:0] = state
                    Rtt.w1[8] = valMPS
                    Rtt.w0[4:0] = bitpos
                    Rss.w0 = range
                    Rss.w1 = offset

                    OUTPUT: Rdd register pair is packed as
                    Rdd.w0[5:0] = state
                    Rdd.w0[8] = valMPS
                    Rdd.w0[31:23] = range
                    Rdd.w0[22:16] = '0'
                    Rdd.w1 = offset (normalized)

                    OUTPUT: P0
                    P0 = (bin)


    4.8.1.2     Code example
                    H264CabacGetBinNC:
                    /****************************************************************
                    * Non-conventional call:
                    * Input: R1:0 = offset : range , R2 = dep,     R3 = ctxIdx,
                    * R4 = (*ctxIdx), R5 = bitpos
                    *
                    * Return:
                    *       R1: 0 - offset : range
                    *       P0 - (bin)
                    *****************************************************************/

                    // Cycle #1
                    { R1:0= decbin(R1:0,R5:4)           // decoding one bin
                      R6 = asl(R22,R5)                  // where R22 = 0x100
                    }

                    // Cycle #2
                    { memb(R3) = R0            // save context to *ctxIdx
                       R1:0 = vlsrw(R1:0,R5)   // re-align range and offset
                       P1 = cmp.gtu(R6,R1)     // need refill? i.e., P1= (range<0x100)
                       IF (!P1.new) jumpr:t LR // return
                    }
                    RENORM_REFILL:
                    ...




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                 75
Hexagon V62 Programmer's Reference Manual                                                     Data Processing



     4.8.2      IP internet checksum
                The key features of the internet checksum1 include:

                ï®     The checksum can be summed in any order
                ï®     Carries may be accumulated using an accumulator larger than size being added, and
                      added back in at any time

                Using standard data-processing instructions, the internet checksum can be computed at 8
                bytes per cycle in the main loop, by loading words and accumulating into doublewords.
                After the loop, the upper word is added to the lower word; then the upper halfword is
                added to the lower halfword, and any carries are added back in.

                The Hexagon processor supports a dedicated instruction (vradduh) which enables the
                internet checksum to be computed at a rate of 16 bytes per cycle.

                The vradduh instruction accepts the halfwords of the two input vectors, adds them all
                together, and places the result in a 32-bit destination register. This operation can be used
                for both computing the sum of 16 bytes of input while preserving the carries, and also
                accumulating carries at the end of computation.

                For more information on the vradduh instruction see Section 11.10.1.

                     NOTE     This operation utilizes the maximum load bandwidth available in the
                              Hexagon processor.




                1   See RFC 1071 (http://www.faqs.org/rfcs/rfc1071.html)



80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    76
Hexagon V62 Programmer's Reference Manual                                               Data Processing



    4.8.2.1     Code example
                   .text
                   .global fast_ip_check
                   // Assumes data is 8-byte aligned
                   // Assumes data is padded at least 16 bytes afterwords with 0's.
                   // input R0 points to data
                   // input R1 is length of data
                   // returns IP checksum in R0

                   fast_ip_check:
                   {
                      R1 = lsr(R1,#4)          // 16-byte chunks, rounded down, +1
                      R9:8 = combine(#0,#0)
                      R3:2 = combine(#0,#0)
                   }
                   {
                      loop0(1f,R1)
                      R7:6 = memd(R0+#8)
                      R5:4 = memd(R0++#16)
                   }
                   .falign
                   1:
                   {
                      R7:6 = memd(R0+#8)
                      R5:4 = memd(R0++#16)
                      R2 = vradduh(R5:4,R7:6)    // accumulate 8 halfwords
                      R8 = vradduh(R3:2,R9:8)    // accumulate carries
                   }:endloop0
                   // drain pipeline
                   {
                      R2 = vradduh(R5:4,R7:6)
                      R8 = vradduh(R3:2,R9:8)
                      R5:4 = combine(#0,#0)
                   }
                   {
                      R8 = vradduh(R3:2,R9:8)
                      R1 = #0
                   }
                   // may have some carries to add back in
                   {
                      R0 = vradduh(R5:4,R9:8)
                   }
                   // possible for one more to pop out
                   {
                      R0 = vradduh(R5:4,R1:0)
                   }
                   {
                      R0 = not(R0)
                      jumpr LR
                   }




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               77
Hexagon V62 Programmer's Reference Manual                                                                         Data Processing



     4.8.3       Software-defined radio
                 The Hexagon processor includes six special-purpose instructions which support the
                 implementation of software-defined radio. The instructions greatly accelerate the
                 following algorithms:

                       ï®   Rake despreading
                       ï®   Scramble code generation
                       ï®   Polynomial field processing


    4.8.3.1      Rake despreading
                 A fundamental operation in despreading is the PN multiply operation. In this operation the
                 received complex chips are compared against a pseudo-random sequence of QAM
                 constellation points and accumulated.

                 Figure 4-3 shows the vrcrotate instruction, which is used to perform this operation. The
                 products are summed to form a soft 32-bit complex symbol. The instruction has both
                 accumulating and non-accumulating versions.


                Rxx += vrcrotate(Rss,Rt,#0)



                                                                                         Rt




                           1 j -1 -j           1 j -1 -j         1 j -1 -j             1 j -1 -j

                             mux                 mux               mux                   mux




                           Im3       Re3        Im2        Re2    Im1        Re1       Im0       Re0         Rs




                                 *                *                 *                        *

                                       +                                           +


                                           I                                   R                       Rxx


                 Figure 4-3            Vector reduce complex rotate



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                      78
Hexagon V62 Programmer's Reference Manual                                                 Data Processing



                For more information on the vrcrotate instruction, see Section 11.10.3.

                   NOTE     Using this instruction the Hexagon processor can process 5.3 chips per cycle,
                            and a 12-finger WCDMA user requires only 15 MHz.


    4.8.3.2     Polynomial operations
                The polynomial multiply instructions support the following operations:

                    ï®   Scramble code generation (at a rate of 8 symbols per cycle for WCDMA)
                    ï®   Cryptographic algorithms (such as Elliptic Curve)
                    ï®   CRC checks (at a rate of 21bits per cycle)
                    ï®   Convolutional encoding
                    ï®   Reed Solomon codes




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  79
Hexagon V62 Programmer's Reference Manual                                                    Data Processing



                The four versions of this instruction support 32 x 32 and vector 16 x 16 multiplication both
                with and without accumulation, as shown in Figure 4-4.

                For more information on the pmpy instructions see Section 11.10.5.

                                                                  Rxx += vpmpyh(Rs,Rt)
                  Rxx += pmpyw(Rs,Rt)


                                                                      Rs

                      Rs

                                                                      Rt

                      Rt
                                                                    16x16
                                                                   Carryless                        16x16
                                                                                                   Carryless
                               32x32
                              Carryless
                                                                  Polynomial
                                                                     Mpy         *           *    Polynomial
                                                                                                     Mpy
                             Polynomial
                                mpy       *
                                                                                XOR        XOR

                                   XOR




                                 Rxx                                           Rxx

                Figure 4-4        Polynomial multiply




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      80
         5 Memory


                The Hexagon processor features a load/store architecture, where numeric and logical
                instructions operate on registers. Explicit load instructions move operands from memory
                to registers, while store instructions move operands from registers to memory. A small
                number of instructions (known as mem-ops) perform numeric and logical operations
                directly on memory.

                The address space is unified: all accesses target the same linear address space, which
                contains both instructions and data.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    81
Hexagon V62 Programmer's Reference Manual                                                              Memory



       5.1      Memory model
                This section describes the memory model for the Hexagon processor.


     5.1.1      Address space
                The Hexagon processor has a 32-bit byte-addressable memory address space. The entire
                4G linear address space is addressable by the user application. A virtual-to-physical
                address translation mechanism is provided.


     5.1.2      Byte order
                The Hexagon processor is a little-endian machine: the lowest address byte in memory is
                held in the least significant byte of a register, as shown in Figure 5-1.


                Address    Contents

                     0        A                 Register Contents
                     1        B
                                                            31                   0
                     2        C
                                                                                     Load byte
                                                                 -   -   -   A
                     3        D

                     4        E                                  -   -   B   A       Load Halfword

                     5        F
                                                                 D   C   B   A       Load word
                     6        G        63

                     7        H             H   G   F   E        D   C   B   A       Load doubleword


                Figure 5-1 Hexagon processor byte order


     5.1.3      Alignment
                Even though the Hexagon processor memory is byte-addressable, instructions and data
                must be aligned in memory on specific address boundaries:
                    ï® Instructions and instruction packets must be 32-bit aligned

                    ï®    Data must be aligned to its native access size.

                Any unaligned memory access will cause a memory-alignment exception.

                The permute instructions (Section 4.3.6) can be used in applications that need to reference
                unaligned vector data. The loads and stores still must be memory-aligned; however, the
                permute instructions enable the data to be easily rearranged in registers.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      82
Hexagon V62 Programmer's Reference Manual                                                                            Memory



                  Table 5-1 summarizes the alignment restrictions.
                  .


                  Table 5-1         Memory alignment restrictions
                           Data Type              Size (bits)       Exception When
                      Byte                             8         Never
                      Unsigned byte
                      Halfword                        16         LSB[0] != 0 1
                      Unsigned halfword
                      Word                            32         LSB[1:0] != 00
                      Unsigned word
                      Doubleword                      64         LSB[2:0] != 000
                      Instruction                     32         LSB[1:0] != 00
                      Instruction packet
                  1    LSB = Least significant bits of address




       5.2        Memory loads
                  Memory can be loaded in byte, halfword, word, or doubleword sizes. The data types
                  supported are signed or unsigned. The syntax used is memXX, where XX denotes the data
                  type.

                  Table 5-2 summarizes the supported load instructions.

Table 5-2       Load instructions
                                        Source        Destination
                                                         Size                Data
            Syntax                        Size                                                       Comment
                                                                          Placement
                                         (bits)         (bits)
Rd = memub(Rs)                             8                32            Low 8 bits     Zero-extend 8 to 32 bits
Rd = memb(Rs)                              8                32            Low 8 bits     Sign-extend 8 to 32 bits
Rd = memuh(Rs)                             16               32            Low 16 bits    Zero-extend 16 to 32 bits
Rd = memh(Rs)                              16               32            Low 16 bits    Sign-extend 16 to 32 bits
Rd = memubh(Rs)                            16               32           Bytes 0 and 2   Bytes 1 and 3 zeroed 1
Rd = membh(Rs)                             16               32           Bytes 0 and 2   Bytes 1 and 3 sign-extended
Rd = memw(Rs)                              32               32            All 32 bits    Load word
Rdd = memubh(Rs)                           32               64           Bytes 0,2,4,6   Bytes 1,3,5,7 zeroed
Rdd = membh(Rs)                            32               64           Bytes 0,2,4,6   Bytes 1,3,5,7 sign-extended
Rdd = memd(Rs)                             64               64            All 64 bits    Load doubleword
Ryy = memh_fifo(Rs)                        16               64           High 16 bits    Shift vector and load halfword
deallocframe                               64               64            All 64 bits    See Chapter 8
dealloc_return                             64               64            All 64 bits    See Chapter 8




80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                               83
Hexagon V62 Programmer's Reference Manual                                                                                   Memory



1   The memubh and membh instructions load contiguous bytes from memory (either 2 or 4 bytes) and unpack these bytes into a
    vector of halfwords. The instructions are useful when bytes are used as input into halfword vector operations, which is common in
    video and image processing..


                         NOTE        The memory load instructions belong to instruction class LD, and can execute
                                     only in Slots 0 or 1.


          5.3        Memory stores
                     Memory can be stored in byte, halfword, word, or doubleword sizes. The syntax used is
                     memX, where X denotes the data type.

                     Table 5-3 summarizes the supported store instructions.

                     Table 5-3        Store instructions
                                                          Source         Destination
                                  Syntax                    Size            Size                       Comment
                                                           (bits)          (bits)
                      memb(Rs) = Rt                          32                8          Store byte (bits 7:0)
                      memb(Rs) = #s8                          8                8          Store byte
                      memh(Rs) = Rt                          32               16          Store lower half (bits 15:0)
                      memh(Rs) = Rt.H                        32               16          Store upper half (bits 31:16)
                      memh(Rs) = #s8                          8               16          Sign-extend 8 to 16 bits
                      memw(Rs) = Rt                          32               32          Store word
                      memw(Rs) = #s8                          8               32          Sign-extend 8 to 32 bits
                      memd(Rs) = Rtt                         64               64          Store doubleword
                      allocframe(#u11)                       64               64          See Chapter 8


                         NOTE        The memory store instructions belong to instruction class ST, and can execute
                                     only in slot 0 or â when part of a dual store (Section 5.4) â slot 1.


          5.4        Dual stores
                     Two memory store instructions can appear in the same instruction packet. The resulting
                     operation is considered a dual store. For example:
                          {
                          memw(R5) = R2                  // dual store
                          memh(R6) = R3
                          }

                     Unlike most packetized operations, dual stores are not executed in parallel (Section 3.3.1).
                     Instead, the store instruction in Slot 1 effectively executes first, followed by the store
                     instruction in Slot 0.




80-N2040-36 B                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                      84
Hexagon V62 Programmer's Reference Manual                                                               Memory



                   NOTE     The store instructions in a dual store must belong to instruction class ST
                            (Section 5.3), and can execute only in Slots 0 and 1.


       5.5      New-value stores
                A memory store instruction can store a register that is assigned a new value in the same
                instruction packet (Section 3.3). This feature is expressed in assembly language by
                appending the suffix â.newâ to the source register. For example:
                    {
                    R2 = memh(R4+#8)               // load halfword
                    memw(R5) = R2.new              // store newly-loaded value
                    }

                New-value store instructions have the following restrictions:

                    ï®   If an instruction uses auto-increment or absolute-set addressing mode
                        (Section 5.7), its address register cannot be used as the new-value register.
                    ï®   If an instruction produces a 64-bit result, its result registers cannot be used as the
                        new-value register.
                    ï®   If the instruction that sets a new-value register is conditional (Section 6.1.2), it
                        must always be executed.

                   NOTE     The new-value store instructions belong to instruction class NV, and can
                            execute only in Slot 0.


       5.6      Mem-ops
                Mem-ops perform basic arithmetic, logical, and bit operations directly on memory
                operands, without the need for a separate load or store. Mem-ops can be performed on
                byte, halfword, or word sizes. Table 5-4 lists the mem-ops.

                Table 5-4    Mem-ops
                                  Syntax                                  Operation
                memXX(Rs+#u6) [+-|&] = Rt                    Arithmetic/logical on memory
                memXX(Rs+#u6) [+-] = #u5                     Arithmetic on memory
                memXX(Rs+#u6) = clrbit(#u5)                  Clear bit in memory
                memXX(Rs+#u6) = setbit(#u5)                  Set bit in memory


                   NOTE     The mem-op instructions belong to instruction class MEMOP, and can
                            execute only in Slot 0.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          85
Hexagon V62 Programmer's Reference Manual                                                                Memory



          5.7         Addressing modes
                      Table 5-5 summarizes the supported addressing modes.

Table 5-5        Addressing modes

                  Mode                                     Syntax                        Operation 1
Absolute                                  memXX(##address)                    EA = address
Absolute-set                              memXX(Re=##address)                 EA = address
                                                                              Re = address
Absolute with register offset             memXX(Ru<<#u2+##U32)                EA = imm + (Ru << #u2)
Global-pointer-relative                   memXX(GP+#immediate)                EA = GP + immediate
                                          memXX(#immediate)
Indirect                                  memXX(Rs)                           EA = Rs
Indirect with offset                      memXX(Rs+#s11)                      EA = Rs + imm
Indirect with register offset             memXX(Rs+Ru<<#u2)                   EA = Rs + (Ru << #u2)
Indirect                                  memXX(Rx++#s4)                      EA = Rx;
with auto-increment immediate                                                 Rx += (imm)

Indirect                                  memXX(Rx++Mu)                       EA = Rx;
with auto-increment register                                                  Rx += Mu

Circular                                  memXX(Rx++#s4:circ(Mu))             EA = Rx;
with auto-increment immediate                                                 Rx = circ_add(Rx,imm,Mu)

Circular                                  memXX(Rx++I:circ(Mu))               EA = Rx;
with auto-increment register                                                  Rx = circ_add(Rx,I,Mu)

Bit-reversed                              memXX(Rx++Mu:brev)                  EA = Rx.H + bit_reverse(Rx.L)
with auto-increment register                                                  Rx += Mu
1   EA (Effective Address) is equivalent to VA (Virtual Address).



        5.7.1         Absolute
                      The absolute addressing mode uses a 32-bit constant value as the effective memory
                      address. For example:
                           R2 = memw(##100000)                 // load R2 with word from addr 100000
                           memw(##200000) = R4                 // store R4 to word at addr 200000



        5.7.2         Absolute-set
                      The absolute-set addressing mode assigns a 32-bit constant value to the specified general
                      register, then uses the assigned value as the effective memory address. For example:
                           R2 = memw(R1=##400000)                   // load R2 with word from addr 400000
                                                                    // and load R1 with value 400000
                           memw(R3=##600000) = R4                   // store R4 to word at addr 600000
                                                                    // and load R3 with value 600000



80-N2040-36 B                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                 86
Hexagon V62 Programmer's Reference Manual                                                              Memory



     5.7.3      Absolute with register offset
                The absolute with register offset addressing mode performs an arithmetic left shift of a 32-
                bit general register value by the amount specified in a 2-bit unsigned immediate value, and
                then adds the shifted result to an unsigned 32-bit constant value to create the 32-bit
                effective memory address. For example:
                    R2 = memh(R3 << #3 + ##100000) // load R2 with signed halfword
                                                   // from addr [100000 + (R3 << 3)]

                The 32-bit constant value is the base address, and the shifted result is the byte offset.

                   NOTE      This addressing mode is useful for loading an element from a global table,
                             where the immediate value is the name of the table, and the register holds the
                             index of the element.


     5.7.4      Global pointer relative
                The global pointer relative addressing mode adds an unsigned offset value to the Hexagon
                processor global data pointer GP to create the 32-bit effective memory address. This
                addressing mode is used to access global and static data in C.

                Global pointer relative addresses can be expressed two ways in assembly language:

                     ï®   By explicitly adding an unsigned offset value to register GP
                     ï®   By specifying only an immediate value as the instruction operand

                For example:
                    R2 = memh(GP+#100)             // load R2 with signed halfword
                                                   // from [GP + 100 bytes]

                    R3 = memh(#2000)               // load R3 with signed halfword
                                                   // from [GP + #2000 - _SDA_BASE]

                Specifying only an immediate value causes the assembler and linker to automatically
                subtract the value of the special symbol _SDA_BASE_ from the immediate value, and use
                the result as the effective offset from GP.

                The global data pointer is programmed in the GDP field of register GP (Section 2.2.8).
                This field contains an unsigned 26-bit value which specifies the most significant 26 bits of
                the 32-bit global data pointer. (The least significant 6 bits of the pointer are defined to
                always be zero.)

                The memory area referenced by the global data pointer is known as the global data area. It
                can be up to 512 KB in length, and â because of the way the global data pointer is
                defined â must be aligned to a 64-byte boundary in virtual memory.

                When expressed in assembly language, the offset values used in global pointer relative
                addressing always specify byte offsets from the global data pointer. Note that the offsets
                must be integral multiples of the size of the instruction data type.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       87
Hexagon V62 Programmer's Reference Manual                                                              Memory



                Table 5-6 lists the offset ranges for global pointer relative addressing.

                Table 5-6     Offset ranges (Global pointer relative)
                                                             Offset Must Be
                   Data Type          Offset Range
                                                               Multiple Of
                doubleword            0 ... 524280                 8
                word                  0 ... 262140                 4
                halfword              0 ... 131070                 2
                byte                  0 ... 65535                  1


                   NOTE      When using global pointer relative addressing, the immediate operand should
                             be a symbol in the .sdata or .sbss section to ensure that the offset is valid.


     5.7.5      Indirect
                The indirect addressing mode uses a 32-bit value stored in a general register as the
                effective memory address. For example:
                    R2 = memub(R1)          // load R2 with unsigned byte from addr R1



     5.7.6      Indirect with offset
                The indirect with offset addressing mode adds a signed offset value to a general register
                value to create the 32-bit effective memory address. For example:
                    R2 = memh(R3 + #100)               // load R2 with signed halfword
                                                       // from [R3 + 100 bytes]

                When expressed in assembly language, the offset values always specify byte offsets from
                the general register value. Note that the offsets must be integral multiples of the size of the
                instruction data type.

                Table 5-7 lists the offset ranges for indirect with offset addressing.

                Table 5-7     Offset ranges (Indirect with offset)
                                                             Offset Must Be
                   Data Type          Offset Range
                                                               Multiple Of
                doubleword            -8192 ... 8184               8
                word                  -4096 ... 4092               4
                halfword              -2048 ... 2046               2
                byte                  -1024 ... 1023               1


                   NOTE      The offset range is smaller for conditional instructions (Section 5.8).




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      88
Hexagon V62 Programmer's Reference Manual                                                            Memory



     5.7.7      Indirect with register offset
                The indirect with register offset addressing mode adds a 32-bit general register value to
                the result created by performing an arithmetic left shift of a second 32-bit general register
                value by the amount specified in a 2-bit unsigned immediate value, forming the 32-bit
                effective memory address. For example:
                    R2 = memh(R3+R4<<#1)            // load R2 with signed halfword
                                                    // from [R3 + (R4 << 1)]

                The register values always specify byte addresses.


     5.7.8      Indirect with auto-increment immediate
                The indirect with auto-increment immediate addressing mode uses a 32-bit value stored in
                a general register to specify the effective memory address. However, after the address is
                accessed, a signed value (known as the increment) is added to the register so it specifies a
                different memory address (which will be accessed in a subsequent instruction). For
                example:
                    R2 = memw(R3++#4)          // R3 contains the effective address
                                               // R3 is then incremented by 4

                When expressed in assembly language, the increment values always specify byte offsets
                from the general register value. Note that the offsets must be integral multiples of the size
                of the instruction data type.

                Table 5-8 lists the increment ranges for indirect with auto-increment immediate
                addressing.

                Table 5-8     Increment ranges (Indirect with auto-inc immediate)
                                            Increment            Increment Must Be
                       Data Type
                                              Range                  Multiple Of
                doubleword                   -64 ... 56                   8
                word                         -32 ... 28                   4
                halfword                     -16 ... 14                   2
                byte                          -8 ... 7                    1



     5.7.9      Indirect with auto-increment register
                The indirect with auto-increment register addressing mode is functionally equivalent to
                indirect with auto-increment immediate, but uses a modifier register Mx (Section 2.2.4)
                instead of an immediate value to hold the increment. For example:
                    R2 = memw(R0++M1)          // The effective addr is the value of R0.
                                               // Next, M1 is added to R0 and the result
                                               // is stored in R0.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    89
Hexagon V62 Programmer's Reference Manual                                                             Memory



                When auto-incrementing with a modifier register, the increment is a signed 32-bit value
                which is added to the general register. This offers two advantages over auto-increment
                immediate:

                     ï®   A larger increment range
                     ï®   Variable increments (since the modifier register can be programmed at runtime)

                The increment value always specifies a byte offset from the general register value.

                   NOTE      The signed 32-bit increment range is identical for all instruction data types
                             (doubleword, word, halfword, byte).


   5.7.10       Circular with auto-increment immediate
                The circular with auto-increment immediate addressing mode is a variant of indirect with
                auto-increment addressing â it accesses data buffers in a modulo wrap-around fashion.
                Circular addressing is commonly used in data stream processing.

                Circular addressing is expressed in assembly language with the address modifier
                â:circ(Mx)â, where Mx specifies a modifier register which is programmed to specify
                the circular buffer (Section 2.2.4). For example:
                    R0 = memb(R2++#4:circ(M0))             // load from R2 in circ buf specified
                                                           // by M0
                    memw(R2++#8:circ(M1)) = R0             // store to R2 in circ buf specified
                                                           // by M1

                Circular addressing is set up by programming the following elements:
                    ï® The Length field of the Mx register is set to the length (in bytes) of the circular
                        buffer to be accessed. A circular buffer can be from 4 to (128K-1) bytes long.
                     ï®   The K field of the Mx register is always set to 0.
                     ï®   The circular start register CSx that corresponds to Mx (CS0 for M0, CS1 for M1)
                         is set to the start address of the circular buffer.

                In circular addressing, after memory is accessed at the address specified in the general
                register, the general register is incremented by the immediate increment value and then
                moduloâd by the circular buffer length to implement wrap-around access of the buffer.

                When expressed in assembly language, the increment values always specify byte offsets
                from the general register value. Note that the offsets must be integral multiples of the size
                of the instruction data type.

                Table 5-9 lists the increment ranges for circular with auto-increment immediate
                addressing.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        90
Hexagon V62 Programmer's Reference Manual                                                              Memory



                Table 5-9      Increment ranges (Circular with auto-inc immediate)
                                              Increment            Increment Must Be
                       Data Type
                                                Range                  Multiple Of
                doubleword                     -64 ... 56                   8
                word                           -32 ... 28                   4
                halfword                       -16 ... 14                   2
                byte                            -8 ... 7                    1


                When programming a circular buffer the following rules apply:
                   ï® The start address must be aligned to the native access size of the buffer elements.

                       ï®   ABS(Increment) < Length. The absolute value of the increment must be less than
                           the buffer length.
                       ï®   Access size < (Length-1). The memory access size (1 for byte, 2 for halfword, 4
                           for word, 8 for doubleword) must be less than (Length-1).
                       ï®   Buffers must not wrap around in the 32-bit address space.

                   NOTE        If any of these rules are not followed the execution result is undefined.

                For example, a 150-byte circular buffer can be set up and accessed as follows:
                    R4.H = #0                                // K = 0
                    R4.L = #150                              // length = 150
                    M0 = R4
                    R2 = ##cbuf                              // start addr = cbuf
                    CS0 = R2
                    R0 = memb(R2++#4:circ(M0))               //   Load byte from circ buf
                                                             //   specified by M0/CS0
                                                             //   inc R2 by 4 after load
                                                             //   wrap R2 around if >= 150

                The following C function precisely describes the behavior of the circular add function:
                    unsigned int
                    fcircadd(unsigned int pointer, int offset,
                     unsigned int M_reg, unsigned int CS_reg)
                    {
                    unsigned int length;
                    int new_pointer, start_addr, end_addr;

                    length = (M_reg&0x01ffff); // lower 17-bits gives buffer size
                    new_pointer = pointer+offset;
                    start_addr = CS_reg;
                    end_addr = CS_reg + lenth;
                    if (new_pointer >= end_addr) {
                       new_pointer -= length;
                    } else if (new_pointer < start_addr) {
                       new_pointer += length;
                    }
                    return (new_pointer);
                    }


80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    91
Hexagon V62 Programmer's Reference Manual                                                               Memory



   5.7.11       Circular with auto-increment register
                The circular with auto-increment register addressing mode is functionally equivalent to
                circular with auto-increment immediate, but uses a register instead of an immediate value
                to hold the increment.

                Register increments are specified in circular addressing instructions by using the symbol I
                as the increment (instead of an immediate value). For example:
                    R0 = memw(R2++I:circ(M1))               // load byte with incr of I*4 from
                                                            // circ buf specified by M1/CS1

                When auto-incrementing with a register, the increment is a signed 11-bit value which is
                added to the general register. This offers two advantages over circular addressing with
                immediate increments:

                       ï®   Larger increment ranges
                       ï®   Variable increments (since the increment register can be programmed at runtime)

                The circular register increment value is programmed in the I field of the modifier register
                Mx (Section 2.2.4) as part of setting up the circular data access. This register field holds the
                signed 11-bit increment value.

                Increment values are expressed in units of the buffer element data type, and are
                automatically scaled at runtime to the proper data access size.

                Table 5-10 lists the increment ranges for circular with auto-increment register addressing.

                Table 5-10 Increment ranges (Circular with auto-inc register)
                                           Increment            Increment Must Be
                    Data Type
                                             Range                  Multiple Of
                doubleword                -8192 ... 8184                  8
                word                      -4096 ... 4092                  4
                halfword                  -2048 ... 2046                  2
                byte                      -1024 ... 1023                  1


                When programming a circular buffer (with either a register or immediate increment), all
                the rules that apply to circular addressing must be followed â for details see
                Section 5.7.10.

                   NOTE       If any of these rules are not followed the execution result is undefined.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       92
Hexagon V62 Programmer's Reference Manual                                                             Memory



   5.7.12       Bit-reversed with auto-increment register
                The bit-reversed with auto-increment register addressing mode is a variant of indirect with
                auto-increment addressing â it accesses data buffers using an address value which is the
                bit-wise reversal of the value stored in the general register. Bit-reversed addressing is used
                in fast Fourier transforms (FFT) and Viterbi encoding.

                The bit-wise reversal of a 32-bit address value is defined as follows:

                     ï®   The lower 16 bits are transformed by exchanging bit 0 with bit 15, bit 1 with bit
                         14, and so on.
                     ï®   The upper 16 bits remain unchanged.

                Bit-reversed addressing is expressed in assembly language with the address modifier
                â:brevâ. For example:
                    R2 = memub(R0++M1:brev)          // The address is (R0.H | bitrev(R0.L))
                                                     // The orginal R0 (not reversed) is added
                                                     // to M1 and written back to R0

                The initial values for the address and increment must be set in bit-reversed form, with the
                hardware bit-reversing the bit-reversed address value to form the effective address.

                The buffer length for a bit-reversed buffer must be an integral power of 2, with a
                maximum length of 64K bytes.

                To support bit-reversed addressing, buffers must be properly aligned in memory. A bit-
                reversed buffer is properly aligned when its starting byte address is aligned to a power of 2
                greater than or equal to the buffer size (in bytes). For example:
                    int bitrev_buf[256] __attribute__((aligned(1024)));

                The bit-reversed buffer declared above is aligned to 1024 bytes because the buffer size is
                1024 bytes (256 integer words ï´ 4 bytes), and 1024 is an integral power of 2.

                The buffer location pointer for a bit-reversed buffer must be initialized so the least-
                significant 16 bits of the address value are bit-reversed.

                The increment value must be initialized to the following value:
                    bitreverse(buffer_size_in_bytes / 2)

                ...where bitreverse is defined as bit-reversing the least-significant 16 bits while leaving
                the remaining bits unchanged.

                   NOTE      To simplify the initialization of the bit-reversed pointer, bit-reversed buffers
                             can be aligned to a 64K byte boundary. This has the advantage of allowing the
                             bit-reversed pointer to be initialized to the base address of the bit-reversed
                             buffer, with no bit-reversing required for the least-significant 16 bits of the
                             pointer value (which are all set to 0 by the 64K alignment).

                             Since buffers allocated on the stack only have an alignment of 8 bytes or less,
                             in most cases bit-reversed buffers should not be declared on the stack.



80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      93
Hexagon V62 Programmer's Reference Manual                                                             Memory



                After a bit-reversed memory access is completed, the general register is incremented by
                the register increment value. Note that the value in the general register is never affected by
                the bit-reversal that is performed as part of the memory access.

                   NOTE        The Hexagon processor supports only register increments for bit-reversed
                               addressing â it does not support immediate increments.


       5.8      Conditional load/stores
                Some load and store instructions can be executed conditionally based on predicate values
                which were set in a previous instruction. The compiler generates conditional loads and
                stores to increase instruction-level parallelism.

                Conditional loads and stores are expressed in assembly language with the instruction
                prefix âif (pred_expr)â, where pred_expr specifies a predicate register expression
                (Section 6.1). For example:
                           if (P0) R0 = memw(R2)                      // conditional load
                           if (!P2) memh(R3 + #100) = R1              // conditional store
                           if (P1.new) R3 = memw(R3++#4)              // conditional load

                Not all addressing modes are supported in conditional loads and stores. Table 5-11 shows
                which modes are supported.

                Table 5-11     Addressing modes (Conditional load/store)
                               Addressing Mode                   Conditional
                Absolute                                             Yes
                Absolute-set                                          No
                Absolute with register offset                         No
                Global pointer relative                               No
                Indirect                                             Yes
                Indirect with offset                                 Yes
                Indirect with register offset                        Yes
                Indirect with auto-increment immediate               Yes
                Indirect with auto-increment register                 No
                Circular with auto-increment immediate                No
                Circular with auto-increment register                 No
                Bit-reversed with auto-increment register             No


                When a conditional load or store instruction uses indirect-with-offset addressing mode,
                note that the offset range is smaller than the range normally defined for indirect-with-
                offset addressing (Section 5.7.6).




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      94
Hexagon V62 Programmer's Reference Manual                                                            Memory



                Table 5-12 lists the conditional and normal offset ranges for indirect-with-offset
                addressing.

                Table 5-12 Conditional offset ranges (Indirect with offset)
                                        Offset Range         Offset Range          Offset Must Be
                   Data Type
                                        (Conditional)          (Normal)              Multiple Of
                doubleword                0 ... 504          -8192 ... 8184               8
                word                      0 ... 252          -4096 ... 4092               4
                halfword                  0 ... 126          -2048 ... 2046               2
                byte                      0 ... 63           -1024 ... 1023               1


                   NOTE        For more information on conditional execution see Chapter 6.


       5.9      Cache memory
                The Hexagon processor has a cache-based memory architecture:

                       ï®   A level 1 instruction cache holds recently-fetched instructions.
                       ï®   A level 1 data cache holds recently-accessed data memory.

                Load/store operations that access memory through the level 1 caches are referred to as
                cached accesses.

                Load/stores that bypass the level 1 caches are referred to as uncached accesses.

                Specific memory areas can be configured so they perform cached or uncached accesses.
                This configuration is performed by the Hexagon processorâs memory management unit
                (MMU). The operating system is responsible for programming the MMU.

                Two types of caching are supported (as cache modes):

                       ï®   Write-through caching keep the cache data consistent with external memory by
                           always writing to the memory any data that is stored in the cache.
                       ï®   Write-back caching allows data to be stored in the cache without being
                           immediately written to external memory. Cached data that is inconsistent with
                           external memory is referred to as dirty.

                The Hexagon processor includes dedicated cache maintenance instructions which can be
                used to push dirty data out to external memory.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    95
Hexagon V62 Programmer's Reference Manual                                                          Memory



                Table 5-13 lists the cache sizes for the V6x processor versions.

                Table 5-13 Hexagon processor cache size
                     Processor            L1 instruction      L1 data                L2
                      version                 cache            cache               cache
                          V60                 16KB             32KB                256KB
                          V61                 32KB             32KB              768KB 1
                1   512K L2$ + 256K TCM




     5.9.1      Uncached memory
                In some cases load/store operations need to bypass the cache memories and be serviced
                externally (for example, when accessing memory-mapped I/O, registers, and peripheral
                devices, or other system defined entities). The operating system is responsible for
                configuring the MMU to generate uncached memory accesses.

                Uncached memory is categorized into two distinct types:

                      ï®    Device-type is for accessing memory that has side-effects (such as a memory-
                           mapped FIFO peripheral). The hardware ensures that interrupts do not cancel a
                           pending device access. The hardware does not re-order device accesses.
                           Peripheral control registers should be marked as device-type.
                      ï®    Uncached-type is for memory-like memory. No side effects are associated with an
                           access. The hardware can load from uncached memory multiple times. The
                           hardware can re-order uncached accesses.

                For instruction accesses, device-type memory is functionally identical to uncached-type
                memory. For data accesses, they are different.

                Code can be executed directly from the L2 cache, bypassing the L1 cache.


     5.9.2      Tightly coupled memory
                The Hexagon processor supports tightly-coupled instruction memory at Level 1, which is
                defined as memory with similar access properties to the instruction cache.

                Tightly-coupled memory is also supported at level 2, which is defined as backing store to
                the primary caches.

                For more information see Chapter 9.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    96
Hexagon V62 Programmer's Reference Manual                                                                           Memory



     5.9.3      Cache maintenance operations
                The Hexagon processor includes dedicated cache maintenance instructions which can be
                used to invalidate cache data or push dirty data out to external memory.

                The cache maintenance instructions operate on specific memory addresses. If the
                instruction causes an address error (due to a privilege violation), the processor raises an
                exception.

                     NOTE       The exception to this rule is dcfetch, which never causes a processor
                                exception.

                Whenever maintenance operations are performed on the instruction cache, the isync
                instruction (Section 5.10) must be executed immediately afterwards. This instruction
                ensures that the maintenance operations will be observed by subsequent instructions.

                Table 5-14 lists the cache maintenance instructions.

                Table 5-14 Cache instructions (User-level)
                                                 Permitted In
                           Syntax                                                            Operation
                                                   Packet
                icinva(Rs)                           Solo 1         Instruction cache invalidate.
                                                                    Look up instruction cache at address Rs.
                                                                    If address is in cache, invalidate it.
                dccleaninva(Rs)                      Slot 1         Data cache clean and invalidate.
                                                   empty or         Look up data cache at address Rs.
                                                  ALU32 only        If address is in cache and has dirty data, flush that
                                                                    data out to memory. The cache line is then
                                                                    invalidated, whether or not dirty data was written.
                dccleana(Rs)                        Slot 1          Data cache clean.
                                                   empty or         Look up data cache at address Rs.
                                                  ALU32 only        If address is in cache and has dirty data, flush that
                                                                    data out to memory.
                dcinva(Rs)                           Slot 1         Equivalent to dccleaninva(Rs).
                                                   empty or
                                                  ALU32 only
                dcfetch(Rs)                        Normal 2         Data cache prefetch.
                                                                    Prefetch data at address Rs into data cache.
                                                                    NOTE - This instruction will not cause an exception.
                l2fetch(Rs,Rt)                     ALU32 or         L2 cache prefetch.
                                                  XTYPE only        Prefetch data from memory specified by Rs and Rt
                                                                    into L2 cache.
                1   Solo means that the instruction must not be grouped with other instructions in a packet.
                2   Normal means that the normal instruction-grouping constraints apply.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                    97
Hexagon V62 Programmer's Reference Manual                                                                Memory



     5.9.4      L2 cache operations
                The cache maintenance operations (Section 5.9.3) operate on both the L1 and L2 caches.

                The data cache coherency operations (including clean, invalidate, and clean and
                invalidate) affect both the L1 and L2 caches, and ensure that the memory hierarchy
                remains coherent.

                However, the instruction cache invalidate operation affects only the L1 cache. Therefore,
                invalidating instructions that may be in the L1 or L2 caches requires a two-step procedure:

                    1. Use icinva to invalidate instructions from the L1 cache.
                    2. Use dcinva separately to invalidate instructions from the L2 cache.


     5.9.5      Cache line zero
                The Hexagon processor includes the instruction dczeroa. This instruction allocates a line
                in the L1 data cache and clears it (by storing all zeros). The behavior is as follows:

                     ï®   The Rs register value must be 32-byte aligned. If it is unaligned, the processor will
                         raise an unaligned error exception.
                     ï®   In the case of a cache hit, the specified cache line is cleared (i.e., written with all
                         zeros) and made dirty.
                     ï®   In the case of a cache miss, the specified cache line is not fetched from external
                         memory. Instead, the line is allocated in the data cache, cleared, and made dirty.

                This instruction is useful in optimizing write-only data. It allows for the use of write-back
                pages â which are the most power and performance efficient â without the need to initially
                fetch the line to be written. This removes unnecessary read bandwidth and latency.

                   NOTE      dczeroa has the same exception behavior as write-back stores.

                             A packet with dczeroa must have Slot 1 either empty or containing an
                             ALU32 instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          98
Hexagon V62 Programmer's Reference Manual                                                              Memory



     5.9.6      Cache prefetch
                The Hexagon processor supports the following types of cache prefetching:

                     ï®   Hardware-based instruction cache prefetching
                     ï®   Software-based data cache prefetching
                     ï®   Software-based L2FETCH
                     ï®   Hardware-based data cache prefetching

                Hardware-based instruction cache prefetching

                L1 and L2 instruction cache prefetching can be enabled or disabled on a per-thread basis â
                this is done by setting the HFI field in the user status register (Section 2.2.3).

                Software-based data cache prefetching

                The Hexagon processor includes the instruction dcfetch. This instruction queries the L1
                data cache based on the address specified in the instruction:

                     ï®   If the address is present in the cache, no action is taken.
                     ï®   If the cache line for the address is missing, the processor attempts to fill the cache
                         line from the next level of memory. Note that the thread does not stall, but rather
                         continues executing while the cache line fill occurs in the background.
                     ï®   If the address is invalid, no exception is generated and the dcfetch instruction is
                         treated as a NOP.

                Software-based L2FETCH

                More powerful L2 prefetching â of data or instructions â is provided by the l2fetch
                instruction, which specifies an area of memory that is prefetched by the Hexagon
                processorâs hardware prefetch engine. l2fetch specifies two registers (Rs and Rt) as
                operands. Rs contains the 32-bit virtual start address of the memory area to be prefetched.
                Rt contains three bit fields which further specify the memory area:

                     ï®   Rt[15:8] â Width, which specifies the width (in bytes) of a block of memory to
                         fetch.
                     ï®   Rt[7:0] â Height, which specifies the number of Width-sized blocks to fetch.
                     ï®   Rt[31:16] â Stride, which specifies an unsigned byte offset that is used to
                         increment the pointer after each Width-sized block is fetched.

                The l2fetch instruction is non-blocking: it initiates a prefetch operation which is
                performed in the background by the prefetch engine while the thread continues to execute
                Hexagon processor instructions.

                The prefetch engine requests all lines in the specified memory area. If the line(s) of
                interest are already resident in the L2 cache, the prefetch engine performs no action. If the
                lines are not in the L2 cache, the prefetch engine attempts to fetch them.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        99
Hexagon V62 Programmer's Reference Manual                                                                              Memory



                The prefetch engine makes a best effort to prefetch the requested data, and attempts to
                perform prefetching at a lower priority than demand fetches. This prevents the prefetch
                engine from adding bus traffic when the system is under a heavy load.

                If a program executes an l2fetch instruction while the prefetch operation from a
                previous l2fetch is still active, the prefetch engine halts the current prefetch operation.

                   NOTE        Executing l2fetch with any bit field operand programmed to zero will
                               cancel all prefetch activity.

                The status of the current prefetch operation is maintained in the PFA field of the user
                status register (Section 2.2.3). This field can be used to determine whether or not a
                prefetch operation has completed.

                With respect to MMU permissions and error checking, the l2fetch instruction behaves
                similarly to a load instruction. If the virtual address causes a processor exception, the
                exception will be taken. (Note that this differs from the dcfetch instruction, which is
                treated as a NOP in the presence of a translation/protection error.)

                   NOTE        Prefetches are dropped when the generated prefetch address resides on a
                               different page than the start address. The programmer must use sufficiently
                               large pages to ensure this does not occur.

                Figure 5-2 shows two examples of using the l2fetch instruction. The first shows a âboxâ
                prefetch, where a 2-D range of memory is defined within a larger frame. The second
                example shows a prefetch for a large linear memory area of size (Lines * 128).


                              L2FETCH for box prefetch                          L2FETCH for large linear prefetch

                         31                                                      31              16 15         8 7           0
                                        16 15       8 7           0

                    Rt         Stride       Width        Height          Rt                128           128         Lines



                   Rs              Start Address                         Rs                  Start Address



                                                Stride



                                         Width


                                        Prefetch
                          Height                                              128* Lines
                                         Area




                Figure 5-2 L2FETCH instruction




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                            100
Hexagon V62 Programmer's Reference Manual                                                          Memory



                Hardware-based data cache prefetching

                L1 data cache prefetching can be enabled or disabled on a per-thread basis â this is done
                by setting the HFD field in the user status register (Section 2.2.3).

                When data cache prefetching is enabled, the Hexagon processor observes patterns of data
                cache misses, and attempts to predict future misses based on any recurring patterns of
                misses where the addresses are separated by a constant stride. If such patterns are found,
                the processor attempts to automatically prefetch future cache lines.

                Data cache prefetching can be user-enabled at four levels of aggressiveness:

                    ï®   HFD = 00: No prefetching
                    ï®   HFD = 01: Prefetch up to 4 lines for misses originating from a load, with a post-
                        update addressing mode that occurs within a hardware loop
                    ï®   HFD = 10: Prefetch up to 4 lines for misses originating from loads that occur
                        within a hardware loop
                    ï®   HFD = 11: Prefetch up to 8 lines for misses originating from loads




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   101
Hexagon V62 Programmer's Reference Manual                                                                Memory



     5.10       Memory ordering
                Some devices may require synchronization of stores and loads when they are accessed. In
                this case a set of processor instructions enable programmer control of the synchronization
                and ordering of memory accesses.

                Table 5-15 lists the memory-ordering instructions.

                Table 5-15 Memory ordering instructions
                    Syntax                                        Operation
                isync           Instruction synchronize.
                                This instruction should be executed after any instruction cache maintenance
                                operation.
                syncht          Synchronize transactions.
                                Perform âheavyweightâ synchronization. Ensure that all previous program
                                transactions (e.g., memw_locked, cached and uncached load/store) have
                                completed before execution resumes past this instruction.


                                NOTE - In V61 syncht ensures that outstanding memory operations from all
                                threads are complete before the syncht instruction is committed.
                barrier         Set memory barrier.
                                Ensure proper ordering between the program accesses performed before the
                                instruction and those performed after the instruction.
                                All accesses before the barrier will be globally observable before any access
                                occurring after the barrier can be observed.


                                NOTE - In V61 barrier ensures that all outstanding memory operations from the
                                thread executing the barrier are complete before the instruction is committed.


                Data memory accesses and program memory accesses are treated separately and held in
                separate caches. Software should ensure coherency between data and program code if
                necessary.

                For example, with generated or self-modified code, the modified code will be placed in the
                data cache and may be inconsistent with program cache. The software must explicitly
                force modified data cache lines to memory (either by using a write-through policy, or
                through explicit cache clean instructions). A barrier instruction should then be used to
                ensure completion of the stores. Finally, relevant instruction cache contents should be
                invalidated so the new instructions can be re-fetched.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           102
Hexagon V62 Programmer's Reference Manual                                                               Memory



                Here is the recommended code sequence to change and then execute an instruction:
                    ICINVA(R1)              //   clear code from instruction cache
                    ISYNC                   //   ensure that ICINVA is finished
                    MEMW(R1)=R0             //   write the new instruction
                    DCCLEANINVA(R1)         //   force data out of data cache
                    SYNCHT                  //   ensure that itâs in memory
                    JUMPR R1                //   can now execute code at R1

                   NOTE     The memory-ordering instructions must not be grouped with other
                            instructions in a packet, otherwise the behavior is undefined.

                            This code sequence differs from the one used in previous processor versions.


     5.11       Atomic operations
                The Hexagon processor includes an LL/SC (Load Locked / Store Conditional) mechanism
                to provide the atomic read-modify-write operation that is necessary to implement
                synchronization primitives such as semaphores and mutexes.

                These primitives are used to synchronize the execution of different software programs
                running concurrently on the Hexagon processor. They can also be used to provide atomic
                memory support between the Hexagon processor and external blocks.

                Table 5-16 describes the atomic instructions.

                Table 5-16 Atomic instructions
                                Syntax                                       Description
                    Rd = memw_locked(Rs)                Load locked word.
                                                        Reserve lock on word at address Rs.
                    memw_locked(Rs,Pd) = Rt             Store conditional word.
                                                        If no other atomic operation has been performed at
                                                        the address (i.e., atomicity is ensured), perform the
                                                        store to the word at address Rs and return TRUE in
                                                        Pd; otherwise return FALSE.
                                                        TRUE indicates that the LL and SC operations have
                                                        been performed atomically.
                    Rdd = memd_locked(Rs)               Load locked doubleword.
                                                        Reserve lock on doubleword at address Rs.
                    memd_locked(Rs,Pd) = Rtt            Store conditional doubleword.
                                                        If no other atomic operation has been performed at
                                                        the address (i.e., atomicity is ensured), perform the
                                                        store to the doubleword at address Rs and return
                                                        TRUE in Pd; otherwise return FALSE.
                                                        TRUE indicates that the LL and SC operations have
                                                        been performed atomically.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           103
Hexagon V62 Programmer's Reference Manual                                                            Memory



                Here is the recommended code sequence to acquire a mutex:
                    // assume mutex address is held in R0
                    // assume R1,R3,P0,P1 are scratch

                    lockMutex:
                    R3 = #1
                    lock_test_spin:
                    R1 = memw_locked(R0)                   // do normal test to wait
                    P1 = cmp.eq(R1,#0)                     // for lock to be available
                    if (!P1) jump lock_test_spin
                    memw_locked(R0,P0) = r3                // do store conditional (SC)
                    if (!P0) jump lock_test_spin           // was LL and SC done atomically?

                Here is the recommended code sequence to release a mutex:
                    // assume mutex address is held in R0
                    // assume R1 is scratch

                    R1 = #0
                    memw(R0) = R1

                Atomic memX_locked operations are supported for external accesses that use the AXI bus
                and support atomic operations. To perform load-locked operations with external memory,
                the operating system must define the memory page as uncacheable, otherwise the
                processor behavior is undefined.

                If a load locked operation is performed on an address that does not support atomic
                operations, the behavior is undefined.

                For atomic operations on cacheable memory, the page attributes must be set to cacheable
                and write-back, otherwise the behavior is undefined. Cacheable memory must be used
                when threads need to synchronize with each other.

                   NOTE     External memX_locked operations are not supported on the AHB bus. If they
                            are performed on the AHB bus, the behavior is undefined.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   104
         6       Conditional Execution


                The Hexagon processor uses a conditional execution model based on compare instructions
                that set predicate bits in one of four 8-bit predicate registers (P0-P3). These predicate bits
                can be used to conditionally execute certain instructions.

                Conditional scalar operations examine only the least-significant bit in a predicate register,
                while conditional vector operations examine multiple bits in the register.

                Branch instructions are the main consumers of the predicate registers.


       6.1      Scalar predicates
                Scalar predicates are 8-bit values which are used in conditional instructions to represent
                truth values:

                     ï®   0xFF represents true
                     ï®   0x00 represents false

                The Hexagon processor provides the four 8-bit predicate registers P0-P3 to hold scalar
                predicates (Section 2.2.5). These registers are assigned values by the predicate-generating
                instructions, and examined by the predicate-consuming instructions.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     105
Hexagon V62 Programmer's Reference Manual                                                    Conditional Execution



     6.1.1      Generating scalar predicates
                The following instructions generate scalar predicates:

                     ï®   Compare byte, halfword, word, doubleword
                     ï®   Compare single- and double-precision floating point
                     ï®   Classify floating-point value
                     ï®   Compare bitmask
                     ï®   Bounds check
                     ï®   TLB match
                     ï®   Store conditional

                Table 6-1 lists the scalar predicate-generating instructions.

                Table 6-1    Scalar predicate-generating instructions
                                 Syntax                                         Operation
                Pd   =   cmpb.eq(Rs,{Rt,#u8})              Equal (signed).
                Pd   =   cmph.eq(Rs,{Rt,#s8})              Compare register Rs to Rt or a signed immediate for
                Pd   =   [!]cmp.eq(Rs,{Rt,#s10})           equality. Assign Pd the resulting truth value.
                Pd   =   cmp.eq(Rss,Rtt)
                Pd   =   sfcmp.eq(Rs,Rt)
                Pd   =   dfcmp.eq(Rss,Rtt)
                Pd   =   cmpb.gt(Rs,{Rt,#s8}               Greater than (signed).
                Pd   =   cmph.gt(Rs,{Rt,#s8})              Compare register Rs to Rt or a signed immediate for
                Pd   =   [!]cmp.gt(Rs,{Rt,#s10})           signed greater than. Assign Pd the resulting truth
                Pd   =   cmp.gt(Rss,Rtt)                   value.
                Pd   =   sfcmp.gt(Rs,Rt)
                Pd   =   dfcmp.gt(Rss,Rtt)
                Pd   =   cmpb.gtu(Rs,{Rt,#u7})             Greater than (unsigned).
                Pd   =   cmph.gtu(Rs,{Rt,#u7})             Compare register Rs to Rt or an unsigned immediate
                Pd   =   [!]cmp.gtu(Rs,{Rt,#u9})           for unsigned greater than. Assign Pd the resulting
                Pd   =   cmp.gtu(Rss,Rtt)                  truth value.
                Pd = cmp.ge(Rs,#s8)                        Greater than or equal (signed).
                Pd = sfcmp.ge(Rs,Rt)                       Compare register Rs to Rt or a signed immediate for
                Pd = dfcmp.ge(Rss,Rtt)                     signed greater than or equal. Assign Pd the resulting
                                                           truth value.
                Pd = cmp.geu(Rs,#u8)                       Greater than or equal (unsigned).
                                                           Compare register Rs to an unsigned immediate for
                                                           unsigned greater than or equal. Assign Pd the
                                                           resulting truth value.
                Pd = cmp.lt(Rs,Rt)                         Less than (signed).
                                                           Compare register Rs to Rt for signed less than.
                                                           Assign Pd the resulting truth value.
                Pd = cmp.ltu(Rs,Rt)                        Less than (unsigned).
                                                           Compare register Rs to Rt for unsigned less than.
                                                           Assign Pd the resulting truth value.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         106
Hexagon V62 Programmer's Reference Manual                                                     Conditional Execution



                Table 6-1   Scalar predicate-generating instructions (Continued)
                Pd = sfcmp.uo(Rs,Rt)                      Unordered (signed).
                Pd = dfcmp.uo(Rss,Rtt)                    Determine if register Rs or Rt is set to the value NaN.
                                                          Assign Pd the resulting truth value.
                Pd=sfclass(Rs,#u5)                        Classify value (signed).
                Pd=dfclass(Rss,#u5)                       Determine if register Rs is set to any of the specified
                                                          classes. Assign Pd the resulting truth value.
                Pd = [!]tstbit(Rs,{Rt,#u5})               Test if bit set.
                                                          Rt or an unsigned immediate specifies a bit position.
                                                          Test if the bit in Rs that is specified by the bit position
                                                          is set. Assign Pd the resulting truth value.
                Pd = [!]bitsclr(Rs,{Rt,#u6})              Test if bits clear.
                                                          Rt or an unsigned immediate specifies a bitmask.
                                                          Test if the bits in Rs that are specified by the bitmask
                                                          are all clear. Assign Pd the resulting truth value.
                Pd = [!]bitsset(Rs,Rt)                    Test if bits set.
                                                          Rt specifies a bitmask.
                                                          Test if the bits in Rs that are specified by the bitmask
                                                          are all set. Assign Pd the resulting truth value.
                memw_locked(Rs,Pd) = Rt                   Store conditional.
                memd_locked(Rs,Pd) = Rtt                  If no other atomic operation has been performed at
                                                          the address (i.e., atomicity is ensured), perform the
                                                          store to the word at address Rs. Assign Pd the
                                                          resulting truth value.
                Pd = boundscheck(Rs,Rtt)                  Bounds check.
                                                          Determine if Rs falls in the numeric range defined by
                                                          Rtt. Assign Pd the resulting truth value.
                Pd = tlbmatch(Rss,Rt)                     Determine if TLB entry in Rss matches the ASID:PPN
                                                          specified in Rt. Assign Pd the resulting truth value.


                   NOTE     One of the compare instructions (cmp.eq) includes a variant which stores a
                            binary predicate value (0 or 1) in a general register not a predicate register.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             107
Hexagon V62 Programmer's Reference Manual                                                  Conditional Execution



     6.1.2      Consuming scalar predicates
                Certain instructions can be conditionally executed based on the value of a scalar predicate
                (or alternatively specify a scalar predicate as an input to their operation).

                The conditional instructions that consume scalar predicates examine only the least-
                significant bit of the predicate value. In the simplest case, this bit value directly determines
                whether the instruction is executed:

                     ï®   1 indicates that the instruction is executed
                     ï®   0 indicates that the instruction is not executed

                If a conditional instruction includes the operator ! in its predicate expression, then the
                logical negation of the bit value determines whether the instruction is executed.

                Conditional instructions are expressed in assembly language with the instruction prefix
                âif (pred_expr)â, where pred_expr specifies the predicate expression. For example:
                    if   (P0) jump target                  //   jump if P0 is true
                    if   (!P2) R2 = R5                     //   assign register if !P2 is true
                    if   (P1) R0 = sub(R2,R3)              //   conditionally subtract if P1
                    if   (P2) R0 = memw(R2)                //   conditionally load word if P2

                The following instructions can be used as conditional instructions:

                     ï®   Jumps and calls (Section 7.3)
                     ï®   Many load and store instructions (Section 5.8)
                     ï®   Logical instructions (including AND/OR/XOR)
                     ï®   Shift halfword
                     ï®   32-bit add/subtract by register or short immediate
                     ï®   Sign and zero extend
                     ï®   32-bit register transfer and 64-bit combine word
                     ï®   Register transfer immediate
                     ï®   Deallocate frame and return

                When a conditional load or store is executed and the predicate expression is false, the
                instruction is cancelled (including any exceptions that might occur). For example, if a
                conditional load uses an address with a memory permission violation, and the predicate
                expression is false, then the load does not execute and the exception is not raised.

                The mux instruction accepts a predicate as one of its basic operands:
                    Rd = mux(Ps,Rs,Rt)

                mux selects either Rs or Rt based on the least significant bit in Ps. If the least-significant
                bit in Ps is a 1, then Rd is set to Rs, otherwise it is set to Rt.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       108
Hexagon V62 Programmer's Reference Manual                                                 Conditional Execution



     6.1.3      Auto-AND predicates
                If multiple compare instructions in a packet write to the same predicate register, the result
                is the logical AND of the individual compare results. For example:
                    {
                    P0 = cmp(A)                                  // if A && B then jump
                    P0 = cmp(B)
                    if (P0.new) jump:T taken_path
                    }

                To perform the corresponding OR operation, the following instructions can be used to
                compute the negation of an existing compare (using De Morganâs law):
                     ï®   Pd = !cmp.{eq,gt}(Rs, {#s10,Rt} )
                     ï®   Pd = !cmp.gtu(Rs, {#u9,Rt} )
                     ï®   Pd = !tstbit(Rs, {#u5,Rt} )
                     ï®   Pd = !bitsclr(Rs, {#u6,Rt} )
                     ï®   Pd = !bitsset(Rs,Rt)

                Auto-AND predicates have the following restrictions:

                     ï®   If a packet contains endloopN, it cannot perform an auto-AND with predicate
                         register P3.
                     ï®   If a packet contains a register transfer from a general register to a predicate
                         register, then no other instruction in the packet can write to the same predicate
                         register. (As a result, a register transfer to P3:0 or C5:4 cannot be grouped with
                         any other predicate-writing instruction.)
                     ï®   The instructions spNloop0, decbin, tlbmatch, memw_locked, memd_locked,
                         add:carry, sub:carry, sfcmp, and dfcmp cannot be grouped with another
                         instruction that sets the same predicate register.

                   NOTE      A register transfer from a predicate register to a predicate register has the
                             same auto-AND behavior as a compare instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        109
Hexagon V62 Programmer's Reference Manual                                               Conditional Execution



     6.1.4      Dot-new predicates
                The Hexagon processor can generate and use a scalar predicate in the same instruction
                packet (Section 3.3). This feature is expressed in assembly language by appending the
                suffix â.newâ to the specified predicate register. For example:
                    if (P0.new) R3 = memw(R4)

                To see how dot-new predicates are used, consider the following C statement and the
                corresponding assembly code that is generated from it by the compiler:

                C statement
                    if (R2 == 4)
                    R3 = *R4;
                    else
                    R5 = 5;

                Assembly code
                    {
                    P0 = cmp.eq(R2,#4)
                    if (P0.new) R3 = memw(R4)
                    if (!P0.new) R5 = #5
                    }

                In the assembly code a scalar predicate is generated and then consumed twice within the
                same instruction packet.

                The following conditions apply to using dot-new predicates:

                    ï®   The predicate must be generated by an instruction in the same packet. The
                        assembler normally enforces this restriction, but if the processor executes a packet
                        that violates this restriction, the execution result is undefined.
                    ï®   A single packet can contain both the dot-new and normal forms of predicates. The
                        normal form examines the old value in the predicate register, rather than the
                        newly-generated value. For example:
                          {
                              P0 = cmp.eq(R2,#4)
                              if (P0.new) R3 = memw(R4)          // use newly-generated P0 value
                              if (P0) R5 = #5                    // use previous P0 value
                          }




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    110
Hexagon V62 Programmer's Reference Manual                                                  Conditional Execution



     6.1.5      Dependency constraints
                Two instructions in an instruction packet should not write to the same destination register
                (Section 3.3.5). An exception to this rule is if the two instructions are conditional, and
                only one of them ever has the predicate expression value true when the packet is
                executed.

                For example, the following packet is valid as long as P2 and P3 never both evaluate to
                true when the packet is executed:

                    {
                          if (P2) R3 = #4             // P2, P3, or both must be false
                          if (P3) R3 = #7
                    }

                Because predicate values change at runtime, the programmer is responsible for ensuring
                that such packets are always valid during program execution. If they are invalid, the
                processor takes the following actions:

                     ï®    When writing to general registers, an error exception is raised.
                     ï®    When writing to predicate or control registers, the result is undefined.


       6.2      Vector predicates
                The predicate registers are also used for conditional vector operations. Unlike scalar
                predicates, vector predicates contain multiple truth values which are generated by vector
                predicate-generating operations.

                For example, a vector compare instruction compares each element of a vector and assigns
                the compare results to a predicate register. Each bit in the predicate vector contains a truth
                value indicating the outcome of a separate compare performed by the vector instruction.

                The vector mux instruction uses a vector predicate to selectively merge elements from two
                separate vectors into a single destination vector. This operation is useful for enabling the
                vectorization of loops with control flow (i.e., branches).

                The vector instructions that use predicates are described in the following sections.


     6.2.1      Vector compare
                A vector compare instruction inputs two 64-bit vectors, performs separate compares for
                each pair of vector elements, and generates a predicate value which contains a bit vector of
                truth values.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    111
Hexagon V62 Programmer's Reference Manual                                                                        Conditional Execution



                Figure 6-1 shows an example of a vector byte compare.


                                                                                                                  Rss


                                                                                                                  Rtt


                    cmp     cmp     cmp            cmp             cmp             cmp             cmp     cmp




                                   1       0       1       0       1       0       1       0         Pd
                                   7                                                       0

                Figure 6-1 Vector byte compare

                In Figure 6-1 two 64-bit vectors of bytes (contained in Rss and Rtt) are being compared.
                The result is assigned as a vector predicate to the destination register Pd.

                In the example vector predicate shown in Figure 6-1, note that every other compare result
                in the predicate is true (i.e., 1).

                Figure 6-2 shows how a vector halfword compare generates a vector predicate.


                                                                                                                  Rss


                                                                                                                  Rtt




                          cmp                  cmp                             cmp                        cmp




                                       1       1       0       0       1       1       0       0           Pd
                                       7                                                       0

                Figure 6-2 Vector halfword compare

                In Figure 6-2 two 64-bit vectors of halfwords are being compared. The result is assigned
                as a vector predicate to the destination register Pd.

                Because a vector halfword compare yields only four truth values, each truth value is
                encoded as two bits in the generated vector predicate.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                             112
Hexagon V62 Programmer's Reference Manual                                                Conditional Execution



     6.2.2      Vector mux instruction
                A vector mux instruction is used to conditionally select the elements from two vectors.
                The instruction takes as input two source vectors and a predicate register. For each byte in
                the vector, the corresponding bit in the predicate register is used to choose from one of the
                two input vectors. The combined result is written to the destination register.

                Figure 6-3 shows the operation of the vector mux instruction.


                                                                                            Rss


                                                                                            Rtt


                     mux     mux     mux       mux       mux     mux     mux     mux
                 P[7]    P[6]    P[5]      P[4]      P[3]    P[2]    P[1]    P[0]


                                                                                           Rdd

                Figure 6-3 Vector mux instruction

                Table 6-2 defines the vector mux instruction.

                Table 6-2    Vector mux instruction
                                    Syntax                                     Operation
                    Rdd = vmux(Ps,Rss,Rtt)                       Select bytes from Rss and Rtt


                Changing the order of the source operands in a mux instruction enables both senses of the
                result to be formed. For example:
                    R1:0 = vmux(P0,R3:2,R5:4)               // choose bytes from R3:2 if true
                    R1:0 = vmux(P0,R5:4,R3:2)               // choose bytes from R3:2 if false

                   NOTE     By replicating the predicate bits generated by word or halfword compares, the
                            vector mux instruction can be used to select words or halfwords.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     113
Hexagon V62 Programmer's Reference Manual                                               Conditional Execution



     6.2.3      Using vector conditionals
                Vector conditional support is used to vectorize loops with conditional statements.

                Consider the following C statement:
                    for (i=0; i<8; i++) {
                    if (A[i]) {
                       B[i] = C[i];
                    }
                    }

                Assuming arrays of bytes, this code can be vectorized as follows:
                    R1:0 = memd(R_A)            // R1:0 holds A[7]-A[0]
                    R3 = #0                   // clear R3:2
                    R2 = #0
                    P0 = vcmpb.eq(R1:0,R3:2)    // compare bytes in A to zero
                    R5:4 = memd(R_B)            // R5:4 holds B[7]-B[0]
                    R7:6 = memd(R_C)            // R7:6 holds C[7]-C[0]
                    R3:2 = vmux(P0,R7:6,R5:4)   // if (A[i]) B[i]=C[i]
                    memd(R_B) = R3:2            // store B[7]-B[0]




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    114
Hexagon V62 Programmer's Reference Manual                                                      Conditional Execution



       6.3      Predicate operations
                The Hexagon processor provides a set of operations for manipulating and moving
                predicate registers.

                Table 6-3 lists the predicate register instructions.

                Table 6-3     Predicate register instructions
                                  Syntax                                        Operation
                     Pd = Ps                               Transfer predicate Ps to Pd
                     Pd = Rs                               Transfer register Rs to predicate Pd
                     Rd = Ps                               Transfer predicate Ps to register Rd
                     Pd = and(Ps,[!]Pt)                    Set Pd to bitwise AND of Ps and [NOT] Pt
                     Pd = or(Ps,[!]Pt)                     Set Pd to bitwise OR of Ps and [NOT] Pt
                     Pd = and(Ps, and(Pt,[!]Pu)            Set Pd to AND of Ps and (AND of Pt and [NOT] Pu)
                     Pd = and(Ps, or(Pt,[!]Pu)             Set Pd to AND of Ps and (OR of Pt and [NOT] Pu)
                     Pd = or(Ps, and(Pt,[!]Pu)             Set Pd to OR of Ps and (AND of Pt and [NOT] Pu)
                     Pd = or(Ps, or(Pt,[!]Pu)              Set Pd to OR of Ps and (OR of Pt and [NOT] Pu)
                     Pd = not(Ps)                          Set Pd to bitwise inversion of Ps
                     Pd = xor(Ps,Pt)                       Set Pd to bitwise exclusive OR of Ps and Pt
                     Pd = any8(Ps)                         Set Pd to 0xFF if any bit in Ps is 1, 0x00 otherwise
                     Pd = all8(Ps)                         Set Pd to 0x00 if any bit in Ps is 0, 0xFF otherwise


                   NOTE      These instructions belong to instruction class CR.

                             Predicate registers can be transferred to and from the general registers either
                             individually or as register quadruples (Section 2.2.5).




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            115
         7 Program Flow


                The Hexagon processor supports the following program flow facilities:

                    ï®   Conditional instructions
                    ï®   Hardware loops
                    ï®   Software branches
                    ï®   Pauses
                    ï®   Exceptions

                Software branches include jumps, calls, and returns. Several types of jumps are supported:

                    ï®   Speculative jumps
                    ï®   Compare jumps
                    ï®   Register transfer jumps
                    ï®   Dual jumps


       7.1      Conditional instructions
                Many Hexagon processor instructions can be conditionally executed. For example:
                    if (P0) R0 = memw(R2)             // conditionally load word if P0
                    if (!P1) jump label               // conditionally jump if not P1

                The following instructions can be specified as conditional:

                    ï®   Jumps and calls
                    ï®   Many load and store instructions
                    ï®   Logical instructions (including AND/OR/XOR)
                    ï®   Shift halfword
                    ï®   32-bit add/subtract by register or short immediate
                    ï®   Sign and zero extend
                    ï®   32-bit register transfer and 64-bit combine word
                    ï®   Register transfer immediate
                    ï®   Deallocate frame and return

                For more information, see Section 5.8 and Chapter 6.


80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                 116
Hexagon V62 Programmer's Reference Manual                                                         Program Flow



       7.2      Hardware loops
                The Hexagon processor includes hardware loop instructions which can perform loop
                branches with zero overhead. For example:
                      loop0(start,#3)           // loop 3 times
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0

                Two sets of hardware loop instructions are provided â loop0 and loop1 â to enable
                hardware loops to be nested one level deep. For example:
                    // Sum the rows of a 100x200 matrix.

                      loop1(outer_start,#100)
                    outer_start:
                        R0 = #0
                        loop0(inner_start,#200)
                    inner_start:
                          R3 = memw(R1++#4)
                          { R0 = add(R0,R3) }:endloop0
                        { memw(R2++#4) = R0 }:endloop1

                The hardware loop instructions are used as follows:

                     ï®   For non-nested loops, loop0 is used.
                     ï®   For nested loops, loop0 is used for the inner loop, and loop1 for the outer loop.

                   NOTE      If a program needs to create loops nested more than one level deep, the two
                             innermost loops can be implemented as hardware loops, with the remaining
                             outer loops implemented as software branches.

                Each hardware loop is associated with a pair of dedicated loop registers:

                     ï®   The loop start address register SAn is set to the address of the first instruction in
                         the loop (which is typically expressed in assembly language as a label).
                     ï®   The loop count register LCn is set to a 32-bit unsigned value which specifies the
                         number of loop iterations to perform. When the PC reaches the end of the loop,
                         LCn is examined to determine whether the loop should repeat or exit.

                The hardware loop setup instruction sets both of these registers at once â typically there is
                no need to set them individually. However, because the loop registers completely specify
                the hardware loop state, they can be saved and restored (either automatically by a
                processor interrupt or manually by the programmer), enabling a suspended hardware loop
                to be resumed normally once its loop registers are reloaded with the saved values.

                The Hexagon processor provides two sets of loop registers for the two hardware loops:

                     ï®   SA0 and LC0 are used by loop0

                     ï®   SA1 and LC1 are used by loop1




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       117
Hexagon V62 Programmer's Reference Manual                                                         Program Flow



                Table 7-1 lists the hardware loop instructions.

                Table 7-1     Loop instructions
                         Syntax                                        Description
                 loopN(start, Rs)        Hardware loop with register loop count.
                                         Set registers SAn and LCn for hardware loop N:
                                         ï® SAn is assigned the specified start address of the loop.
                                         ï®  LCn is assigned the value of general register Rs.
                                         NOTE - The loop start operand is encoded as a PC-relative
                                         immediate value.
                 loopN(start, #count)    Hardware loop with immediate loop count.
                                         Set registers SAn and LCn for hardware loop N:
                                         ï® SAn is assigned the specified start address of the loop.
                                         ï®  LCn is assigned the specified immediate value (0-1023).
                                         NOTE - The loop start operand is encoded as a PC-relative
                                         immediate value.
                 :endloopN               Hardware loop end instruction.
                                         Performs the following operation:
                                               if (LCn > 1) {PC = SAn; LCn = LCn-1}

                                         NOTE - This instruction appears in assembly as a suffix appended to
                                         the last packet in the loop. It is encoded in the last packet.
                 SAn = Rs                Set loop start address to general register Rs
                 LCn = Rs                Set loop count to general register Rs


                   NOTE      The loop instructions are assigned to instruction class CR.


     7.2.1      Loop setup
                To set up a hardware loop, the loop registers SAn and LCn must be set to the proper values.
                This can be done in two ways:

                     ï®   A loopN instruction
                     ï®   Register transfers to SAn and LCn

                The loopN instruction performs all the work of setting SAn and LCn. For example:
                      loop0(start,#3)           // SA0=&start, LC0=3
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0

                In this example the hardware loop (consisting of a single multiply instruction) is executed
                three times. The loop0 instruction sets register SA0 to the address value of label start,
                and LC0 to 3.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          118
Hexagon V62 Programmer's Reference Manual                                                       Program Flow



                Loop counts are limited to the range 0-1023 when they are expressed as immediate values
                in loopN. If the desired loop count exceeds this range, it must be specified as a register
                value. For example:

                Using loopN:
                      R1 = #20000;
                      loop0(start,R1)          // LC0=20000, SA0=&start
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0

                Using register transfers:
                      R1 = #20000
                      LC0 = R1                 // LC0=20000
                      R1 = #start
                      SA0 = R1                 // SA0=&start
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0

                If a loopN instruction is located too far from its loop start address, the PC-relative offset
                value that is used to specify the start address can exceed the maximum range of the
                instructionâs start-address operand. If this occurs, either move the loopN instruction closer
                to the loop start, or specify the loop start address as a 32-bit constant (Section 10.9). For
                example:

                Using 32-bit constants:
                      R1 = #20000;
                      loop0(##start,R1)                 // LC0=20000, SA0=&start
                      ...



     7.2.2      Loop end
                The loop end instruction indicates the last packet in a hardware loop. It is expressed in
                assembly language by appending the packet with the symbol â:endloopNâ, where N
                specifies the hardware loop (0 or 1). For example:
                      loop0(start,#3)
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0              // last packet in loop

                The last instruction in the loop must always be expressed in assembly language as a packet
                (using curly braces), even if it is the only instruction in the packet.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       119
Hexagon V62 Programmer's Reference Manual                                                         Program Flow



                Nested hardware loops can specify the same instruction as the end of both the inner and
                outer loops. For example:
                    // Sum the rows of a 100x200 matrix.
                    // Software pipeline the outer loop.

                         p0 = cmp.gt(R0,R0)              // p0 = false
                         loop1(outer_start,#100)
                    outer_start:
                         { if (p0) memw(R2++#4) = R0
                           p0 = cmp.eq(R0,R0)            // p0 = true
                           R0 = #0
                           loop0(inner_start,#200) }
                    inner_start:
                         R3 = memw(R1++#4)
                         { R0 = add(R0,R3) }:endloop0:endloop1
                         memw(R2++#4) = R0

                Though endloopN behaves like a regular instruction (by implementing the loop test and
                branch), note that it does not execute in any instruction slot, and does not count as an
                instruction in the packet. Therefore a single instruction packet which is marked as a loop
                end can perform up to six operations:

                     ï®   Four regular instructions (the normal limit for an instruction packet)
                     ï®   The endloop0 test and branch
                     ï®   The endloop1 test and branch

                   NOTE      The endloopN instruction is encoded in the instruction packet (Section 10.6).


     7.2.3      Loop execution
                After a hardware loop is set up, the loop body always executes at least once regardless of
                the specified loop count (because the loop count is not examined until the last instruction
                in the loop). Therefore, if a loop needs to be optionally executed zero times, it must be
                preceded with an explicit conditional branch. For example:
                      loop0(start,R1)
                      P0 = cmp.eq(R1,#0)
                      if (P0) jump skip
                    start:
                        { R0 = mpyi(R0,R0) } :endloop0
                    skip:

                In this example a hardware loop is set up with the loop count in R1, but if the value in R1
                is zero a software branch skips over the loop body.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      120
Hexagon V62 Programmer's Reference Manual                                                      Program Flow



                After the loop end instruction of a hardware loop is executed, the Hexagon processor
                examines the value in the corresponding loop count register:

                    ï®   If the value is greater than 1, the processor decrements the loop count register and
                        performs a zero-cycle branch to the loop start address.
                    ï®   If the value is less than or equal to 1, the processor resumes program execution at
                        the instruction immediately following the loop end instruction.

                   NOTE     Because nested hardware loops can share the same loop end instruction, the
                            processor may examine both loop count registers in a single operation.


     7.2.4      Pipelined hardware loops
                Software pipelined loops are common for VLIW architectures such as the Hexagon
                processor. They offer increased code performance in loops by overlapping multiple loop
                iterations.

                A software pipeline has three sections:

                    ï®   A prologue in which the loop is primed
                    ï®   A kernel (or steady-state) portion
                    ï®   An epilogue which drains the pipeline

                This is best illustrated with a simple example, as shown in Table 7-2.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    121
Hexagon V62 Programmer's Reference Manual                                                      Program Flow



                Table 7-2      Software pipelined loop


                    int foo(int *A, int *result)
                    {
                        int i;
                        for (i=0;i<100;i++) {
                            result[i]= A[i]*A[i];
                        }
                    }



                    foo:
                    {            R3 = R1
                                 loop0(.kernel,#98)               // Decrease loop count by 2
                    }
                                 R1 = memw(R0++#4)                // 1st prologue stage
                    {            R1 = memw(R0++#4)                // 2nd prologue stage
                                 R2 = mpyi(R1,R1)
                    }
                            .falign
                    .kernel:
                    {       R1 = memw(R0++#4)                     // kernel
                            R2 = mpyi(R1,R1)
                            memw(R3++#4) = R2
                    }:endloop0
                    {       R2 = mpyi(R1,R1)                      // 1st epilogue stage
                            memw(R3++#4) = R2
                    }
                            memw(R3++#4) = R2                     // 2nd epilogue stage
                            jumpr lr



                In Table 7-2 the kernel section of the pipelined loop performs three iterations of the loop
                in parallel:

                     ï®    The load for iteration N+2
                     ï®    The multiply for iteration N+1
                     ï®    The store for iteration N

                One drawback to software pipelining is the extra code necessary for the prologue and
                epilogue sections of a pipelined loop.

                To address this issue the Hexagon processor provides the spNloop0 instruction, where the
                âNâ in the instruction name indicates a digit in the range 1-3. For example:
                         P3 = sp2loop0(start,#10)            // Set up pipelined loop




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    122
Hexagon V62 Programmer's Reference Manual                                                         Program Flow



                spNloop0 is a variant of the loop0 instruction: it sets up a normal hardware loop using
                SA0 and LC0, but also performs the following additional operations:

                     ï®   When the spNloop0 instruction is executed, it assigns the truth value false to the
                         predicate register P3.
                     ï®   After the associated loop has executed N times, P3 is automatically set to true.

                This feature (which is known as automatic predicate control) enables the store instructions
                in the kernel section of a pipelined loop to be conditionally executed by P3 and thus â
                because of the way spNloop0 controls P3 â not be executed during the pipeline warm-up.
                This can reduce the code size of many software pipelined loops by eliminating the need
                for prologue code.

                spNloop0 cannot be used to eliminate the epilogue code from a pipelined loop; however,
                in some cases it is possible to do this through the use of programming techniques.

                Typically, the issue affecting the removal of epilogue code is load safety. If the kernel
                section of a pipelined loop can safely access past the end of its arrays â either because it is
                known to be safe, or because the arrays have been padded at the end â then epilogue code
                is unnecessary. However, if load safety cannot be ensured, then explicit epilogue code is
                required to drain the software pipeline.

                Table 7-3 shows how spNloop0 and load safety simplify the code shown in Table 7-2.

                Table 7-3     Software pipelined loop (using spNloop0)


                     int foo(int *A, int *result)
                     {
                         int i;
                         for (i=0;i<100;i++) {
                             result[i]= A[i]*A[i];
                         }
                     }



                     foo:
                     { // load safety assumed
                             P3 = sp2loop0(.kernel,#102)                  // set up pipelined loop
                             R3 = R1
                     }
                     .falign
                     .kernel:
                     {       R1 = memw(R0++#4)                            // kernel
                             R2 = mpyi(R1,R1)
                             if (P3) memw(R3++#4) = R2
                     }:endloop0

                                jumpr lr



                   NOTE      The count value that spNloop0 uses to control the P3 setting is stored in the
                             user status register USR.LPCFG.



80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      123
Hexagon V62 Programmer's Reference Manual                                                           Program Flow



     7.2.5      Loop restrictions
                Hardware loops have the following restrictions:

                     ï®   The loop setup packet in loopN or spNloop0 (Section 7.2.4) cannot contain a
                         speculative indirect jump, new-value compare jump, or dealloc_return.
                     ï®   The last packet in a hardware loop cannot contain any program flow instructions
                         (including jumps or calls).
                     ï®   The loop end packet in loop0 cannot contain any instruction that changes SA0 or
                         LC0. Similarly, the loop end packet in loop1 cannot contain any instruction that
                         changes SA1 or LC1.
                     ï®   The loop end packet in spNloop0 cannot contain any instruction that changes P3.

                   NOTE       SA1 and LC1 can be changed at the end of loop0, while SA0 and LC0 can be
                              changed at the end of loop1.


       7.3      Software branches
                Unlike hardware loops, software branches use an explicit instruction to perform a branch
                operation. Software branches include the following instructions:

                     ï®   Jumps
                     ï®   Calls
                     ï®   Returns

                The target address for branch instructions can be specified as register indirect or PC-
                relative offsets. PC-relative offsets are normally less than 32 bits, but can be specified as
                32 bits by using the appropriate syntax in the target operand (Section 7.3.4).

                Branch instructions can be unconditional or conditional, with the execution of conditional
                instructions controlled by a predicate expression.

                Table 7-4 summarizes the software branch instructions.

                Table 7-4      Software branch instructions
                            Syntax                                        Operation
                 [if (pred_expr)] jump label   Branch to address specified by register Rs or PC-relative offset.
                 [if (pred_expr)] jumpr Rs     Can be conditionally executed.

                 [if (pred_expr)] call label   Branch to address specified by register Rs or PC-relative offset.
                 [if (pred_expr)] callr Rs     Store subroutine return address in link register LR.
                                               Can be conditionally executed.
                 [if (pred_expr)] jumpr LR     Branch to subroutine return address contained in link register LR.
                                               Can be conditionally executed.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         124
Hexagon V62 Programmer's Reference Manual                                                              Program Flow



     7.3.1      Jumps
                Jump instructions change the program flow to a target address which can be specified by
                either a register or a PC-relative immediate value. Jump instructions can be conditional
                based on the value of a predicate expression.

                Table 7-5 lists the jump instructions.

                Table 7-5      Jump instructions
                         Syntax                                        Operation
                 jump label              Direct jump.
                                         Branch to address specified by label.
                                         Label is encoded as PC-relative signed immediate value.
                 jumpr Rs                Indirect jump.
                                         Branch to address contained in general register Rs.
                 if ([!]Ps) jump label   Conditional jump.
                 if ([!]Ps) jumpr Rs     Perform jump if predicate expression evaluates to true.


                   NOTE       Conditional jumps can be specified as speculative (Section 7.4).


     7.3.2      Calls
                Call instructions are used to jump to subroutines. The instruction performs a jump to the
                target address and also stores the return address in the link register LR.

                The forms of call are functionally similar to jump instructions and include both PC-
                relative and register indirect in both unconditional and conditional forms.

                Table 7-6 lists the call instructions.

                Table 7-6      Call instructions
                        Syntax                                           Operation
                 call label              Direct subroutine call.
                                         Branch to address specified by label, and store return address in register
                                         LR. Label is encoded as PC-relative signed immediate value.
                 callr Rs                Indirect subroutine call.
                                         Branch to address contained in general register Rs, and store return
                                         address in register LR.
                 if ([!]Ps) call label   Conditional call.
                 if ([!]Ps) callr Rs     If predicate expression evaluates to true, perform subroutine call to
                                         specified target address.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           125
Hexagon V62 Programmer's Reference Manual                                                           Program Flow



     7.3.3      Returns
                Return instructions are used to return from a subroutine. The instruction performs an
                indirect jump to the subroutine return address stored in link register LR.

                Returns are implemented as jump register indirect instructions, and support both
                unconditional and conditional forms.

                Table 7-7 lists the return instructions.

                Table 7-7     Return instructions
                              Syntax                                       Operation
                  jumpr LR                        Subroutine return.
                                                  Branch to subroutine return address contained in link register
                                                  LR.
                 if ([!]Ps) jumpr LR              Conditional subroutine return.
                                                  If predicate expression evaluates to true, perform subroutine
                                                  return to specified target address.
                 dealloc_return                   Subroutine return with stack frame deallocate.
                                                  Perform deallocframe operation (Section 8.5) and then
                                                  perform subroutine return to the target address loaded by
                                                  deallocframe from the link register.
                 if ([!]Ps) dealloc_return        Conditional subroutine return with stack frame deallocate.
                                                  If predicate expression evaluates to true, perform
                                                  deallocframe and then subroutine return to the target
                                                  address loaded by deallocframe from the link register.


                   NOTE      The link register LR is an alias of general register R31. Therefore subroutine
                             returns can be performed with the instruction jumpr R31.

                             The conditional subroutine returns (including dealloc_return) can be
                             specified as speculative (Section 7.4).




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         126
Hexagon V62 Programmer's Reference Manual                                                         Program Flow



     7.3.4      Extended branches
                When a jump or call instruction specifies a PC-relative offset as the branch target, the
                offset value is normally encoded in significantly less than 32 bits. This can limit the ability
                for programs to specify âlongâ branches which span a large range of the processorâs
                memory address space.

                To support long branches, the jump and call instructions have special versions which
                encode a full 32-bit value as the PC-relative offset.

                   NOTE      Such instructions use an extra word to store the 32-bit offset (Section 10.9).

                The size of a PC-relative branch offset is expressed in assembly language by optionally
                prefixing the target label with the symbol â##â or â#â:

                     ï®   â##â specifies that the assembler must use a 32-bit offset
                     ï®   â#â specifies that the assembler must not use a 32-bit offset
                     ï®   No â#â specifies that the assembler use a 32-bit offset only if necessary

                For example:
                    jump ##label        // 32-bit offset
                    call #label         // non 32-bit offset
                    jump label          // offset size determined by assembler



     7.3.5      Branches to and from packets
                Instruction packets are atomic: even if they contain multiple instructions, they can be
                referenced only by the address of the first instruction in the packet. Therefore, branches to
                a packet can target only the packetâs first instruction.

                Packets can contain up to two branches (Section 7.7). The branch destination can target
                the current packet or the beginning of another packet.

                A branch does not interrupt the execution of the current packet: all the instructions in the
                packet are executed, even if they appear in the assembly source after the branch
                instruction.

                If a packet is at the end of a hardware loop, it cannot contain a branch instruction.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      127
Hexagon V62 Programmer's Reference Manual                                                              Program Flow



       7.4      Speculative jumps
                Conditional instructions normally depend on predicates that are generated in a previous
                instruction packet. However, dot-new predicates (Section 6.1.4) enable conditional
                instructions to use a predicate generated in the same packet that contains the conditional
                instruction.

                When dot-new predicates are used with a conditional jump, the resulting instruction is
                called a speculative jump. For example:
                    {
                          P0 = cmp.eq(R9,#16)                  // single-packet compare-and-jump
                          IF (P0.new) jumpr:t R11              // ... enabled by use of P0.new
                    }

                Speculative jumps require the programmer to specify a direction hint in the jump
                instruction, which indicates whether the conditional jump is expected to be taken or not.

                The hint is used to initialize the Hexagon processorâs dynamic branch predictor. Whenever
                the predictor is wrong, the speculative jump instruction takes two cycles to execute instead
                of one (due to a pipeline stall).

                Hints can improve program performance by indicating how speculative jumps are
                expected to execute over the course of a program: the more often the specified hint
                indicates how the instruction actually executes, the better the performance.

                Hints are expressed in assembly language by appending the suffix â:tâ or â:ntâ to the
                jump instruction symbol. For example:

                     ï®    jump:t â The jump instruction will most often be taken

                     ï®    jump:nt â The jump instruction will most often be not taken

                In addition to dot-new predicates, speculative jumps also accept conditional arithmetic
                expressions (=0, !=0, >=0, <=0) involving the general register Rs.

                Table 7-8 lists the speculative jump instructions.

                Table 7-8      Speculative jump instructions
                              Syntax                                         Operation
                 if ([!]Ps.new) jump:t label      Speculative direct jump.
                 if ([!]Ps.new) jump:nt label     If predicate expression evaluates to true, jump to address
                                                  specified by label.
                 if ([!]Ps.new) jumpr:t Rs        Speculative indirect jump.
                 if ([!]Ps.new) jumpr:nt Rs       If predicate expression evaluates to true, jump to address in
                                                  register Rs.
                 if (Rs == #0) jump:t label       Speculative direct jump.
                 if (Rs == #0) jump:nt label      If predicate Rs = 0 is true, jump to address specified by label.
                 if (Rs != #0) jump:t label       Speculative direct jump.
                 if (Rs != #0) jump:nt label      If predicate Rs != 0 is true, jump to address specified by label.




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                              128
Hexagon V62 Programmer's Reference Manual                                                          Program Flow



                Table 7-8     Speculative jump instructions (Continued)
                             Syntax                                        Operation
                 if (Rs >= #0) jump:t label     Speculative direct jump.
                 if (Rs >= #0) jump:nt label    If predicate Rs >= 0 is true, jump to address specified by
                                                label.
                 if (Rs <= #0) jump:t label     Speculative direct jump.
                 if (Rs <= #0) jump:nt label    If predicate Rs <= 0 is true, jump to address specified by
                                                label.


                   NOTE      The hints :t and :nt interact with the predicate value to determine the
                             instruction cycle count.

                             Speculative indirect jumps are not supported with register Rs predicates.


       7.5      Compare jumps
                To reduce code size the Hexagon processor supports a compound instruction which
                combines a compare with a speculative jump in a single 32-bit instruction.

                For example:
                    {
                    p0 = cmp.eq (R2,R5)                     // single-instr compare-and-jump
                    if (p0.new) jump:nt target              // enabled by compound instr
                    }

                The register operands used in a compare jump are limited to R0-R7 or R16-R23
                (Table 10-3).

                The compare and jump instructions that can be used in a compare jump are limited to the
                instructions listed in Table 7-9. The compare can use predicate P0 or P1, while the jump
                must specify the same predicate that is set in the compare.

                A compare jump instruction is expressed in assembly source as two independent compare
                and jump instructions in a packet. The assembler translates the two instructions into a
                single compound instruction.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        129
Hexagon V62 Programmer's Reference Manual                                                   Program Flow




                Table 7-9    Compare jump instructions
                        Compare Instruction                 Jump Instruction
                 Pd = cmp.eq (Rs, Rt)              IF (Pd.new) jump:t label
                 Pd = cmp.gt (Rs, Rt)              IF (Pd.new) jump:nt label
                 Pd = cmp.gtu (Rs, Rt)             IF (!Pd.new) jump:t label
                 Pd = cmp.eq (Rs,#U5)              IF (!Pd.new) jump:nt label
                 Pd = cmp.gt (Rs,#U5)
                 Pd = cmp.gtu (Rs,#U5)
                 Pd = cmp.eq (Rs,#-1)
                 Pd = cmp.gt (Rs,#-1)
                 Pd = tstbit (Rs, #0)



     7.5.1      New-value compare jumps
                A compare jump instruction can access a register that is assigned a new value in the same
                instruction packet (Section 3.3). This feature is expressed in assembly language by the
                following changes:

                    ï®    Appending the suffix â.newâ to the new-value register in the compare
                    ï®    Rewriting the compare jump so its constituent compare and jump operations
                         appear as a single conditional instruction

                For example:
                    // load-compare-and-jump packet enabled by new-value compare jump

                    {
                    R0 = memw(R2+#8)
                    if (cmp.eq(R0.new,#0)) jump:nt target
                    }

                New-value compare jump instructions have the following restrictions:




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                 130
Hexagon V62 Programmer's Reference Manual                                                          Program Flow



                     ï®   They are limited to the instruction forms listed in Table 7-10.
                     ï®   They cannot be combined with another jump instruction in the same packet.
                     ï®   If an instruction produces a 64-bit result or performs a floating-point operation
                         (Section 1.3.4), its result registers cannot be used as the new-value register.
                     ï®   If an instruction uses auto-increment or absolute-set addressing mode
                         (Section 5.7), its address register cannot be used as the new-value register.
                     ï®   If the instruction that sets a new-value register is conditional (Section 6.1.2), it
                         must always be executed.

                If the specified jump direction hint is wrong (Section 7.4), a new-value compare jump
                takes three cycles to execute instead of one. While this penalty is one cycle longer than in
                a regular speculative jump, the overall performance is still better than using a regular
                speculative jump (which must execute an extra packet in all cases).

                   NOTE       New-value compare jump instructions are assigned to instruction class NV,
                              which can execute only in Slot 0. The instruction that assigns the new value
                              must execute in Slot 1, 2, or 3.



                Table 7-10 New-value compare jump instructions
                 if ([!]cmp.eq (Rs.new, Rt)) jump:[hint] label
                 if ([!]cmp.gt (Rs.new, Rt)) jump:[hint] label
                 if ([!]cmp.gtu (Rs.new, Rt)) jump:[hint] label

                 if ([!]cmp.gt (Rs, Rt.new)) jump:[hint] label
                 if ([!]cmp.gtu (Rs, Rt.new)) jump:[hint] label
                 if ([!]cmp.eq (Rs.new, #u5)) jump:[hint] label
                 if ([!]cmp.gt (Rs.new, #u5)) jump:[hint] label
                 if ([!]cmp.gtu (Rs.new ,#u5)) jump:[hint] label

                 if ([!]cmp.eq (Rs.new, #-1)) jump:[hint] label
                 if ([!]cmp.gt (Rs.new, #-1)) jump:[hint] label

                 if ([!]tstbit (Rs.new, #0)) jump:[hint] label



       7.6      Register transfer jumps
                To reduce code size the Hexagon processor supports a compound instruction which
                combines a register transfer with an unconditional jump in a single 32-bit instruction.

                For example:
                    {
                    jump target            // jump to label âtargetâ
                    R1 = R2                // assign contents of reg R2 to R1
                    }




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           131
Hexagon V62 Programmer's Reference Manual                                                               Program Flow



                The source and target register operands in the register transfer are limited to R0-R7 or
                R16-R23 (Table 10-3).

                The target address in the jump is a scaled 9-bit PC-relative address value (as opposed to
                the 22-bit value in the regular unconditional jump instruction).

                A register transfer jump instruction is expressed in assembly source as two independent
                instructions in a packet. The assembler translates the instructions into a single compound
                instruction.

                Table 7-11 lists the register transfer jump instructions.

                Table 7-11         Register transfer jump instructions
                         Syntax                                          Operation
                 jump label; Rd=Rs          Register transfer jump.

                                            Perform register transfer and branch to address specified by label.
                                            Label is encoded as PC-relative 9-bit signed immediate value.
                 jump label; Rd=#u6         Register transfer immediate jump.

                                            Perform register transfer (of 6-bit unsigned immediate value) and
                                            branch to address specified by label.
                                            Label is encoded as PC-relative 9-bit signed immediate value.




       7.7      Dual jumps
                Two software branch instructions (referred to here as âjumpsâ) can appear in the same
                instruction packet, under the conditions listed in Table 7-12.

                The first jump is defined as the jump instruction at the lower address, and the second jump
                as the jump instruction at the higher address.

                Unlike most packetized operations, dual jumps are not executed in parallel (Section 3.3.1).
                Instead, the two jumps are processed in a well-defined order in a packet:

                    1. The predicate in the first jump is evaluated.
                    2. If the first jump is taken, the second jump is ignored.
                    3. If the first jump is not taken, the second jump is performed.


                Table 7-12 Dual jump instructions
                                                                                        First jump    Second jump
                              Instruction                       Description
                                                                                        in packet?     in packet?
                 jump                                   Direct jump                         No              Yes
                 if ([!]Ps[.new]) jump                  Conditional jump                   Yes              Yes
                 call                                   Direct calls                        No              Yes
                 if ([!]Ps) call
                 Pd=cmp.xx ; if ([!]Pd.new) jump        Compare jump                       Yes              Yes




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            132
Hexagon V62 Programmer's Reference Manual                                                             Program Flow



                Table 7-12 Dual jump instructions
                                                                                       First jump    Second jump
                              Instruction                       Description
                                                                                       in packet?     in packet?
                 if ([!]cmp.xx(Rs.new, Rt)) jump         New-value compare jump            No             No
                 jumpr                                   Indirect jumps                    No             No
                 if ([!]Ps[.new]) jumpr                  Indirect calls
                 callr                                   dealloc_return
                 if ([!]Ps) callr
                 dealloc_return
                 if ([!]Ps[.new]) dealloc_return
                 endloopN                                Hardware loop end                 No             No


                   NOTE        If a call is ignored in a dual jump, the link register LR is not changed.


       7.8      Hint indirect jump target
                Because it obtains the jump target address from a register, the jumpr instruction
                (Section 7.3.1) normally causes the processor to stall for one cycle.

                To avoid the stall penalty caused by a jumpr instruction, the Hexagon processor supports
                the jump hint instruction hintjr, which can be specified before the jumpr instruction.

                The hintjr instruction indicates that the program is about to execute a jumpr to the
                address contained in the specified register.

                Table 7-13 lists the speculative jump instructions.

                Table 7-13 Jump hint instruction
                              Syntax                                          Operation
                 hintjr(Rs)                        Inform processor that jumpr(Rs) instruction is about to be
                                                   performed.


                   NOTE        In order to prevent a stall, the hintjr instruction must be executed at least 2
                               packets before the corresponding jumpr instruction.

                               The hintjr instruction is not needed for jumpr instructions used as returns
                               (Section 7.3.3), because in this case the Hexagon processor automatically
                               predicts the jump targets based on the most recent nested call instructions.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           133
Hexagon V62 Programmer's Reference Manual                                                      Program Flow



       7.9      Pauses
                Pauses suspend the execution of a program for a period of time, and put it into low-power
                mode. The program remains suspended for the duration specified in the instruction.

                The pause instruction accepts an unsigned 8-bit immediate operand which specifies the
                pause duration in terms of cycles. The maximum possible duration is 263 cycles (255+8).

                Hexagon processor interrupts cause a program to exit the paused state before its specified
                duration has elapsed.

                The pause instruction is useful for implementing user-level low-power synchronization
                operations (such as spin locks).

                Table 7-14 lists the pause instruction.

                Table 7-14 Pause instruction
                          Syntax                                     Operation
                 pause(#u8)                 Suspend program in low-power mode for specified cycle
                                            duration.




     7.10       Exceptions
                Exceptions are internally-generated disruptions to the program flow.

                The Hexagon processor OS handles fatal exceptions by terminating the execution of the
                application system. The user is responsible for fixing the problem and recompiling their
                applications.

                The error messages generated by exceptions include the following information to assist in
                locating the problem:

                     ï®   Cause code â Hexadecimal value indicating the type of exception that occurred
                     ï®   User IP â PC value indicating the instruction executed when exception occurred
                     ï®   Bad VA â Virtual address indicating the data accessed when exception occurred

                   NOTE     The cause code, user IP, and Bad VA values are stored in the Hexagon
                            processor system control registers SSR[7:0], ELR, and BADVA respectively.

                If multiple exceptions occur simultaneously, the exception with the lowest error code
                value has the highest exception priority.

                If a packet contains multiple loads, or a load and a store, and both operations have an
                exception of any type, then all Slot 1 exceptions are processed before any Slot 0 exception
                is processed.

                   NOTE     The exceptions defined for processor versions V60 and V61 are identical,
                            with one exception: V61 defines an additional event (with cause code 0x27)
                            to indicate stack overflow.


80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   134
Hexagon V62 Programmer's Reference Manual                                                        Program Flow



                Table 7-15 lists the exceptions for the V60 and V61 processor versions.

                Table 7-15 V60/61 exceptions
                 Cause
                            Event Type                  Event Description                       Notes
                 Code
                   0x0    Reset           Software thread reset.                          Non-maskable,
                                                                                          Highest Priority
                  0x01    Precise,      Unrecoverable BIU error (bus error, timeout, L2 Non-maskable
                          Unrecoverable parity error, etc.).
                  0x03    Precise,      Double exception (exception occurs while          Non-maskable
                          Unrecoverable SSR[EX]=1).
                  0x11    Precise         Privilege violation: User/Guest mode execute to Non-maskable
                                          page with no execute permissions (X=0).
                  0x12    Precise         Privilege violation: User mode execute to a     Non-maskable
                                          page with no user permissions (X=1, U=0).
                  0x15    Precise         Invalid packet.                                 Non-maskable
                  0x16    Precise         Illegal Execution of Coprocessor Instruction.   Non-maskable
                  0x1A    Precise         Privilege violation: Executing a guest mode     Non-maskable
                                          instruction in user mode.
                  0x1B    Precise         Privilege violation: Executing a supervisor     Non-maskable
                                          instruction in user/guest mode.
                  0x1D    Precise,      Packet with multiple writes to the same           Non-maskable
                          Unrecoverable destination register.
                  0x1E    Precise,      Program counter values that are not properly      Non-maskable
                          Unrecoverable aligned.
                  0x20    Precise         Load to misaligned address.                     Non-maskable
                  0x21    Precise         Store to misaligned address.                    Non-maskable
                  0x22    Precise         Privilege violation: User/Guest mode Read to    Non-maskable
                                          page with no read permission (R=0).
                  0x23    Precise         Privilege violation: User/Guest mode Write to   Non-maskable
                                          page with no write permissions (W=0).
                  0x24    Precise         Privilege violation: User mode Read to page     Non-maskable
                                          with no user permission (R=1, U=0).
                  0x25    Precise         Privilege violation: User mode Write to page    Non-maskable
                                          with no user permissions (W=1, U=0).
                  0x26    Precise         Coprocessor VMEM address error.                 Non-maskable
                  0x27    Precise         Stack overflow: Allocframe instruction exceeded Non-maskable,
                                          FRAMELIMIT.                                     V61 and greater
                  0x42    Imprecise       Data abort.                                     Non-maskable
                  0x43    Imprecise       NMI.                                            Non-maskable
                  0x44    Imprecise       Multiple TLB match.                             Non-maskable
                  0x45    Imprecise       Livelock exception.                             Non-maskable
                  0x60    TLB miss-X      Due to missing Fetch address on PC-page.        Non-maskable




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        135
Hexagon V62 Programmer's Reference Manual                                                            Program Flow



                Table 7-15 V60/61 exceptions (Continued)
                 Cause
                           Event Type                    Event Description                          Notes
                 Code
                  0x61    TLB miss-X       Due to missing Fetch on second page from           Non-maskable
                                           packet that spans pages.
                  0x62    TLB miss-X       Due to icinva.                                     Non-maskable
                          Reserved
                  0x70    TLB miss-RW      Due to memory read.                                Non-maskable
                  0x71    TLB miss-RW      Due to memory write.                               Non-maskable
                          Reserved
                  #u8     Trap0            Software Trap0 instruction.                        Non-maskable
                  #u8     Trap1            Software Trap1 instruction.                        Non-maskable
                          Reserved
                  0x80    Debug            Single-step debug exception.
                          Reserved
                  0xBF    Floating-Point   Execution of Floating-Point instruction resulted   Non-maskable
                                           in exception.
                  0xC0    Interrupt0       General external interrupt.                        Maskable, highest
                                                                                              priority general
                                                                                              interrupt
                  0xC1    Interrupt 1      General external interrupt                         Maskable
                  0xC2    Interrupt 2
                  0xC3    Interrupt 3
                  0xC4    Interrupt 4
                  0xC5    Interrupt 5
                  0xC6    Interrupt 6
                  0xC7    Interrupt 7
                  0xC8    Interrupt 8
                  0xC9    Interrupt 9
                  0xCA    Interrupt 10
                  0xCB    Interrupt 11
                  0xCC    Interrupt 12
                  0xCD    Interrupt 13




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             136
Hexagon V62 Programmer's Reference Manual                                                      Program Flow



                Table 7-15 V60/61 exceptions (Continued)
                 Cause
                           Event Type                  Event Description                      Notes
                 Code
                  0xCE    Interrupt 14   General external interrupt                     Maskable
                  0xCF    Interrupt 15
                  0xD0    Interrupt 16
                  0xD1    Interrupt 17
                  0xD2    Interrupt 18
                  0xD3    Interrupt 19
                  0xD4    Interrupt 20
                  0xD5    Interrupt 21
                  0xD6    Interrupt 22
                  0xD7    Interrupt 23
                  0xD8    Interrupt 24
                  0xD9    Interrupt 25
                  0xDA    Interrupt 26
                  0xDB    Interrupt 27
                  0xDC    Interrupt 28
                  0xDD    Interrupt 29
                  0xDE    Interrupt 30   General external interrupt.                    Maskable, lowest
                                                                                        priority internal
                                                                                        interrupt
                  0xDF    Interrupt 31   General external interrupt.                    Maskable, lowest
                                                                                        priority interrupt
                                                                                        reserved for L2
                                                                                        Vectored Interrupt




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        137
         8 Software Stack


                The Hexagon processor includes dedicated registers and instructions to support a call
                stack for subroutine execution.

                The stack structure follows standard C conventions.


       8.1      Stack structure
                The stack is defined to grow from high addresses to low addresses. The stack pointer
                register SP points to the data element that is currently on the top of the stack.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   138
Hexagon V62 Programmer's Reference Manual                                                      Software Stack



                Figure 8-1 shows the stack structure.

                                               Stack in Memory

                                                   Saved LR
                                                   Saved FP




                  Higher Address
                                                Procedure Local
                                                Data on Stack

                                                                                 Stack frame



                                                   Saved LR
                                                   Saved FP                             FP register



                                                Procedure Local
                                                Data on Stack

                                                                                        SP register
                 Lower Address




                                               Unallocated Stack




                Figure 8-1 Stack structure

                   NOTE     The Hexagon processor supports three dedicated stack instructions:
                            allocframe, deallocframe, and dealloc_return (Section 8.5).

                            The SP address must always remain 8-byte aligned for the stack instructions
                            to work properly.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    139
Hexagon V62 Programmer's Reference Manual                                                      Software Stack



       8.2      Stack frames
                The stack is used to store stack frames, which are data structures that store state
                information on the active subroutines in a program (i.e., those that were called but have
                not yet returned). Each stack frame corresponds to an active subroutine in the program.

                A stack frame contains the following elements:

                     ï®   The local variables and data used by the subroutine
                     ï®   The return address for the subroutine call (pushed from the link register LR)
                     ï®   The address of the previous stack frame allocated on the stack (pushed from the
                         frame pointer register FP)

                The frame pointer register FP always contains the address of the saved frame pointer in
                the current stack frame. It facilitates debugging by enabling a debugger to examine the
                stack in memory and easily determine the call sequence, function parameters, etc.

                   NOTE      For leaf functions it is often unnecessary to save FP and LR. In this case FP
                             contains the frame pointer of the calling function, not the current function.


       8.3      Stack protection
                The Hexagon V6x processor supports the following features to protect the integrity of the
                software stack:

                     ï®   Stack bounds checking
                     ï®   Stack smashing protection


     8.3.1      Stack bounds checking
                Stack bounds checking prevents a stack frame from being allocated past the lower
                boundary of the software stack.

                FRAMELIMIT is a 32-bit control register which stores a memory address that specifies the
                lower bound of the memory area reserved for the software stack. When the allocframe
                instruction allocates a new stack frame, it compares the new stack pointer value in SP with
                the stack bound value in FRAMELIMIT. If SP is less than FRAMELIMIT, the Hexagon
                processor raises exception 0x27 (Section 7.10).

                   NOTE      Stack bounds checking is performed when the processor is in user and guest
                             modes, but not in monitor mode.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        140
Hexagon V62 Programmer's Reference Manual                                                             Software Stack



     8.3.2      Stack smashing protection
                Stack smashing is a technique used by malicious code to gain control over an executing
                program. Malicious code causes buffer overflows to occur in a procedureâs local data, with
                the goal of modifying the subroutine return address stored in a stack frame so it points to
                the malicious code instead of the intended return code.

                Stack smashing protection prevents this from happening by scrambling the subroutine
                return address whenever a new stack frame is allocated, and then unscrambling the return
                address when the frame is deallocated. Because the value in FRAMEKEY changes regularly
                and varies from device to device, it becomes difficult to pre-calculate a malicious return
                address.

                FRAMEKEY is a 32-bit control register which is used to scramble return addresses stored on
                the stack:

                     ï®    In the allocframe instruction, the 32-bit return address in link register LR is
                          XOR-scrambled with the value in FRAMEKEY before it is stored in the new stack
                          frame.
                     ï®    In deallocframe and dealloc_return, the return address loaded from the stack
                          frame is unscrambled with the value in FRAMEKEY before it is stored in LR.

                After a processor reset, the default value of FRAMEKEY is 0. If this value is not changed,
                stack smashing protection is effectively disabled.

                   NOTE       Each hardware thread has its own instance of the FRAMEKEY register.


       8.4      Stack registers
                Table 8-1 lists the stack registers.


                Table 8-1     Stack registers
                   Register               Name                           Description                        Alias
                         SP       Stack pointer          Points to topmost stack element in memory          R29
                         FP       Frame pointer          Points to previous stack frame on stack            R30
                         LR       Link register          Contains return address of subroutine call         R31
                 FRAMELIMIT       Frame limit register   Contains lowest address of stack area              C16
                  FRAMEKEY        Frame key register     Contains scrambling key for return addresses       C17


                   NOTE       SP, FP, and LR are aliases of three general registers (Section 2.1). These
                              general registers are conventionally dedicated for use as stack registers.




80-N2040-36 B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            141
Hexagon V62 Programmer's Reference Manual                                                               Software Stack



       8.5      Stack instructions
                The Hexagon processor includes the instructions allocframe and deallocframe to
                efficiently allocate and deallocate stack frames on the call stack.

                Table 8-2 describes these instructions.

                Table 8-2       Stack instructions
                          Syntax                                        Operation
                 allocframe(#u11:3)         Allocate stack frame.
                                            This instruction is used after a call. It first XORs the values in LR
                                            and FRAMEKEY, and pushes the resulting scrambled return
                                            address and FP to the top of stack.
                                            Next, it subtracts an unsigned immediate from SP in order to
                                            allocate room for local variables. If the resulting SP is less than
                                            FRAMELIMIT, the processor raises exception 0x27. Otherwise,
                                            SP is set to the new value, and FP is set to the address of the
                                            old frame pointer on the stack.
                                            The immediate operand as expressed in assembly syntax
                                            specifies the byte offset. This value must be 8-byte aligned. The
                                            valid range is from 0 to 16 KB.
                 deallocframe               Deallocate stack frame.
                                            This instruction is used before a return in order to free a stack
                                            frame. It first loads the saved FP and LR values from the
                                            address at FP, and XORs the restored LR with the value in
                                            FRAMEKEY to unscramble the return address. SPis then
                                            pointed back to the previous frame.
                 dealloc_return             Subroutine return with stack frame deallocate.
                                            Perform deallocframe operation, and then perform
                                            subroutine return (Section 7.3.3) to the target address loaded
                                            from LR by deallocframe.


                   NOTE     allocframe and deallocframe load and store the LR and FP registers on the
                            stack as a single aligned 64-bit register pair (i.e., LR:FP).




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                               142
         9 PMU Events

                The Hexagon processor can collect execution statistics on the applications it executes. The
                statistics summarize the various types of Hexagon processor events that occurred while
                the application was running.

                Execution statistics can be collected in hardware or software:

                ï®   Statistics can be collected in hardware with the Performance Monitor Unit (PMU),
                    which is defined as part of the Hexagon processor architecture.
                ï®   Statistics can be collected in software using the Hexagon simulator. The simulator
                    statistics are presented in the same format used by the PMU.

                Execution statistics are expressed in terms of processor events. This chapter defines the
                event symbols, along with their associated numeric codes.

                    NOTE    Because the types of execution events vary across the Hexagon processor
                            versions, different types of statistics are collected for each version. This
                            chapter lists the event symbols defined for version V62.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      143
Hexagon V62 Programmer's Reference Manual                                                               PMU Events



         9.1      V62 processor event symbols
                  Table 9-1 defines the symbols that are used to represent processor events for the V62
                  Hexagon processor.

Table 9-1       V62 processor event symbols
 Event                  Symbol                                              Definition
  0x00    No                                    Do nothing. This event never causes a counter update.
  0x01    COUNTER0_OVERFLOW                     Counter0 overflow. This can be used as the event detected by
                                                counter1 to build an effective 64-bit counter.
  0x02    COUNTER2_OVERFLOW                     Counter2 overflow. This can be used as the event detected by
                                                counter3 to build an effective 64-bit counter.
  0x03    COMMITTED_PKT_ANY                     Thread committed a packet. Packets executed.
  0x04    COMMITTED_PKT_BSB                     Packet committed 2 cycles after previous packet in same thread.
  0x05    COUNTER4_OVERFLOW                     Counter4 overflow. This can be used as the event detected by
                                                counter5 to build an effective 64-bit counter.
  0x06    COUNTER6_OVERFLOW                     Counter6 overflow. This can be used as the event detected by
                                                counter7 to build an effective 64-bit counter.
  0x07    COMMITTED_PKT_B2B                     Packet committed 1 cycle after previous packet in same thread.
  0x08    COMMITTED_PKT_SMT                     2 packets committed in the same cycle.
  0x12    ICACHE_DEMAND_MISS                    Icache demand miss. Includes secondary miss and dczero.
                                                Excludes uncacheables, prefetch initiated misses, and predicate-
                                                killed operations.
  0x13    DCACHE_DEMAND_MISS                    Dcache cacheable demand primary or secondary miss. Includes
                                                dczero stall. Excludes uncacheables, prefetches, and no allocate
                                                store misses.
  0x14    DCACHE_STORE_MISS                     Dcache cacheable store miss.
  0x17    CU_PKT_READY_NOT_DISPATCHED Packet ready at scheduler but not scheduled because a) its thread
                                      was not picked or b) an intercluster resource conflict occurred.
  0x20    ANY_IU_REPLAY                         Any IU stall other than icache miss. Includes jump register stall,
                                                fetchcross stall, itlb miss stall, etc. Excludes CU replay.
  0x21    ANY_DU_REPLAY                         Any DU replay. Bank conflict, dTLB miss, etc. Excludes stalls due
                                                to cache misses.
  0x22    CU_REDISPATCH                         Any case where a packet is redispatched. Commonly a replay
                                                requested for a non-replayable instruction or forwarding bus
                                                resource conflict.
  0x25    COMMITTED_PKT_1_THREAD_               Committed packets with 1 thread running. Not in stop/wait.
          RUNNING
  0x26    COMMITTED_PKT_2_THREAD_               Committed packets with 2 threads running. Not in stop/wait.
          RUNNING
  0x27    COMMITTED_PKT_3_THREAD_               Committed packets with 3 threads running. Not in stop/wait.
          RUNNING
  0x2a    COMMITTED_INSTS                       Committed instructions. Increments by up to 8 per cycle. Duplex
                                                counts as two instructions. Does not include endloops.
  0x2b    COMMITTED_TC1_INSTS                   Committed tc1 class instructions. Increments by up to 8 per cycle.
                                                Duplex of two tc1 instructions counts as two tc1 instructions.



80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          144
Hexagon V62 Programmer's Reference Manual                                                              PMU Events



Table 9-1       V62 processor event symbols
 Event                  Symbol                                             Definition
  0x2c   COMMITTED_PRIVATE_INSTS               Committed instructions that have per-cluster (private) execution
                                               resources. Increments by up to 8 per cycle. Duplex of two private
                                               instructions counts as two private instructions.
  0x2f   COMMITTED_PKT_4_THREAD_               Committed packets with 4 threads running. Not in stop/wait.
         RUNNING
  0x30   COMMITTED_LOADS                       Committed load instructions. Includes cached and uncached.
                                               Increments by 2 for dual loads. Excludes prefetches, memops.
  0x31   COMMITTED_STORES                      Committed store instructions. Includes cached and uncached.
                                               Increments by 2 for dual stores. Excludes memops.
  0x32   COMMITTED_MEMOPS                      Committed memop instructions. Cached or uncached.
  0x37   COMMITTED_PROGRAM_FLOW_               Committed packet contains program flow inst. Includes cr jumps,
         INSTS                                 endloop, j, jr, dealloc_return, system/trap, superset of event 0x38.
                                               Dual jumps count as two.
  0x38   COMMITTED_PKT_CHANGED_                Committed packet resulted in change-of-flow. Any taken jump,
         FLOW                                  includes endloop.
  0x39   COMMITTED_PKT_ENDLOOP                  Committed packet contains an endloop which was taken.
  0x3b   CYCLES_1_THREAD_RUNNING               Processor cycles that 1 thread is running. Not in wait or stop.
  0x3c   CYCLES_2_THREAD_RUNNING               Processor cycles that 2 threads are running. Not in wait or stop.
  0x3d   CYCLES_3_THREAD_RUNNING               Processor cycles that 3 threads are running. Not in wait or stop.
  0x3e   CYCLES_4_THREAD_RUNNING               Processor cycles that 4 threads are running. Not in wait or stop.
  0x40   AXI_READ_REQUEST                      All read requests issued by primary AXI master. Includes full line
                                               and partial line.
  0x41   AXI_LINE32_READ_REQUEST                32-byte line read requests issued by primary AXI master.
  0x42   AXI_WRITE_REQUEST                     All write requests issued by primary AXI master. Includes full line
                                               and partial line.
  0x43   AXI_LINE32_WRITE_REQUEST              32-byte line write requests issued by primary AXI master, all bytes
                                               valid.
  0x44   AHB_READ_REQUEST                       Read requests issued by AHB master.
  0x45   AHB_WRITE_REQUEST                      Write requests issued by AHB master.
  0x47   AXI_SLAVE_MULTI_BEAT_ACCESS            AXI slave multi-beat access.
  0x48   AXI_SLAVE_SINGLE_BEAT_                AXI slave single-beat access.
         ACCESS
  0x49   AXI2_READ_REQUEST                     All read requests issued by secondary AXI master. Includes full
                                               line and partial line.
  0x4a   AXI2_LINE32_READ_REQUEST              32-byte line read requests issued by secondary AXI master
  0x4b   AXI2_WRITE_REQUEST                    All write requests issued by secondary AXI master. Includes full
                                               line and partial line.
  0x4c   AXI2_LINE32_WRITE_REQUEST              32-byte line write requests issued by secondary AXI master.
  0x4d   AXI2_CONGESTION                       Secondary AXI command or data queue is full and an operation is
                                               stuck at the head of the secondary AXI master command queue.
  0x50   COMMITTED_FPS                         Committed floating point instructions. Increments by 2 for dual FP
                                               ops. Excludes conversions.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          145
Hexagon V62 Programmer's Reference Manual                                                             PMU Events



Table 9-1       V62 processor event symbols
 Event                  Symbol                                             Definition
  0x51   BRANCH_MISPREDICT_DIRECTION           Branch mispredict direction. Includes new-predicate, old-
                                               predicate, low loop count, new-value, and dealloc_return direction
                                               mispredicts. Only counts once if both jumps in a dual jump
                                               mispredict. Excludes target mispredicts.
  0x52   BRANCH_MISPREDICT_TARGET              Branch mispredict target. Includes RAS mispredict. Excludes
                                               indirect jumps and calls other than JUMPR R31 returns. Excludes
                                               direction mispredicts.
  0x58   JTLB_MISS                             Instruction or data address translation request missed in JTLB.
  0x5a   COMMITTED_PKT_RETURN                  Committed a return instruction. Includes canceled returns.
  0x5b   COMMITTED_PKT_INDIRECT_JUMP           Committed an indirect jump or call instruction. Includes canceled
                                               instructions. Does not include JUMPR R31 returns.
  0x5c   COMMITTED_BIMODAL_                    Committed bimodal branch. Includes .old and .new. Increments by
         BRANCH_INSTS                          2 for dual jumps.
  0x65   IU_DEMAND_SECONDARY_MISS              Icache secondary miss.
  0x6b   IU_PREFETCHES_SENT_TO_L2              IU prefetches sent to L2. Counts cachelines not dropped by L2.
                                               Excludes replayed prefetches and only counts ones L2 accepts.
  0x6c   ITLB_MISS                             ITLB miss. One per thread maximum.
  0x76   L2_IU_ACCESS                          L2 access from IU. Any access to L2 cache that was the result of
                                               an IU command, either demand or L1 prefetch access. Excludes
                                               L2 prefetches, TCM accesses, and uncacheables.
  0x77   L2_IU_MISS                            L2 misses from IU. Of the events qualified by 0x76, the ones that
                                               resulted in an L2 miss (demand miss or L1 prefetch miss).
                                               Includes hitting a reserved line.
  0x78   L2_IU_PREFETCH_ACCESS                 Pre-fetch from the IU to L2. Any IU pre-fetch access sent to the L2
                                               cache. Access must be L2 cacheable and target primary AXI. This
                                               does not include L2Fetch generated accesses.
  0x79   L2_IU_PREFETCH_MISS                   L2 prefetch from IU miss. Of the events qualified by 0x78, the
                                               ones that resulted in an L2 miss.
  0x7c   L2_DU_READ_ACCESS                     L2 read access from DU. Any read access from DU that may
                                               cause a lookup in the L2 cache. includes loads, L1 prefetch,
                                               dcfetch. excludes initial L2fetch command, uncacheables.
  0x7d   L2_DU_READ_MISS                       L2 read miss from DU. Of the events qualified by 0x7c, the ones
                                               that resulted in a miss and were attempts to load data. Includes
                                               prefetches. Excludes TCM.
  0x7e   L2FETCH_ACCESS                        L2fetch access from DU. Any access to the L2 cache from the L2
                                               prefetch engine that was initiated by programing the L2Fetch
                                               engine. Includes only the cache inquire and fetch if not present
                                               commands.
  0x7f   L2FETCH_MISS                          L2fetch miss from a programed inquiry. Of the events qualified by
                                               0x7e, the ones that resulted in L2 miss. i.e. the line was not
                                               previously allocated in the L2 cache and will be fetched from
                                               backing memory.
  0x81   L2_ACCESS                             All requests to the L2. Does not include internally generated
                                               accesses like L2Fetch, however the programing of the L2Fetch
                                               engine would be counted. Accesses target odd or even interleave,
                                               and may be L2 cacheable or TCM.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          146
Hexagon V62 Programmer's Reference Manual                                                              PMU Events



Table 9-1       V62 processor event symbols
 Event                  Symbol                                              Definition
  0x82   L2_PIPE_CONFLICT                      Request not taken by the L2 due to a pipe conflict. The conflict
                                               may be a tag bank, data bank, or other pipeline conflict.
  0x83   L2_TAG_ARRAY_CONFLICT                 Tag array conflict. Triggers when L2 tag has a conflict i.e., two
                                               operations collide.
  0x87   TCM_DU_ACCESS                          TCM access from DU. DU access to the L2 TCM space.
  0x88   TCM_DU_READ_ACCESS                    TCM read access from DU. DU read access to the L2 TCM space.
  0x89   TCM_IU_ACCESS                         TCM access from IU. IU access to the L2 TCM space.
  0x8a   L2_CASTOUT                            L2 castout. Triggers when L2 evicts a dirty line due to an
                                               allocation. Not triggered on cache ops.
  0x8b   L2_DU_STORE_ACCESS                    L2 cacheable store access from DU. Any store access from DU
                                               that may cause a lookup in the L2 cache. Excludes cache ops,
                                               uncacheables, TCM. Must target primary AXI.
  0x8c   L2_DU_STORE_MISS                      L2 miss from DU. Of the events qualified by 0x8b, the ones that
                                               resulted in a miss. Specifically the cases where the line is not in
                                               cache or a coalesce buffer.
  0x8d   L2_DU_PREFETCH_ACCESS                 L2 prefetch access from DU. Dcfetch and dhwprefetch access to
                                               the L2.
  0x8e   L2_DU_PREFETCH_MISS                   L2 prefetch miss from DU. Of the events qualified by 0x8d, which
                                               ones missed the L2.
  0x90   L2_DU_LOAD_SECONDARY_MISS             L2 load secondary miss from DU. Hit busy line in the scoreboard
                                               which prevented a return. Busy condition may include pipeline
                                               bubbles caused by back to back loads, as may be seen on L1UC
                                               loads.
  0x91   L2FETCH_COMMAND                        L2fetch command. Excludes stop command.
  0x92   L2FETCH_COMMAND_KILLED                L2fetch command killed because a stop command was issued.
                                               Increments once for each L2fetch commands that is killed. If
                                               multiple commands are queued to the L2Fetch engine, the kill of
                                               each one will be recorded.
  0x93   L2FETCH_COMMAND_OVERWRITE             L2fetch command overwrite. Kills old L2fetch and replaces with
                                               new one.
  0x94   L2FETCH_ACCESS_CREDIT_FAIL            L2fetch access could not get a credit. L2fetch blocked because of
                                               missing L2fetch or L2evict credit.
  0x97   L2_ACCESS_EVEN                        Of the events in 0x81, the number of accesses made to the even
                                               L2 cache.
  0xa0   ANY_DU_STALL                          Any DU stall. Increments once when the thread has any DU stall
                                               (dcache miss or dTLB miss).
  0xa1   DU_BANK_CONFLICT_REPLAY               DU bank conflict replay. Dual mem access to same bank but
                                               different lines. Banks are determined by bits 11,5,4,3.
  0xa2   DU_CREDIT_REPLAY                      Number of times packet took a replay because insufficient QoS
                                               DU credits were available.
  0xa3   L2_FIFO_FULL_REPLAY                   Counts L2 even/odd FIFO full replays.
  0xa4   DU_STORE_BUFFER_FULL_                 First packet puts access in DU store buffer (memop, store.new,
         REPLAY                                load/store bank conflict, store/store bank conflict). Any later
                                               packet tries to use store buffer before the first one evicts, and so
                                               must replay so the store buffer can drain.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            147
Hexagon V62 Programmer's Reference Manual                                                               PMU Events



Table 9-1       V62 processor event symbols
 Event                  Symbol                                               Definition
  0xa7   DU_SNOOP_REQUEST                       Number of DU snoop requests that were accepted.
  0xa8   DU_FILL_REPLAY                        A fill has a index conflict with an instruction from the same thread
                                               in pipeline. Fills and demands might be from different threads if (1)
                                               prefetch from deferral queue, (2) store from store buffer, or (3) fill
                                               has not be ack'ed for too long and forces itself in to the pipeline.
  0xac   DU_READ_TO_L2                         DU read to L2. Total of everything that brings data from L2.
                                               Includes prefetches (dcfetch and hwprefetch).
  0xad   DU_WRITE_TO_L2                        DU write to L2. Total of everything that is written out of DU to the
                                               L2 array. Includes cleaninv. Excludes tag writes.
  0xaf   DCZERO_COMMITTED                      Committed a dczeroa instruction.
  0xb3   DTLB_MISS                             DTLB miss which goes to JTLB. When both slots miss to different
                                               pages, increments by 2. When both slots miss to the same page,
                                               only counts S1, since S1 goes first and fills for S0.
  0xb6   STORE_BUFFER_HIT_REPLAY               Store buffer hit replay due to a packet with 2 stores going to the
                                               same bank but different cachelines, followed by a load from an
                                               address that was pushed into the store buffer.
  0xb7   STORE_BUFFER_FORCE_REPLAY             The store buffer must drain, forcing the current packet to replay.
                                               This usually happens on a cache index match between the current
                                               packet and store buffer. Could also a store buffer timeout.
  0xb9   SMT_BANK_CONFLICT                     Counts inter-thread SMT bank conflicts.
  0xba   PORT_CONFLICT_REPLAY                  Counts all port conflict replays, including the same cluster replays
                                               that were caused by high-priority fills and store buffer force drains
                                               (and intercluster ones as well).
  0xbd   PAGE_CROSS_REPLAY                     Page cross replay. Page cross from valid packet that caused
                                               replay. Excludes pdkill packets. Counts twice if both slots cause a
                                               page cross.
  0xbe   DU_DEALLOC_SECURITY_REPLAY            Replay caused by executing the instructions deallocframe or
                                               dealloc_return when FRAMEKEY is not equal to zero.
  0xbf   DU_DEMAND_SECONDARY_MISS              DU demand secondary miss.
  0xc3   DCFETCH_COMMITTED                     Dcfetch committed. Includes hit and dropped. Does not include
                                               convert-to-prefetches.
  0xc4   DCFETCH_HIT                            Dcfetch hit in dcache. Includes hit valid or reserved line.
  0xc5   DCFETCH_MISS                          Dcfetch missed in L1. Counts the dcfetch issued to L2 FIFO.
  0xc8   DU_LOAD_UNCACHEABLE                   Uncacheable load in L1 cache. Counts twice for dual uncacheable
                                               loads.
  0xc9   DU_DUAL_LOAD_UNCACHEABLE              Dual uncacheable loads in L1 cache.
  0xca   DU_STORE_UNCACHEABLE                  Uncacheable store in L1 cache. Counts twice for dual
                                               uncacheable stores.
  0xce   AXI_LINE64_READ_REQUEST                64-byte line read requests issued by primary AXI master.
  0xcf   AXI_LINE64_WRITE_REQUEST              64-byte line write requests issued by primary AXI master. All bytes
                                               valid.
  0xd1   AHB_8_READ_REQUEST                    An 8-byte AHB read was made.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           148
Hexagon V62 Programmer's Reference Manual                                                              PMU Events



Table 9-1       V62 processor event symbols
 Event                  Symbol                                              Definition
  0xd3   L2FETCH_COMMAND_PAGE_                 L2fetch command terminated because it could not get a page
         TERMINATION                           translation from VA to PA. Includes termination dues to permission
                                               errors. i.e. address translation could fail because the VA to PA is
                                               not in the TLB, or the properties in the translation are not
                                               acceptable and the command terminates.
  0xd5   L2_DU_STORE_COALESCE                   Events from 0x8b that were coalesced.
  0xd6   L2_STORE_LINK                         Number of times a new store links to something else in the
                                               scoreboard.
  0xd7   L2_SCOREBOARD_70_PERCENT_             Increments by 1 every cycle that the L2 scoreboard is at least 70%
         FULL                                  full. For a 32-entry scoreboard, this indicates that 23 or more
                                               entries are consumed. This event continues to count even if the
                                               scoreboard is more than 80% full. For more than one interleave,
                                               this event considers only the scoreboard with the most entries
                                               consumed.
  0xd8   L2_SCOREBOARD_80_PERCENT_             Increments by 1 every cycle that the L2 scoreboard is at least 80%
         FULL                                  full. For a 32-entry scoreboard, this indicates that 26 or more
                                               entries are consumed. This event continues to count even if the
                                               scoreboard is more than 90% full. For more than one interleave,
                                               this event considers only the scoreboard with the most entries
                                               consumed.
  0xd9   L2_SCOREBOARD_90_PERCENT_             Increments by 1 every cycle that the L2 scoreboard is at least 90%
         FULL                                  full. For a 32-entry scoreboard, this indicates that 29 or more
                                               entries are consumed. For more than one interleave, this event
                                               considers only the scoreboard with the most entries consumed.
  0xda   L2_SCOREBOARD_FULL_REJECT             L2 scoreboard is too full to accept a selector request, and the
                                               selector has a request.
  0xdc   L2_EVICTION_BUFFERS_FULL              Counts every cycle when all eviction buffers in any interleave are
                                               occupied.
  0xdd   AHB_MULTI_BEAT_READ_                  A 32-byte multi-beat AHB read was made.
         REQUEST
  0xdf   L2_DU_LOAD_SECONDARY_MISS_            Of the events in 0x90, the ones where the primary miss was a
         ON_SW_PREFETCH                        DCFETCH or L2FETCH.
  0xe6   ARCH_LOCK_PVIEW_CYCLES                 Cycles cluster could not dispatch due to kernel lock or TLB lock.
  0xe7   IU_BRANCH_MISS_PVIEW_CYCLES           Packets in-flight killed due to branch mispredict, and cycles cluster
                                               could not dispatch due to IQ being empty because of branch
                                               mispredict.
  0xe8   IU_NO_PKT_PVIEW_CYCLES                 Cycles cluster could not dispatch due to IQ being empty.
  0xe9   DU_CACHE_MISS_PVIEW_CYCLES            Cycles cluster could not dispatch due to D-cache miss or
                                               uncached access.
  0xea   DU_BUSY_OTHER_PVIEW_CYCLES            Packets in flight killed due to DU replay and cycles cluster could
                                               not dispatch due to DU busy because of stall or replay.
  0xeb   CU_BUSY_PVIEW_CYCLES                  Cycles cluster could not dispatch due to register interlock, register
                                               port conflict, bubbles due to timing class such as tc_3stall, no B2B
                                               HVX, or HVX FIFO full.
  0xec   SMT_DU_CONFLICT_PVIEW_                Cycles cluster could not dispatch even though the thread was
         CYCLES                                ready due to DU resource conflict.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          149
Hexagon V62 Programmer's Reference Manual                                                            PMU Events



Table 9-1       V62 processor event symbols
 Event                  Symbol                                              Definition
  0xed   SMT_XU_CONFLICT_PVIEW_                Cycles cluster could not dispatch even though the cluster was
         CYCLES                                ready due to an XU resource conflict or other non-DU reason.
  oxf0   COPROC_PKT_THREAD                     Committed packets on a thread with XE bit set, whether executed
                                               in core or coprocessor.
  oxf1   COPROC_PKT_COUNT                       Packets with HVX instructions.
  oxf2   COPROC_POWER_THROTTLING_              Stall cycles due to HVX engine being throttled for power reasons.
         STALL_CYCLES
  oxf3   COPROC_REGISTER_STALL_                Stall cycles due to interlocks.
         CYCLES
  oxf4   COPROC_LOAD_STALL_CYCLES              Stall cycles due to load pending.
  oxf5   COPROC_STORE_STALL_CYCLES             Stall cycles due to store not yet allocated in L2.
  oxf6   COPROC_BUSY_STALL_CYCLES               Stall cycles due to multi-issue packet.
  oxf7   COPROC_FREEZE_STALL_CYCLES            Stall cycles due to L2 vector store data FIFO full.
  oxf8   COPROC_CORE_VFIFO_FULL_               Number of times a thread had to stall due to VFIFO being full.
         STALL
  oxf9   COPROC_L2_STORE_ACCESS                L2 cacheable store access from HVX. Any store access from HVX
                                               that may cause a lookup in L2 cache. Excludes cache ops,
                                               uncacheables, scalar stores.
  oxfa   COPROC_L2_STORE_MISS                  L2 cacheable miss from HVX. Of the events qualified by 0xf9, the
                                               ones that resulted in a miss. Specifically the cases where line is
                                               not in cache or a coalesce buffer. DCZero does not count as a
                                               miss, if it allocates without a backing store fetch.
  oxfb   COPROC_L2_LOAD_ACCESS                 L2 cacheable load access from HVX. Any load access from HVX
                                               that may cause a lookup in the L2 cache. Excludes cache ops,
                                               uncacheables, scalars.
  oxfc   COPROC_L2_LOAD_MISS                   L2 cacheable miss from HVX. Of the events qualified by 0xFB, the
                                               ones that resulted in a miss i.e. the line was not previously
                                               allocated in the L2 cache and will be fetched from backing
                                               memory.
  oxfd   COPROC_TCM_STORE_ACCESS               TCM store access for HVX. HVX store to L2 TCM space.
  oxfe   COPROC_TCM_LOAD_ACCESS                TCM load access for HVX. HVX load from L2 TCM space
  oxff   COPROC_L2_LOAD_SECONDARY_             Of the events in 0xfb, the ones where the load could not be
         MISS                                  returned due to the immediately prior access for the line being a
                                               pending load or pending L2Fetch.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         150
      10 Instruction Encoding


                This chapter describes the binary encoding of Hexagon processor instructions and
                instruction packets. It covers the following topics:

                    ï®   Instructions
                    ï®   Sub-instructions
                    ï®   Duplex instructions
                    ï®   Instruction classes
                    ï®   Instruction packets
                    ï®   Loop packets
                    ï®   Immediate operands
                    ï®   Scaled immediate operands
                    ï®   Constant extenders
                    ï®   New-value operands
                    ï®   Instruction mapping




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              151
Hexagon V62 Programmer's Reference Manual                                                   Instruction Encoding



     10.1       Instructions
                All Hexagon processor instructions are encoded in a 32-bit instruction word. The
                instruction word format varies according to the instruction type.

                The instruction words contain two types of bit fields:

                      ï®   Common fields appear in every processor instruction, and are defined the same in
                          all instructions.
                      ï®   Instruction-specific fields appear only in some instructions, or vary in definition
                          across the instruction set.

                Table 10-1 lists the instruction bit fields.

                Table 10-1 Instruction fields
                       Name                             Description                       Type
                ICLASS             Instruction class                              Common
                Parse              Packet / loop bits
                MajOp              Major opcode                                   Instruction-
                Maj                                                               specific
                MinOp              Minor opcode
                Min
                RegType            Register type (32-bit, 64-bit)
                Type               Operand type (byte, halfword, etc.)
                Amode              Addressing mode
                dn                 Destination register operand
                sn                 Source register operand
                tn                 Source register operand #2
                xn                 Source and destination register operand
                un                 Predicate or modifier register operand
                sH                 Source register bit field (Rs.H or Rs.L)
                tH                 Source register #2 bit field (Rt.H or Rt.L)
                UN                 Unsigned operand
                Rs                 No source register read
                P                  Predicate expression
                PS                 Predicate sense (Pu or !Pu)
                DN                 Dot-new predicate
                PT                 Predict taken
                sm                 Supervisor mode only


                     NOTE     In some cases instruction-specific fields are used to encode instruction
                              attributes other than the ones described for the fields in Table 10-1.




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     152
Hexagon V62 Programmer's Reference Manual                                                    Instruction Encoding



                Reserved bits

                Some instructions contain reserved bits which are not currently used to encode instruction
                attributes. These bits should always be set to 0 to ensure compatibility with any future
                changes in the instruction encoding.

                   NOTE      Reserved bits appear as â-â characters in the instruction encoding tables.


     10.2       Sub-instructions
                To reduce code size the Hexagon processor supports the encoding of certain pairs of
                instructions in a single 32-bit container. Instructions encoded this way are called sub-
                instructions, and the containers are called duplexes (Section 10.3).

                Sub-instructions are limited to certain commonly-used instructions:

                     ï®   Arithmetic and logical operations
                     ï®   Register transfer
                     ï®   Loads and stores
                     ï®   Stack frame allocation/deallocation
                     ï®   Subroutine return

                Table 10-2 lists the sub-instructions along with the group identifiers that are used to
                encode them in duplexes.

                Sub-instructions can access only a subset of the general registers (R0-R7, R16-R23).
                Table 10-3 lists the sub-instruction register encodings.

                   NOTE      Certain sub-instructions implicitly access registers such as SP (R29).

Table 10-2 Sub-instructions
     Group                            Instruction                                    Description
       L1        Rd = memw(Rs+#u4:2)                                    Word load
       L1        Rd = memub(Rs+#u4:0)                                   Unsigned byte load
     Group                            Instruction                                    Instruction
       L2        Rd = memh/memuh(Rs+#u3:1)                              Halfword loads
       L2        Rd = memb(Rs+#u3:0)                                    Signed byte load
       L2        Rd = memw(r29+#u5:2)                                   Load word from stack
       L2        Rdd = memd(r29+#u5:3)                                  Load pair from stack
       L2        deallocframe                                           Dealloc stack frame
       L2        if ([!]P0) dealloc_return                              Dealloc stack frame and return
                 if ([!]P0.new) dealloc_return:nt
       L2        jumpr R31                                              Return
                 if ([!]P0) jumpr R31
                 if ([!]P0.new) jumpr:nt R31



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        153
Hexagon V62 Programmer's Reference Manual                                                   Instruction Encoding



Table 10-2 Sub-instructions (Continued)
     Group                           Instruction                                     Description
     Group                           Instruction                                     Instruction
       S1        memw(Rs+#u4:2) = Rt                                  Store word
       S1        memb(Rs+#u4:0) = Rt                                  Store byte
     Group                           Instruction                                     Instruction
       S2        memh(Rs+#u3:1) = Rt                                  Store halfword
       S2        memw(r29+#u5:2) = Rt                                 Store word to stack
       S2        memd(r29+#s6:3) = Rtt                                Store pair to stack
       S2        memw(Rs+#u4:2) = #U1                                 Store immediate word #0 or #1
       S2        memb(Rs+#u4) = #U1                                   Store immediate byte #0 or #1
       S2        allocframe(#u5:3)                                    Allocate stack frame
     Group                           Instruction                                     Instruction
       A         Rx = add(Rx,#s7)                                     Add immediate
       A         Rd = Rs                                              Transfer
       A         Rd = #u6                                             Set to unsigned immediate
       A         Rd = #-1                                             Set to -1
       A         if ([!]P0[.new]) Rd = #0                             Conditional clear
       A         Rd = add(r29,#u6:2)                                  Add immediate to stack pointer
       A         Rx = add(Rx,Rs)                                      Register add
       A         P0 = cmp.eq(Rs,#u2)                                  Compare register equal immed
       A         Rdd = combine(#0,Rs)                                 Combine zero and register into pair
       A         Rdd = combine(Rs,#0)                                 Combine register and zero into pair
       A         Rdd = combine(#u2,#U2)                               Combine immediates into pair
       A         Rd = add(Rs,#1)                                      Add and Subtract 1
                 Rd = add(Rs,#-1)
       A         Rd = sxth/sxtb/zxtb/zxth(Rs)                         Sign- and zero-extends
       A         Rd = and(Rs,#1)                                      And with 1




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       154
Hexagon V62 Programmer's Reference Manual                                               Instruction Encoding




                Table 10-3 Sub-instruction registers
                    Register               Encoding
                Rs,Rt,Rd,Rx      0000      =    R0
                                 0001      =    R1
                                 0010      =    R2
                                 0011      =    R3
                                 0100      =    R4
                                 0101      =    R5
                                 0110      =    R6
                                 0111      =    R7
                                 1000      =    R16
                                 1001      =    R17
                                 1010      =    R18
                                 1011      =    R19
                                 1100      =    R20
                                 1101      =    R21
                                 1110      =    R22
                                 1111      =    R23
                Rdd,Rtt          000   =       R1:0
                                 001   =       R3:2
                                 010   =       R5:4
                                 011   =       R7:6
                                 100   =       R17:16
                                 101   =       R19:18
                                 110   =       R21:20
                                 111   =       R23:22




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   155
Hexagon V62 Programmer's Reference Manual                                                      Instruction Encoding



     10.3       Duplexes
                A duplex is encoded as a 32-bit instruction with bits [15:14] set to 00. The sub-instructions
                (Section 10.2) that comprise a duplex are encoded as 13-bit fields in the duplex.

                Table 10-4 shows the encoding details for a duplex.

                An instruction packet can contain one duplex and up to two other (non-duplex)
                instructions. The duplex must always appear as the last word in a packet.

                The sub-instructions in a duplex are always executed in Slot 0 and Slot 1.

                Table 10-4 Duplex instruction
                       Bits             Name                                  Description
                15:14            Parse Bits             00 = Duplex type, ends the packet and indicates that
                                                        word contains two sub-instructions
                12:0             Sub-insn low           Encodes Slot 0 sub-instruction
                28:16            Sub-insn high          Encodes Slot 1 sub-instruction
                31:29, 13        4-bit ICLASS           Indicates which group the low and high sub-instructions
                                                        below to.

                Table 10-5 lists the duplex ICLASS field values, which specify the group of each sub-
                instruction in a duplex.

                Table 10-5 Duplex ICLASS field
                   ICLASS          Low Slot 0 subinsn type       High Slot 1 subinsn type
                        0x0                   L1-type                     L1-type
                        0x1                   L2-type                     L1-type
                        0x2                   L2-type                     L2-type
                        0x3                   A-type                       A-type
                        0x4                   L1-type                      A-type
                        0x5                   L2-type                      A-type
                        0x6                   S1-type                      A-type
                        0x7                   S2-type                      A-type
                        0x8                   S1-type                     L1-type
                        0x9                   S1-type                     L2-type
                       0xA                    S1-type                     S1-type
                       0xB                    S2-type                     S1-type
                       0xC                    S2-type                     L1-type
                       0xD                    S2-type                     L2-type
                       0xE                    S2-type                     S2-type
                        0xF               Reserved                       Reserved




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           156
Hexagon V62 Programmer's Reference Manual                                                      Instruction Encoding



                Duplexes have the following grouping constraints:

                       ï®   Constant extenders enable the range of an instructionâs immediate operand to be
                           expanded to 32 bits (Section 10.9). The following sub-instructions can be
                           expanded with a constant extender:
                               â¢   Rx = add(Rx,#s7)
                               â¢   Rd = #u6
                           Note that a duplex can contain only one constant-extended instruction, and it must
                           appear in the Slot 1 position.
                       ï®   If a duplex contains two instructions with the same sub-instruction group, the
                           instructions must be ordered in the duplex as follows: when the sub-instructions
                           are treated as 13-bit unsigned integer values, the instruction corresponding to the
                           numerically smaller value must be encoded in the Slot 1 position of the duplex.1
                       ï®   Sub-instructions must conform to any slot assignment grouping rules that apply to
                           the individual instructions, even if a duplex pattern exists which violates those
                           assignments. One exception to this rule exists:
                               â¢   jumpr R31 must appear in the Slot 0 position




                1   Note that the sub-instruction register and immediate fields are assumed to be 0 when performing
                    this comparison.



80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        157
Hexagon V62 Programmer's Reference Manual                                                Instruction Encoding



     10.4       Instruction classes
                The instruction class (Section 3.2) is encoded in the four most-significant bits of the
                instruction word (31:28). These bits are referred to as the instructionâs ICLASS field.

                Table 10-6 lists the encoding values for the instruction classes. The Slots column indicates
                which slots can receive the instruction class.

                Table 10-6 Instruction class encoding
                    Encoding                 Instruction Class                 Slots
                    0000          Constant extender (Section 10.9)               â
                    0001          J                                             2,3
                    0010          J                                             2,3
                    0011          LD                                            0,1
                                  ST
                    0100          LD                                            0,1
                                  ST
                                  (conditional or GP-relative)
                    0101          J                                             2,3
                    0110          CR                                             3
                    0111          ALU32                                        0,1,2,3
                    1000          XTYPE                                         2,3
                    1001          LD                                            0,1
                    1010          ST                                             0
                    1011          ALU32                                        0,1,2,3
                    1100          XTYPE                                         2,3
                    1101          XTYPE                                         2,3
                    1110          XTYPE                                         2,3
                    1111          ALU32                                        0,1,2,3


                For details on encoding the individual class types see Chapter 11.




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     158
Hexagon V62 Programmer's Reference Manual                                                       Instruction Encoding



     10.5       Instruction packets
                Instruction packets are encoded using two bits of the instruction word (15:14), which are
                referred to as the instruction wordâs Parse field. The field values have the following
                definitions:

                       ï®   â11â indicates that an instruction is the last instruction in a packet (i.e., the
                           instruction word at the highest address).
                       ï®   â01â or â10â indicate that an instruction is not the last instruction in a packet.
                       ï®   â00âindicates a duplex (Section 10.3)

                If any sequence of four consecutive instructions occurs without one of them containing
                â11â or â00â, the processor will raise an error exception (illegal opcode).

                Figure 10-1 shows the location of the Parse field in an instruction word.


                  31                                                                     16



                  15                                                                      0
                   P       P




                 Packet / Loop Parse Bits:
                 01, 10 = not end of packet
                 11 = end of packet
                 00 = duplex



                Figure 10-1 Instruction packet encoding

                The following examples show how the Parse field is used to encode instruction packets:
                    { A ; B}
                      01 11                         // Parse fields of instrs A,B

                    { A ; B ; C}
                      01 01 11                      // Parse fields of instrs A,B,C

                    { A ; B ; C ; D}
                      01 01 01 11                   // Parse fields of instrs A,B,C,D




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         159
Hexagon V62 Programmer's Reference Manual                                                    Instruction Encoding



     10.6       Loop packets
                In addition to encoding the last instruction in a packet, the instruction wordâs Parse field
                (Section 10.5) is used to encode the last packet in a hardware loop.

                The Hexagon processor supports two hardware loops, labelled 0 and 1 (Section 7.2). The
                last packet in these loops is subject to the following restrictions:

                       ï®   The last packet in a hardware loop 0 must contain two or more instruction words.
                       ï®   The last packet in a hardware loop 1 must contain three or more instruction words.

                If the last packet in a loop is expressed in assembly language with fewer than the required
                number of words, the assembler automatically adds one or two NOP instructions to the
                encoded packet so it contains the minimum required number of instruction words.

                The Parse fields in a packetâs first and second instruction words (i.e., the words at the
                lowest addresses) encode whether or not the packet is the last packet in a hardware loop.

                Table 10-7 shows how the Parse fields are used to encode loop packets.
                Table 10-7 Loop packet encoding
                                                     Parse Field in       Parse Field in
                            Packet
                                                    First Instruction   Second Instruction
                Not last in loop                          01 or 11          01 or 11 1
                Last in loop 0                               10              01 or 11
                Last in loop 1                               01                10
                Last in loops 0 & 1                          10                10
                1   Not applicable for single-instruction packets.


                The following examples show how the Parse field is used to encode loop packets:
                      { A       B}:endloop0
                        10      11                                       // Parse fields of instrs A,B

                      { A       B      C}:endloop0
                        10      01     11                                // Parse fields of instrs A,B,C

                      { A       B     C      D}:endloop0
                        10      01    01     11                         // Parse fields of instrs A,B,C,D

                      { A       B      C}:endloop1
                        01      10     11                               // Parse fields of instrs A,B,C

                      { A       B     C      D}:endloop1
                        01      10    01     11                         // Parse fields of instrs A,B,C,D

                      { A       B      C}:endloop0:endloop1
                        10      10     11                               // Parse fields of instrs A,B,C

                      { A       B     C      D}:endloop0:endloop1
                        10      10    01     11                  // Parse fields of instrs A,B,C,D




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     160
Hexagon V62 Programmer's Reference Manual                                                      Instruction Encoding



     10.7       Immediate values
                To conserve encoding space, the Hexagon processor often stores immediate values in
                instruction fields that are smaller (in bit size) than the values actually needed in the
                instruction operation.

                When an instruction operates on one of its immediate operands, the processor
                automatically extends the immediate value to the bit size required by the operation:

                       ï®   Signed immediate values are sign-extended
                       ï®   Unsigned immediate values are zero-extended


     10.8       Scaled immediates
                To minimize the number of bits used in instruction words to store certain immediate
                values, the Hexagon processor stores the values as scaled immediates. Scaled immediate
                values are used when an immediate value must represent integral multiples of a power of 2
                in a specific range.

                For example, consider an instruction operand whose possible values are the following:

                           -32, -28, -24, -20, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 28

                Encoding the full range of integers -32..28 would normally require 6 bits. However, if the
                operand is stored as a scaled immediate, it can first be shifted right by two bits, with only
                the four remaining bits being stored in the instruction word. When the operand is fetched
                from the instruction word, the processor automatically shifts the value left by two bits to
                recreate the original operand value.

                   NOTE        The scaled immediate value in the example above is represented notationally
                               as #s4:2. For more information see Section 1.5.

                Scaled immediate values are commonly used to encode address offsets which apply to
                data types of varying size. For example, Table 10-8 shows how the byte offsets used in
                immediate-with-offset addressing mode are stored as 11-bit scaled immediate values. This
                enables the offsets to span the same range of data elements regardless of the data type.

                Table 10-8 Scaled immediate encoding (indirect offsets)
                                  Offset Size    Scale     Offset Size      Offset Range        Offset Range
                  Data Type
                                   (Stored)       Bits     (Effective)         (Bytes)           (Elements)
                byte                   11          0            11          -1024 ... 1023      -1024 ... 1023
                halfword               11          1            12          -2048 ... 2046      -1024 ... 1023
                word                   11          2            13          -4096 ... 4092      -1024 ... 1023
                doubleword             11          3            14          -8192 ... 8184      -1024 ... 1023




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          161
Hexagon V62 Programmer's Reference Manual                                                     Instruction Encoding



     10.9       Constant extenders
                To support the use of 32-bit operands in a number of instructions, the Hexagon processor
                defines an instruction word which exists solely to extend the bit range of an immediate or
                address operand that is contained in an adjacent instruction in a packet. These instruction
                words are called constant extenders.

                For example, the absolute addressing mode specifies a 32-bit constant value as the
                effective address. Instructions using this addressing mode are encoded in a single packet
                containing both the normal instruction word and a second word with a constant extender
                that increases the range of the instructionâs normal constant operand to a full 32 bits.

                   NOTE       Constant extended operands can encode symbols.

                A constant extender is encoded as a 32-bit instruction with the 4-bit ICLASS field set to 0
                and the 2-bit Parse field set to its usual value (Section 10.5). The remaining 26 bits in the
                instruction word store the data bits that are prepended to an operand as small as 6 bits in
                order to create a full 32-bit value.

                Table 10-9 shows the encoding details.

                Table 10-9 Constant extender encoding
                       Bits              Name                               Description
                31:28            ICLASS               Instruction class = 0000
                27:16            Extender high        High 12 bits of 26-bit constant extension
                15:14            Parse                Parse bits
                13:0             Extender low         Low 14 bits of 26-bit constant extension

                Within a packet, a constant extender must be positioned immediately before the
                instruction that it extends: in terms of memory addresses, the extender word must reside at
                address (<instr_address> - 4).

                The constant extender effectively serves as a prefix for an instruction: it is not executed in
                a slot, nor does it consume any slot resources. All packets must contain four or fewer
                words, and the constant extender occupies one word.

                If the instruction operand to be extended is longer than 6 bits, the overlapping bits in the
                base instruction must be encoded as zeros. The value in the constant extender always
                supplies the upper 26 bits.

                Table 10-10 lists the instructions that work with constant extenders.

                The Regclass field in the table lists the values that bits [27:24] must be set to in the
                instruction word to identify the instruction as one that may include a constant extender.

                   NOTE       In cases where the base instruction encodes two constant operands, the
                              extended immediate is the one specified in the table.

                              Constant extenders appear in disassembly listings as Hexagon instructions
                              with the name immext.


80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       162
Hexagon V62 Programmer's Reference Manual                                                   Instruction Encoding




Table 10-10 Constant extender instructions
    ICLASS      Regclass                                       Instructions
LD              ---1        Rd = mem{b,ub,h,uh,w,d}(##U32)
                            if ([!]Pt[.new]) Rd = mem{b,ub,h,uh,w,d} (Rs + ##U32)
                            // predicated loads
LD              ----        Rd   = mem{b,ub,h,uh,w,d} (Rs + ##U32)
                            Rd   = mem{b,ub,h,uh,w,d} (Re=##U32)
                            Rd   = mem{b,ub,h,uh,w,d} (Rt<<#u2 + ##U32)
                            if   ([!]Pt[.new]) Rd = mem{b,ub,h,uh,w,d} (##U32)
ST              ---0        mem{b,h,w,d}(##U32) = Rs[.new]   // GP-stores
                            if ([!]Pt[.new]) mem{b,h,w,d}(Rs + ##U32) = Rt[.new]
                            // predicated stores
ST              ----        mem{b,h,w,d}(Rs + ##U32) = Rt[.new]
                            mem{b,h,w,d}(Rd=##U32) = Rt[.new]
                            mem{b,h,w,d}(Ru<<#u2 + ##U32) = Rt[.new]
                            if ([!]Pt[.new]) mem{b,h,w,d}(##U32) = Rt[.new]
MEMOP           ----        [if [!]Ps] memw(Rs + #u6) = ##U32                 // constant store
                            memw(Rs + Rt<<#u2) = ##U32                        // constant store
NV              ----        if (cmp.xx(Rs.new,##U32)) jump:hint target
ALU32           ----        Rd = ##u32
                            Rdd = combine(Rs,##u32)
                            Rdd = combine(##u32,Rs)
                            Rdd = combine(##u32,#s8)
                            Rdd = combine(#s8,##u32)
                            Rd = mux (Pu, Rs,##u32)
                            Rd = mux (Pu, ##u32, Rs)
                            Rd = mux(Pu,##u32,#s8)
                            if ([!]Pu[.new]) Rd = add(Rs,##u32)
                            if ([!]Pu[.new]) Rd = ##u32
                            Pd = [!]cmp.eq (Rs,##u32)
                            Pd = [!]cmp.gt (Rs,##u32)
                            Pd = [!]cmp.gtu (Rs,##u32)
                            Rd = [!]cmp.eq(Rs,##u32)
                            Rd = and(Rs,##u32)
                            Rd = or(Rs,##u32)
                            Rd = sub(##u32,Rs)
ALU32           ----        Rd = add(Rs,##s32)
XTYPE           00--        Rd   = mpyi(Rs,##u32)
                            Rd   += mpyi(Rs,##u32)
                            Rd   -= mpyi(Rs,##u32)
                            Rx   += add(Rs,##u32)
                            Rx   -= add(Rs,##u32)
ALU32           ---- 1      Rd = ##u32
                            Rd = add(Rs,##s32)
J               1---        jump (PC + ##s32)
                            call (PC + ##s32)
                            if ([!]Pu) call (PC + ##s32)




80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   163
Hexagon V62 Programmer's Reference Manual                                                          Instruction Encoding



Table 10-10 Constant extender instructions (Continued)
    ICLASS         Regclass                                             Instructions
CR                ----             Pd = spNloop0(PC+##s32,Rs/#U10)
                                   loop0/1 (PC+##s32,#Rs/#U10)
XTYPE             1---             Rd = add(pc,##s32)
                                   Rd = add(##u32,mpyi(Rs,#u6))
                                   Rd = add(##u32,mpyi(Rs,Rt))
                                   Rd = add(Rs,add(Rt,##u32))
                                   Rd = add(Rs,sub(##u32,Rt))
                                   Rd = sub(##u32,add(Rs,Rt))
                                   Rd = or(Rs,and(Rt,##u32))
                                   Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,#U5))
                                   Rx = add/sub/and/or (##u32,asl/asr/lsr(Rs,Rx))
                                   Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,Rs))
                                   Pd = cmpb/h.{eq,gt,gtu} (Rs,##u32)
1   Constant extension is only for a Slot 1 sub-instruction.


                            NOTE      If a constant extender is encoded in a packet for an instruction that does not
                                      accept a constant extender, the execution result is undefined. The assembler
                                      normally ensures that only valid constant extenders are generated.

                         Encoding 32-bit address operands in load/stores

                         Two methods exist for encoding a 32-bit absolute address in a load or store instruction:

                         1) For unconditional load/stores, the GP-relative load/store instruction is used. The
                         assembler encodes the absolute 32-bit address as follows:

                              ï®   The upper 26 bits are encoded in a constant extender
                              ï®   The lower 6 bits are encoded in the 6 operand bits contained in the GP-relative
                                  instruction

                         In this case the 32-bit value encoded must be a plain address, and the value stored in the
                         GP register is ignored.

                            NOTE      When a constant extender is explicitly specified with a GP-relative load/store,
                                      the processor ignores the value in GP and creates the effective address directly
                                      from the 32-bit constant value.

                         2) For conditional load/store instructions that have their base address encoded only by a 6-
                         bit immediate operand, a constant extender must be explicitly specified; otherwise, the
                         execution result is undefined. The assembler ensures that these instructions always include
                         a constant extender.

                         This case applies also to instructions that use the absolute-set addressing mode or
                         absolute-plus-register-offset addressing mode.




80-N2040-36 B                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      164
Hexagon V62 Programmer's Reference Manual                                                  Instruction Encoding



                Encoding 32-bit immediate operands

                The immediate operands of certain instructions use scaled immediates (Section 10.8) to
                increase their addressable range. When constant extenders are used, scaled immediates are
                not scaled by the processor. Instead, the assembler must encode the full 32-bit unscaled
                value as follows:

                     ï®   The upper 26 bits are encoded in the constant extender
                     ï®   The lower 6 bits are encoded in the base instruction in the least-significant bit
                         positions of the immediate operand field.
                     ï®   Any overlapping bits in the base instruction are encoded as zeros.

                Encoding 32-bit jump/call target addresses

                When a jump/call has a constant extender, the resulting target address is forced to a 32-bit
                alignment (i.e., bits 1:0 in the address are cleared by hardware). The resulting jump/call
                operation will never cause an alignment violation.


   10.10        New-value operands
                Instructions that include a new-value register operand specify in their encodings which
                instruction in the packet has its destination register accessed as the new-value register.

                New-value consumers include a 3-bit instruction field named Nt which specifies this
                information.

                     ï®   Nt[0] is reserved and should always be encoded as zero. A non-zero value
                         produces undefined results.
                     ï®   Nt[2:1] encodes the distance (in instructions) from the producer to the consumer,
                         as follows:
                         ï²   Nt[2:1] = 00           // reserved
                         ï²   Nt[2:1] = 01           // producer is +1 instruction ahead of consumer
                         ï²   Nt[2:1] = 10           // producer is +2 instructions ahead of consumer
                         ï²   Nt[2:1] = 11           // producer is +3 instructions ahead of consumer

                âaheadâ is defined here as the instruction encoded at a lower memory address than the
                consumer instruction, not counting empty slots or constant extenders. For example, the
                following producer/consumer relationship would be encoded with Nt[2:1] set to 01.
                    ...
                    <producer instruction word>
                    <consumer constant extender word>
                    <consumer instruction word>
                    ...

                   NOTE      Instructions with 64-bit register pair destinations cannot produce new-values.
                             The assembler flags this case with an error, as the result is undefined.



80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        165
Hexagon V62 Programmer's Reference Manual                                                Instruction Encoding



   10.11        Instruction mapping
                Some Hexagon processor instructions are encoded by the assembler as variants of other
                instructions. This is done for operations that are functionally equivalent to other
                instructions, but are still defined as separate instructions because of their programming
                utility as common operations.

                Table 10-11 lists some of the instructions that are mapped to other instructions.
                Table 10-11 Instruction mapping
                     Instruction                         Mapping
                Rd = not(Rs)           Rd = sub(#-1,Rs)
                Rd = neg(Rs)           Rd = sub(#0,Rs)
                Rdd = Rss              Rdd = combine(Rss.H32, Rss.L32)




80-N2040-36 B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    166
        11 Instruction Set


                This chapter describes the instruction set for version 6 of the Hexagon processor.

                The instructions are listed alphabetically within instruction categories. The following
                information is provided for each instruction:
                     ï®   Instruction name
                     ï®   A brief description of the instruction
                     ï®   A high-level functional description (syntax and behavior) with all possible
                         operand types
                     ï®   Instruction class and slot information for grouping instructions in packets
                     ï®   Notes on miscellaneous issues
                     ï®   Any C intrinsic functions that provide access to the instruction
                     ï®   Instruction encoding




80-N2040-36 B                                        167

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                              Instruction Set



     11.0.1 Instruction categories

                     ï®   ALU32 â 32-bit ALU operations
                         ï²   ALU â Arithmetic and Logical
                         ï²   PERM â Permute
                         ï²   PRED â Predicate
                     ï®   CR â Control registers, looping
                     ï®   JR â Jump from Register
                     ï®   J â Jump
                     ï®   LD â Load
                     ï®   MEMOP â Memory operations
                     ï®   NV â New-value operations
                         ï²   J â New-value jumps
                         ï²   ST â New-value stores
                     ï®   ST â Store operations
                     ï®   SYSTEM
                         ï²   User Instructions
                     ï®   XTYPE â 32-bit and 64-bit operations
                         ï²   ALU â Arithmetic and Logical
                         ï²   BIT â Bit
                         ï²   COMPLEX â Complex
                         ï²   FP â Floating point
                         ï²   MPY â Multiply
                         ï²   PERM â Permute
                         ï²   PRED â Predicate
                         ï²   SHIFT â Shift

                Table 11-1 lists the symbols used to specify the instruction syntax.




80-N2040-36 B                                       168

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                           Instruction Set




                Table 11-1 Instruction syntax symbols
                       Symbol                  Example                                 Meaning
                =                 R2 = R3;                          Assignment of RHS to LHS
                ;                 R2 = R3;                          Marks the end of an instruction or group of
                                                                    instructions
                {â¦}               {R2 = R3; R5 = R6;}               Indicates a group of parallel instructions.
                #                 #100                              Immediate constant value
                ##                ##2147483647                      32-bit immediate constant value
                0x                R2 = #0x1fe;                      Indicates hexadecimal number
                MEMxx             R2 = MEMxx(R3)                    Access memory. xx specifies the size and
                                                                    type of access.
                :sat              R2 = add(r1,r2):sat               Perform optional saturation
                :rnd              R2 = mpy(r1.h,r2.h):rnd           Perform optional rounding
                :<<16             R2 = add(r1.l,r2.l):<<16          Shift left by a halfword




                Table 11-2 lists the symbols used to specify instruction operands.


                Table 11-2 Instruction operand symbols
                     Symbol                 Example                                Meaning
                #uN             R2 = #u16                     Unsigned N-bit immediate value
                #sN             R2 = add(R3,#s16)             Signed N-bit immediate value
                #mN             Rd = mpyi(Rs,#m9)             Signed N-bit immediate value
                #uN:S           R2 = memh(#u16:1)             Unsigned N-bit immediate value representing
                                                              integral multiples of 2S in specified range
                #sN:S           Rd = memw(Rs++#s4:2)          Signed N-bit immediate value representing
                                                              integral multiples of 2S in specified range
                #rN:S           call #r22:2                   Same as #sN:S, but value is offset from PC of
                                                              current packet
                ##              call ##32                     Same as #, but associated value (u,s,m,r) is 32
                                                              bits

                When an instruction contains more than one immediate operand, the operand symbols are
                specified in upper and lower case (e.g., #uN and #UN) to indicate where they appear in the
                instruction encodings.

                The instruction behavior is specified using a superset of the C language. Table 11-3 lists
                symbols not defined in C which are used to specify the instruction behavior.




80-N2040-36 B                                           169

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set




                Table 11-3 Instruction behavior symbols
                   Symbol                Example                               Meaning
                usatN        usat16(Rs)                  Saturate a value to an unsigned N-bit
                satN         sat16(Rs)                   Saturate a value to a signed N-bit number
                sxt x->y     sxt32->64(Rs)               Sign-extend value from x to y bits
                zxt x->y     zxt32->64(Rs)               Zero-extend value from x to y bits
                >>>          Rss >>> offset              Logical right shift




80-N2040-36 B                                      170

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



       11.1 ALU32
                The ALU32 instruction class includes instructions which perform arithmetic and logical
                operations on 32-bit data.

                ALU32 instructions are executable on any slot.


     11.1.1 ALU32/ALU
                The ALU32/ALU instruction subclass includes instructions which perform arithmetic and
                logical operations on individual 32-bit items.

Add
                Add a source register either to another source register or to a signed 16-bit immediate
                value. Store result in destination register. Source and destination registers are 32 bits. If the
                result overflows 32 bits, it wraps around. Optionally saturate result to a signed value
                between 0x80000000 and 0x7fffffff.

                For 64-bit versions of this operation, see the XTYPE add instructions.

                               Syntax                                          Behavior
                Rd=add(Rs,#s16)                        apply_extension(#s);
                                                       Rd=Rs+#s;
                Rd=add(Rs,Rt)                          Rd=Rs+Rt;
                Rd=add(Rs,Rt):sat                      Rd=sat32(Rs+Rt);


                Class: ALU32 (slots 0,1,2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), then the OVF bit in the Status Register is
                         set. OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rd=add(Rs,#s16)             Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)
                Rd=add(Rs,Rt)               Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)
                Rd=add(Rs,Rt):sat           Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)




80-N2040-36 B                                         171

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7   6   5   4   3   2    1   0
    ICLASS                                                   s5           Parse                                                  d5
1   0   1    1   i   i     i     i   i     i     i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=add(Rs,#s16)
    ICLASS       P       MajOp           MinOp               s5           Parse                 t5                               d5
1   1   1    1   0   0    1    1     0    0    0     s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=add(Rs,Rt)
1   1   1    1   0   1    1    0     0    1    0     s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=add(Rs,Rt):sat




                            Field name                                                                   Description
                          MajOp                          Major Opcode
                          MinOp                          Minor Opcode
                          P                              Predicated
                          ICLASS                         Instruction Class
                          Parse                          Packet/Loop parse bits
                          d5                             Field to encode register d
                          s5                             Field to encode register s
                          t5                             Field to encode register t




80-N2040-36 B                                                                         172

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



Logical operations
                           Perform bitwise logical operations (AND, OR, XOR, NOT) either on two source registers
                           or on a source register and a signed 10-bit immediate value. Store result in destination
                           register. Source and destination registers are 32 bits.

                           For 64-bit versions of these operations, see the XTYPE logical instructions.

                                                   Syntax                                                                  Behavior
                            Rd=and(Rs,#s10)                                             apply_extension(#s);
                                                                                        Rd=Rs&#s;
                            Rd=and(Rs,Rt)                                               Rd=Rs&Rt;
                            Rd=and(Rt,~Rs)                                              Rd = (Rt & ~Rs);
                            Rd=not(Rs)                                                  Assembler mapped to: "Rd=sub(#-1,Rs)"
                            Rd=or(Rs,#s10)                                              apply_extension(#s);
                                                                                        Rd=Rs|#s;
                            Rd=or(Rs,Rt)                                                Rd=Rs|Rt;
                            Rd=or(Rt,~Rs)                                               Rd = (Rt | ~Rs);
                            Rd=xor(Rs,Rt)                                               Rd=Rs^Rt;


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics

                            Rd=and(Rs,#s10)                                             Word32 Q6_R_and_RI(Word32 Rs, Word32 Is10)
                            Rd=and(Rs,Rt)                                               Word32 Q6_R_and_RR(Word32 Rs, Word32 Rt)
                            Rd=and(Rt,~Rs)                                              Word32 Q6_R_and_RnR(Word32 Rt, Word32 Rs)
                            Rd=not(Rs)                                                  Word32 Q6_R_not_R(Word32 Rs)
                            Rd=or(Rs,#s10)                                              Word32 Q6_R_or_RI(Word32 Rs, Word32 Is10)
                            Rd=or(Rs,Rt)                                                Word32 Q6_R_or_RR(Word32 Rs, Word32 Rt)
                            Rd=or(Rt,~Rs)                                               Word32 Q6_R_or_RnR(Word32 Rt, Word32 Rs)
                            Rd=xor(Rs,Rt)                                               Word32 Q6_R_xor_RR(Word32 Rs, Word32 Rt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp               s5           Parse                                                  d5
0   1   1    1   0    1    1   0   0    0      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=and(Rs,#s10)
0   1   1    1   0    1    1   0   1    0      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=or(Rs,#s10)
    ICLASS       P        MajOp        MinOp               s5           Parse                 t5                               d5




80-N2040-36 B                                                                       173

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3   2   1   0
1   1   1   1   0   0   0   1   0   0   0   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=and(Rs,Rt)
1   1   1   1   0   0   0   1   0   0   1   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=or(Rs,Rt)
1   1   1   1   0   0   0   1   0   1   1   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=xor(Rs,Rt)
1   1   1   1   0   0   0   1   1   0   0   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=and(Rt,~Rs)
1   1   1   1   0   0   0   1   1   0   1   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=or(Rt,~Rs)




                          Field name                                                          Description
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        Rs                      No Rs read
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        P                       Predicated
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        d5                      Field to encode register d
                        s5                      Field to encode register s
                        t5                      Field to encode register t




80-N2040-36 B                                                               174

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Negate
                Perform arithmetic negation on a source register. Store result in destination register.
                Source and destination registers are 32 bits.

                For 64-bit and saturating versions of this instruction, see the XTYPE-class negate
                instructions.

                               Syntax                                        Behavior
                Rd=neg(Rs)                            Assembler mapped to: "Rd=sub(#0,Rs)"


                Class: N/A

                Intrinsics

                Rd=neg(Rs)                           Word32 Q6_R_neg_R(Word32 Rs)




80-N2040-36 B                                       175

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Nop
                           Perform no operation. This instruction is used for padding and alignment.

                           Within a packet it can be positioned in any slot 0-3.

                                               Syntax                                                                Behavior
                            nop


                           Class: ALU32 (slots 0,1,2,3)

                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
    ICLASS       Rs       MajOp                                    Parse
0   1   1    1   1    1    1   1   -   -   -   -   -   -   -   -   P   P   -   -     -   -   -   -   -   -   -   -    -   -   -   -   nop




                             Field name                                                          Description
                           MajOp                   Major Opcode
                           Rs                      No Rs read
                           ICLASS                  Instruction Class
                           Parse                   Packet/Loop parse bits




80-N2040-36 B                                                                  176

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



Subtract
                           Subtract a source register from either another source register or from a signed 10-bit
                           immediate value. Store result in destination register. Source and destination registers are
                           32 bits. If the result underflows 32 bits, it wraps around. Optionally saturate result to a
                           signed value between 0x8000_0000 and 0x7fff_ffff.

                           For 64-bit versions of this operation, see the XTYPE subtract instructions.

                                                   Syntax                                                                  Behavior
                            Rd=sub(#s10,Rs)                                             apply_extension(#s);
                                                                                        Rd=#s-Rs;
                            Rd=sub(Rt,Rs)                                               Rd=Rt-Rs;
                            Rd=sub(Rt,Rs):sat                                           Rd=sat32(Rt - Rs);


                           Class: ALU32 (slots 0,1,2,3)

                           Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), then the OVF bit in the Status Register is
                                        set. OVF will remain set until explicitly cleared by a transfer to SR.

                           Intrinsics

                            Rd=sub(#s10,Rs)                                             Word32 Q6_R_sub_IR(Word32 Is10, Word32 Rs)
                            Rd=sub(Rt,Rs)                                               Word32 Q6_R_sub_RR(Word32 Rt, Word32 Rs)
                            Rd=sub(Rt,Rs):sat                                           Word32 Q6_R_sub_RR_sat(Word32 Rt, Word32
                                                                                        Rs)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp               s5           Parse                                                  d5
0   1   1    1   0    1    1   0   0    1      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=sub(#s10,Rs)
    ICLASS       P        MajOp        MinOp               s5           Parse                 t5                               d5
1   1   1    1   0    0    1   1   0    0   1      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=sub(Rt,Rs)
1   1   1    1   0    1    1   0   1    1   0      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=sub(Rt,Rs):sat




                             Field name                                                                Description
                           MajOp                       Major Opcode
                           MinOp                       Minor Opcode
                           Rs                          No Rs read
                           MajOp                       Major Opcode
                           MinOp                       Minor Opcode
                           P                           Predicated



80-N2040-36 B                                                                       177

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       178

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Sign extend
                           Sign-extend the least-significant byte or halfword from the source register and place the
                           32-bit result in the destination register.


                                                 Rd=sxth(Rs)                                                   Rd=sxtb(Rs)

                                                                                     Rs                                                             Rs




                                   Sign-extend                                       Rd                    Sign-extend                              Rd


                                                   Syntax                                                              Behavior
                            Rd=sxtb(Rs)                                              Rd = sxt8->32(Rs);
                            Rd=sxth(Rs)                                              Rd = sxt16->32(Rs);


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics


                            Rd=sxtb(Rs)                                              Word32 Q6_R_sxtb_R(Word32 Rs)
                            Rd=sxth(Rs)                                              Word32 Q6_R_sxth_R(Word32 Rs)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp         MinOp             s5           Parse C                                             d5
0   1   1    1   0    0    0   0    1    0   1    s   s   s    s   s   P   P 0   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=sxtb(Rs)
0   1   1    1   0    0    0   0    1    1   1    s   s   s    s   s   P   P 0   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=sxth(Rs)




                             Field name                                                            Description
                           MajOp                      Major Opcode
                           MinOp                      Minor Opcode
                           Rs                         No Rs read
                           C                          Conditional
                           ICLASS                     Instruction Class
                           Parse                      Packet/Loop parse bits
                           d5                         Field to encode register d
                           s5                         Field to encode register s




80-N2040-36 B                                                                    179

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Transfer immediate
                Assign an immediate value to a 32-bit destination register.

                Two types of assignment are supported. The first sign-extends a 16-bit signed immediate
                value to 32 bits. The second assigns a 16-bit unsigned immediate value to either the upper
                or lower 16 bits of the destination register, leaving the other 16 bits unchanged.


                                             Rd=#s16
                             Sign-Extend                   16-bit immediate

                                             Rx.H=#u16
                          16-bit immediate                   Unchanged

                                             Rx.L=#u16
                             Unchanged                     16-bit immediate


                               Syntax                                         Behavior
                Rd=#s16                                apply_extension(#s);
                                                       Rd=#s;
                Rdd=#s8                                if ("#s8<0") {
                                                           Assembler mapped to: "Rdd=combine(#-
                                                       1,#s8)";
                                                       } else {
                                                           Assembler mapped to:
                                                       "Rdd=combine(#0,#s8)";
                                                       };
                Rx.[HL]=#u16                           Rx.h[01]=#u;


                Class: ALU32 (slots 0,1,2,3)

                Intrinsics

                Rd=#s16                             Word32 Q6_R_equals_I(Word32 Is16)
                Rdd=#s8                             Word64 Q6_P_equals_I(Word32 Is8)
                Rx.H=#u16                           Word32 Q6_Rh_equals_I(Word32 Rx, Word32
                                                    Iu16)
                Rx.L=#u16                           Word32 Q6_Rl_equals_I(Word32 Rx, Word32
                                                    Iu16)




80-N2040-36 B                                      180

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp               x5           Parse
0   1   1    1   0    0    0   1   i     i   1     x   x   x    x   x   P   P   i   i     i   i   i   i   i   i   i   i   i   i    i   i   Rx.L=#u16
0   1   1    1   0    0    1   0   i     i   1     x   x   x    x   x   P   P   i   i     i   i   i   i   i   i   i   i   i   i    i   i   Rx.H=#u16
    ICLASS       Rs       MajOp        MinOp                            Parse                                                 d5
0   1   1    1   1    0    0   0   i     i     -   i   i   i    i   i   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=#s16




                             Field name                                                               Description
                           MajOp                       Major Opcode
                           MinOp                       Minor Opcode
                           Rs                          No Rs read
                           ICLASS                      Instruction Class
                           Parse                       Packet/Loop parse bits
                           d5                          Field to encode register d
                           x5                          Field to encode register x




80-N2040-36 B                                                                       181

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Transfer register
                           Transfer a source register to a destination register. Source and destination registers are
                           either 32 bits or 64 bits.

                                                Syntax                                                               Behavior
                            Rd=Rs                                                  Rd=Rs;
                            Rdd=Rss                                                Assembler mapped to:
                                                                                   "Rdd=combine(Rss.H32,Rss.L32)"


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics

                            Rd=Rs                                                  Word32 Q6_R_equals_R(Word32 Rs)
                            Rdd=Rss                                                Word64 Q6_P_equals_P(Word64 Rss)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp            s5           Parse C                                             d5
0   1   1    1   0    0    0   0   0    1   1   s   s   s    s   s   P   P 0   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=Rs




                             Field name                                                          Description
                           MajOp                    Major Opcode
                           MinOp                    Minor Opcode
                           Rs                       No Rs read
                           C                        Conditional
                           ICLASS                   Instruction Class
                           Parse                    Packet/Loop parse bits
                           d5                       Field to encode register d
                           s5                       Field to encode register s




80-N2040-36 B                                                                  182

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector add halfwords
                          Add the two 16-bit halfwords of Rs to the two 16-bit halfwords of Rt. The results are
                          optionally saturated to signed or unsigned 16-bit values.

                                               Syntax                                                                  Behavior
                           Rd=vaddh(Rs,Rt)[:sat]                                    for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=[sat16](Rs.h[i]+Rt.h[i]);
                                                                                    };
                           Rd=vadduh(Rs,Rt):sat                                     for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=usat16(Rs.uh[i]+Rt.uh[i]);
                                                                                    };


                          Class: ALU32 (slots 0,1,2,3)

                          Notes

                                  ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), then the OVF bit in the Status Register is
                                       set. OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                           Rd=vaddh(Rs,Rt)                                          Word32 Q6_R_vaddh_RR(Word32 Rs, Word32 Rt)
                           Rd=vaddh(Rs,Rt):sat                                      Word32 Q6_R_vaddh_RR_sat(Word32 Rs, Word32
                                                                                    Rt)
                           Rd=vadduh(Rs,Rt):sat                                     Word32 Q6_R_vadduh_RR_sat(Word32 Rs, Word32
                                                                                    Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS       P       MajOp        MinOp            s5           Parse                 t5                               d5
1   1   1    1   0   1    1   0   0    0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vaddh(Rs,Rt)
1   1   1    1   0   1    1   0   0    0   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vaddh(Rs,Rt):sat
1   1   1    1   0   1    1   0   0    1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vadduh(Rs,Rt):sat




                            Field name                                                             Description
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          P                        Predicated
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   183

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector average halfwords
                          VAVGH adds the two 16-bit halfwords of Rs to the two 16-bit halfwords of Rd, and shifts
                          the result right by 1 bit. Optionally, a rounding constant is added before shifting.

                          VNAVGH subtracts the two 16-bit halfwords of Rt from the two 16-bit halfwords of Rs,
                          and shifts the result right by 1 bit. For vector negative average with rounding, see the
                          XTYPE VNAVGH instruction.

                                               Syntax                                                                  Behavior
                           Rd=vavgh(Rs,Rt)                                          for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=((Rs.h[i]+Rt.h[i])>>1);
                                                                                    };
                           Rd=vavgh(Rs,Rt):rnd                                      for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=((Rs.h[i]+Rt.h[i]+1)>>1);
                                                                                    };
                           Rd=vnavgh(Rt,Rs)                                         for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=((Rt.h[i]-Rs.h[i])>>1);
                                                                                    };


                          Class: ALU32 (slots 0,1,2,3)

                          Intrinsics


                           Rd=vavgh(Rs,Rt)                                          Word32 Q6_R_vavgh_RR(Word32 Rs, Word32 Rt)
                           Rd=vavgh(Rs,Rt):rnd                                      Word32 Q6_R_vavgh_RR_rnd(Word32 Rs, Word32
                                                                                    Rt)
                           Rd=vnavgh(Rt,Rs)                                         Word32 Q6_R_vnavgh_RR(Word32 Rt, Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS       P       MajOp        MinOp            s5           Parse                 t5                               d5
1   1   1    1   0   1    1   1   -    0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vavgh(Rs,Rt)
1   1   1    1   0   1    1   1   -    0   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vavgh(Rs,Rt):rnd
1   1   1    1   0   1    1   1   -    1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vnavgh(Rt,Rs)




                            Field name                                                             Description
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          P                        Predicated
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   184

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector subtract halfwords
                          Subtract each of the two halfwords in 32-bit vector Rs from the corresponding halfword in
                          vector Rt. Optionally saturate each 16-bit addition to either a signed or unsigned 16-bit
                          value.

                          Applying saturation to the VSUBH instruction clamps the result to the signed range
                          0x8000 to 0x7fff, whereas applying saturation to VSUBUH ensures that the unsigned
                          result is in the range 0 to 0xffff. When saturation is not needed, VSUBH should be used.

                                               Syntax                                                                  Behavior
                           Rd=vsubh(Rt,Rs)[:sat]                                    for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=[sat16](Rt.h[i]-Rs.h[i]);
                                                                                    };
                           Rd=vsubuh(Rt,Rs):sat                                     for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=usat16(Rt.uh[i]-Rs.uh[i]);
                                                                                    };


                          Class: ALU32 (slots 0,1,2,3)

                          Notes

                                  ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), then the OVF bit in the Status Register is
                                       set. OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                           Rd=vsubh(Rt,Rs)                                          Word32 Q6_R_vsubh_RR(Word32 Rt, Word32 Rs)
                           Rd=vsubh(Rt,Rs):sat                                      Word32 Q6_R_vsubh_RR_sat(Word32 Rt, Word32
                                                                                    Rs)
                           Rd=vsubuh(Rt,Rs):sat                                     Word32 Q6_R_vsubuh_RR_sat(Word32 Rt, Word32
                                                                                    Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS       P       MajOp        MinOp            s5           Parse                 t5                               d5
1   1   1    1   0   1    1   0   1    0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vsubh(Rt,Rs)
1   1   1    1   0   1    1   0   1    0   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vsubh(Rt,Rs):sat
1   1   1    1   0   1    1   0   1    1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=vsubuh(Rt,Rs):sat




                            Field name                                                             Description
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          P                        Predicated
                          ICLASS                   Instruction Class



80-N2040-36 B                                                                   185

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       186

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Zero extend
                           Zero-extend the least significant byte or halfword from Rs and place the 32-bit result in
                           Rd.


                                                Rd=zxth(Rs)                                                   Rd=zxtb(Rs)

                                                                                    Rs                                                             Rs




                                   0x0000                                           Rd                    0x000000                                 Rd


                                                  Syntax                                                              Behavior
                            Rd=zxtb(Rs)                                             Assembler mapped to: "Rd=and(Rs,#255)"
                            Rd=zxth(Rs)                                             Rd = zxt16->32(Rs);


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics


                            Rd=zxtb(Rs)                                             Word32 Q6_R_zxtb_R(Word32 Rs)
                            Rd=zxth(Rs)                                             Word32 Q6_R_zxth_R(Word32 Rs)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp             s5           Parse C                                             d5
0   1   1    1   0    0    0   0   1    1   0    s   s   s    s   s   P   P 0   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=zxth(Rs)




                             Field name                                                           Description
                           MajOp                     Major Opcode
                           MinOp                     Minor Opcode
                           Rs                        No Rs read
                           C                         Conditional
                           ICLASS                    Instruction Class
                           Parse                     Packet/Loop parse bits
                           d5                        Field to encode register d
                           s5                        Field to encode register s




80-N2040-36 B                                                                   187

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



     11.1.2 ALU32/PERM
                The ALU32/PERM instruction subclass includes instructions which rearrange or perform
                format conversion on vector data types.

Combine words into doubleword
                Combine halfwords or words into larger values.

                In a halfword combine, either the high or low halfword of the first source register is
                transferred to the most-significant halfword of the destination register, while either the
                high or low halfword of the second source register is transferred to the least-significant
                halfword of the destination register. Source and destination registers are 32 bits.

                In a word combine, the first source register is transferred to the most-significant word of
                the destination register, while the second source register is transferred to the least-
                significant word of the destination register. Source registers are 32 bits and the destination
                register is 64 bits.

                In a variant of word combine, signed 8-bit immediate values (instead of registers) are
                transferred to the most- and least-significant words of the 64-bit destination register.
                Optionally one of the immediate values can be 32 bits.


                       Rd=combine(Rt.[HL],Rs.[HL])


        Rt.H            Rt.L               Rs.H                 Rs.L
                                                                                      Rdd=combine(Rs,Rt)

                Mux                                 Mux                         Rs                           Rt




                                                           Rd                                                     Rdd


                               Syntax                                        Behavior
                Rd=combine(Rt.[HL],Rs.[HL])           Rd = (Rt.uh[01]<<16) | Rs.uh[01];




80-N2040-36 B                                        188

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



                                                   Syntax                                                                  Behavior
                            Rdd=combine(#s8,#S8)                                        apply_extension(#s);
                                                                                        Rdd.w[0]=#S;
                                                                                        Rdd.w[1]=#s;
                            Rdd=combine(#s8,#U6)                                        apply_extension(#U);
                                                                                        Rdd.w[0]=#U;
                                                                                        Rdd.w[1]=#s;
                            Rdd=combine(#s8,Rs)                                         apply_extension(#s);
                                                                                        Rdd.w[0]=Rs;
                                                                                        Rdd.w[1]=#s;
                            Rdd=combine(Rs,#s8)                                         apply_extension(#s);
                                                                                        Rdd.w[0]=#s;
                                                                                        Rdd.w[1]=Rs;
                            Rdd=combine(Rs,Rt)                                          Rdd.w[0]=Rt;
                                                                                        Rdd.w[1]=Rs;


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics


                            Rd=combine(Rt.H,Rs.H)                                       Word32 Q6_R_combine_RhRh(Word32 Rt, Word32
                                                                                        Rs)
                            Rd=combine(Rt.H,Rs.L)                                       Word32 Q6_R_combine_RhRl(Word32 Rt, Word32
                                                                                        Rs)
                            Rd=combine(Rt.L,Rs.H)                                       Word32 Q6_R_combine_RlRh(Word32 Rt, Word32
                                                                                        Rs)
                            Rd=combine(Rt.L,Rs.L)                                       Word32 Q6_R_combine_RlRl(Word32 Rt, Word32
                                                                                        Rs)
                            Rdd=combine(#s8,#S8)                                        Word64 Q6_P_combine_II(Word32 Is8, Word32
                                                                                        IS8)
                            Rdd=combine(#s8,Rs)                                         Word64 Q6_P_combine_IR(Word32 Is8, Word32
                                                                                        Rs)
                            Rdd=combine(Rs,#s8)                                         Word64 Q6_P_combine_RI(Word32 Rs, Word32
                                                                                        Is8)
                            Rdd=combine(Rs,Rt)                                          Word64 Q6_P_combine_RR(Word32 Rs, Word32
                                                                                        Rt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp               s5           Parse                                                  d5
0   1   1    1   0    0    1   1   -    0    0     s   s   s    s   s   P   P 1     i     i   i    i   i   i   i   i   d   d   d    d   d Rdd=combine(Rs,#s8)
0   1   1    1   0    0    1   1   -    0    1     s   s   s    s   s   P   P 1     i     i   i    i   i   i   i   i   d   d   d    d   d Rdd=combine(#s8,Rs)
    ICLASS       Rs       MajOp        MinOp                            Parse                                                  d5
0   1   1    1   1    1    0   0   0     I     I   I   I   I    I   I   P   P   I   i     i   i    i   i   i   i   i   d   d   d    d   d Rdd=combine(#s8,#S8)
0   1   1    1   1    1    0   0   1     -     -   I   I   I    I   I   P   P   I   i     i   i    i   i   i   i   i   d   d   d    d   d Rdd=combine(#s8,#U6)
    ICLASS       P        MajOp        MinOp               s5           Parse                 t5                               d5




80-N2040-36 B                                                                       189

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3   2   1   0
1   1   1   1   0   0   1   1   1   0   0   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=combine(Rt.H,Rs.H)
1   1   1   1   0   0   1   1   1   0   1   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=combine(Rt.H,Rs.L)
1   1   1   1   0   0   1   1   1   1   0   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=combine(Rt.L,Rs.H)
1   1   1   1   0   0   1   1   1   1   1   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rd=combine(Rt.L,Rs.L)
1   1   1   1   0   1   0   1   0   -   -   s   s   s   s   s   P   P   -   t     t   t   t   t   -   -   -   d   d   d   d   d Rdd=combine(Rs,Rt)




                          Field name                                                          Description
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        Rs                      No Rs read
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        P                       Predicated
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        d5                      Field to encode register d
                        s5                      Field to encode register s
                        t5                      Field to encode register t




80-N2040-36 B                                                               190

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                    Instruction Set



Mux
                           Select between two source registers based on the least-significant bit of a predicate
                           register. If the bit is 1, transfer the first source register to the destination register;
                           otherwise, transfer the second source register. Source and destination registers are 32 bits.

                           In a variant of mux, signed 8-bit immediate values can be used instead of registers for
                           either or both source operands.

                           For 64-bit versions of this instruction, see the XTYPE vmux instruction.

                                                         Syntax                                                                       Behavior
                            Rd=mux(Pu,#s8,#S8)                                                apply_extension(#s);
                                                                                              (Pu[0]) ? (Rd=#s):(Rd=#S);
                            Rd=mux(Pu,#s8,Rs)                                                 apply_extension(#s);
                                                                                              (Pu[0]) ? (Rd=#s):(Rd=Rs);
                            Rd=mux(Pu,Rs,#s8)                                                 apply_extension(#s);
                                                                                              (Pu[0]) ? (Rd=Rs):(Rd=#s);
                            Rd=mux(Pu,Rs,Rt)                                                  (Pu[0]) ? (Rd=Rs):(Rd=Rt);


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics


                            Rd=mux(Pu,#s8,#S8)                                                Word32 Q6_R_mux_pII(Byte Pu, Word32 Is8,
                                                                                              Word32 IS8)
                            Rd=mux(Pu,#s8,Rs)                                                 Word32 Q6_R_mux_pIR(Byte Pu, Word32 Is8,
                                                                                              Word32 Rs)
                            Rd=mux(Pu,Rs,#s8)                                                 Word32 Q6_R_mux_pRI(Byte Pu, Word32 Rs,
                                                                                              Word32 Is8)
                            Rd=mux(Pu,Rs,Rt)                                                  Word32 Q6_R_mux_pRR(Byte Pu, Word32 Rs,
                                                                                              Word32 Rt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                          8   7   6    5       4   3   2    1   0
    ICLASS       Rs       MajOp                 u2               s5           Parse                                                       d5
0   1   1    1   0    0    1   1    0       u    u       s   s   s    s   s   P   P 0     i     i   i    i   i   i   i        i   d   d   d    d   d Rd=mux(Pu,Rs,#s8)
0   1   1    1   0    0    1   1    1       u    u       s   s   s    s   s   P   P 0     i     i   i    i   i   i   i        i   d   d   d    d   d Rd=mux(Pu,#s8,Rs)
    ICLASS       Rs                u1                                         Parse                                                       d5
0   1   1    1   1    0    1   u    u       I        I   I   I   I    I   I   P   P   I   i     i   i    i   i   i   i        i   d   d   d    d   d Rd=mux(Pu,#s8,#S8)
    ICLASS       P        MajOp                                  s5           Parse                 t5                   u2               d5
1   1   1    1   0    1    0   0        -   -        -   s   s   s    s   s   P   P   -   t     t   t    t   t   -   u    u       d   d   d    d   d Rd=mux(Pu,Rs,Rt)




80-N2040-36 B                                                                             191

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                MajOp          Major Opcode
                MinOp          Minor Opcode
                Rs             No Rs read
                MajOp          Major Opcode
                P              Predicated
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                u1             Field to encode register u
                u2             Field to encode register u




80-N2040-36 B                                       192

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Shift word by 16
                           ASLH performs an arithmetic left shift of the 32-bit source register by 16 bits (one
                           halfword). The lower 16 bits of the destination are zero-filled.


                                                                                    Rs




                                                              0x0000                Rd


                           ASRH performs an arithmetic right shift of the 32-bit source register by 16 bits (one
                           halfword). The upper 16 bits of the destination are sign-extended.


                                                                                    Rs




                                   Sign-extend                                      Rd


                                                 Syntax                                                               Behavior
                            Rd=aslh(Rs)                                             Rd=Rs<<16;
                            Rd=asrh(Rs)                                             Rd=Rs>>16;


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics

                            Rd=aslh(Rs)                                             Word32 Q6_R_aslh_R(Word32 Rs)
                            Rd=asrh(Rs)                                             Word32 Q6_R_asrh_R(Word32 Rs)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp         MinOp            s5           Parse C                                             d5
0   1   1    1   0    0    0   0    0    0   0   s   s   s    s   s   P   P 0   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=aslh(Rs)
0   1   1    1   0    0    0   0    0    0   1   s   s   s    s   s   P   P 0   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=asrh(Rs)




                             Field name                                                           Description
                           MajOp                     Major Opcode
                           MinOp                     Minor Opcode
                           Rs                        No Rs read
                           C                         Conditional



80-N2040-36 B                                                                   193

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s




80-N2040-36 B                                       194

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



Pack high and low halfwords
                          Pack together the most-significant halfwords from Rs and Rt into the most-significant
                          word of register pair Rdd, and the least-significant halfwords from Rs and Rt into the
                          least-significant halfword of Rdd.


                                                          Rs                                                              Rt




                                                                                                                                               Rdd


                                                  Syntax                                                                  Behavior
                           Rdd=packhl(Rs,Rt)                                           Rdd.h[0]=Rt.h[0];
                                                                                       Rdd.h[1]=Rs.h[0];
                                                                                       Rdd.h[2]=Rt.h[1];
                                                                                       Rdd.h[3]=Rs.h[1];


                          Class: ALU32 (slots 0,1,2,3)

                          Intrinsics

                           Rdd=packhl(Rs,Rt)                                           Word64 Q6_P_packhl_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7   6   5   4   3    2    1   0
    ICLASS       P       MajOp        MinOp               s5           Parse                 t5                                d5
1   1   1    1   0   1    0   1   1     -     -   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d    d    d   d Rdd=packhl(Rs,Rt)




                            Field name                                                                Description
                          MajOp                       Major Opcode
                          MinOp                       Minor Opcode
                          P                           Predicated
                          ICLASS                      Instruction Class
                          Parse                       Packet/Loop parse bits
                          d5                          Field to encode register d
                          s5                          Field to encode register s
                          t5                          Field to encode register t




80-N2040-36 B                                                                      195

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                Instruction Set



        11.1.3 ALU32/PRED
                           The ALU32/PRED instruction subclass includes instructions which perform conditional
                           arithmetic and logical operations based on the values stored in a predicate register, and
                           which produce predicate results. They are executable on any slot.

Conditional add
                           If the least-significant bit of predicate Pu is set, then add a 32-bit source register to either
                           another register or an immediate value. The result is placed in 32-bit destination register. If
                           the predicate is false, the instruction does nothing.

                                                  Syntax                                                                        Behavior
                            if ([!]Pu[.new])                                           if([!]Pu[.new][0]){
                            Rd=add(Rs,#s8)                                                 apply_extension(#s);
                                                                                           Rd=Rs+#s;
                                                                                       } else {
                                                                                           NOP;
                                                                                       };
                            if ([!]Pu[.new])                                           if([!]Pu[.new][0]){
                            Rd=add(Rs,Rt)                                                  Rd=Rs+Rt;
                                                                                       } else {
                                                                                           NOP;
                                                                                       };


                           Class: ALU32 (slots 0,1,2,3)

                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7    6    5       4   3   2    1   0
                                                                             D
    ICLASS       Rs       MajOp    PS        u2           s5           Parse N                                                      d5

0   1   1    1   0    1    0   0   0    u     u   s   s   s    s   s   P   P 0     i     i   i    i   i   i    i        i   d   d   d    d   d if (Pu) Rd=add(Rs,#s8)
0   1   1    1   0    1    0   0   0    u     u   s   s   s    s   s   P   P 1     i     i   i    i   i   i    i        i   d   d   d    d   d if (Pu.new) Rd=add(Rs,#s8)
0   1   1    1   0    1    0   0   1    u     u   s   s   s    s   s   P   P 0     i     i   i    i   i   i    i        i   d   d   d    d   d if (!Pu) Rd=add(Rs,#s8)
0   1   1    1   0    1    0   0   1    u     u   s   s   s    s   s   P   P 1     i     i   i    i   i   i    i        i   d   d   d    d   d if (!Pu.new) Rd=add(Rs,#s8)
                                                                               D
    ICLASS       P        MajOp        MinOp              s5           Parse                 t5           PS       u2               d5
                                                                               N
1   1   1    1   1    0    1   1   0     -    0   s   s   s    s   s   P   P 0     t     t   t    t   t   0    u    u       d   d   d    d   d if (Pu) Rd=add(Rs,Rt)
1   1   1    1   1    0    1   1   0     -    0   s   s   s    s   s   P   P 0     t     t   t    t   t   1    u    u       d   d   d    d   d if (!Pu) Rd=add(Rs,Rt)
1   1   1    1   1    0    1   1   0     -    0   s   s   s    s   s   P   P 1     t     t   t    t   t   0    u    u       d   d   d    d   d if (Pu.new) Rd=add(Rs,Rt)
1   1   1    1   1    0    1   1   0     -    0   s   s   s    s   s   P   P 1     t     t   t    t   t   1    u    u       d   d   d    d   d if (!Pu.new) Rd=add(Rs,Rt)




                             Field name                                                               Description
                           MajOp                      Major Opcode
                           MinOp                      Minor Opcode
                           Rs                         No Rs read
                           DN                         Dot-new
                           PS                         Predicate sense




80-N2040-36 B                                                                      196

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                DN             Dot-new
                MajOp          Major Opcode
                MinOp          Minor Opcode
                P              Predicated
                PS             Predicate sense
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                u2             Field to encode register u




80-N2040-36 B                                       197

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Conditional shift halfword
                           Conditionally shift a halfword.

                           ASLH performs an arithmetic left shift of the 32-bit source register by 16 bits (one
                           halfword). The lower 16 bits of the destination are zero-filled.


                                                                                    Rs




                                                              0x0000                Rd


                           ASRH performs an arithmetic right shift of the 32-bit source register by 16 bits (one
                           halfword). The upper 16 bits of the destination are sign-extended.


                                                                                    Rs




                                   Sign-extend                                      Rd


                                                 Syntax                                                              Behavior
                            if ([!]Pu[.new]) Rd=aslh(Rs) if([!]Pu[.new][0]){
                                                             Rd=Rs<<16;
                                                         } else {
                                                             NOP;
                                                         };
                            if ([!]Pu[.new]) Rd=asrh(Rs) if([!]Pu[.new][0]){
                                                             Rd=Rs>>16;
                                                         } else {
                                                             NOP;
                                                         };


                           Class: ALU32 (slots 0,1,2,3)

                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp         MinOp            s5           Parse C       S dn     u2                          d5
0   1   1    1   0    0    0   0    0    0   0   s   s   s    s   s   P   P 1   -   0    0   u   u   -   -   -   d   d   d    d   d if (Pu) Rd=aslh(Rs)
0   1   1    1   0    0    0   0    0    0   0   s   s   s    s   s   P   P 1   -   0    1   u   u   -   -   -   d   d   d    d   d if (Pu.new) Rd=aslh(Rs)
0   1   1    1   0    0    0   0    0    0   0   s   s   s    s   s   P   P 1   -   1    0   u   u   -   -   -   d   d   d    d   d if (!Pu) Rd=aslh(Rs)




80-N2040-36 B                                                                   198

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                             Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                       8   7   6   5   4   3   2   1   0
0   1   1   1   0   0   0   0   0   0   0   s   s   s   s   s   P   P 1   -   1   1   u   u   -   -   -   d   d   d   d   d if (!Pu.new) Rd=aslh(Rs)
0   1   1   1   0   0   0   0   0   0   1   s   s   s   s   s   P   P 1   -   0   0   u   u   -   -   -   d   d   d   d   d if (Pu) Rd=asrh(Rs)
0   1   1   1   0   0   0   0   0   0   1   s   s   s   s   s   P   P 1   -   0   1   u   u   -   -   -   d   d   d   d   d if (Pu.new) Rd=asrh(Rs)
0   1   1   1   0   0   0   0   0   0   1   s   s   s   s   s   P   P 1   -   1   0   u   u   -   -   -   d   d   d   d   d if (!Pu) Rd=asrh(Rs)
0   1   1   1   0   0   0   0   0   0   1   s   s   s   s   s   P   P 1   -   1   1   u   u   -   -   -   d   d   d   d   d if (!Pu.new) Rd=asrh(Rs)




                          Field name                                                      Description
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        Rs                      No Rs read
                        C                       Conditional
                        S                       Predicate sense
                        dn                      Dot-new
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        d5                      Field to encode register d
                        s5                      Field to encode register s
                        u2                      Field to encode register u




80-N2040-36 B                                                             199

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Conditional combine
                          If the least-significant bit of predicate Pu is set, then the most-significant word of
                          destination Rdd is taken from the first source register Rs, while the least-significant word
                          is taken from the second source register Rt. If the predicate is false, this instruction does
                          nothing.

                                              Syntax                                                                 Behavior
                           if ([!]Pu[.new])                                      if ([!]Pu[.new][0]) {
                           Rdd=combine(Rs,Rt)                                        Rdd.w[0]=Rt;
                                                                                     Rdd.w[1]=Rs;
                                                                                 } else {
                                                                                     NOP;
                                                                                 };


                          Class: ALU32 (slots 0,1,2,3)

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0

    ICLASS       P       MajOp                        s5           Parse D             t5           PS   u2              d5
                                                                         N
1   1   1    1   1   1    0   1   -   -   -   s   s   s    s   s   P   P 0   t     t   t    t   t   0    u   u   d   d   d    d   d if (Pu) Rdd=combine(Rs,Rt)
1   1   1    1   1   1    0   1   -   -   -   s   s   s    s   s   P   P 0   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu) Rdd=combine(Rs,Rt)
1   1   1    1   1   1    0   1   -   -   -   s   s   s    s   s   P   P 1   t     t   t    t   t   0    u   u   d   d   d    d   d  if (Pu.new) Rdd=combine(Rs,Rt)
1   1   1    1   1   1    0   1   -   -   -   s   s   s    s   s   P   P 1   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu.new) Rdd=combine(Rs,Rt)




                            Field name                                                          Description
                          DN                      Dot-new
                          MajOp                   Major Opcode
                          P                       Predicated
                          PS                      Predicate sense
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d5                      Field to encode register d
                          s5                      Field to encode register s
                          t5                      Field to encode register t
                          u2                      Field to encode register u




80-N2040-36 B                                                                200

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Conditional logical operations
                          If the least-significant bit of predicate Pu is set, then do a logical operation on the source
                          values. The result is placed in 32-bit destination register. If the predicate is false, the
                          instruction does nothing.

                                               Syntax                                                                 Behavior
                           if ([!]Pu[.new])                                       if([!]Pu[.new][0]){
                           Rd=and(Rs,Rt)                                              Rd=Rs&Rt;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                           if ([!]Pu[.new])                                       if([!]Pu[.new][0]){
                           Rd=or(Rs,Rt)                                               Rd=Rs|Rt;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                           if ([!]Pu[.new])                                       if([!]Pu[.new][0]){
                           Rd=xor(Rs,Rt)                                              Rd=Rs^Rt;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };


                          Class: ALU32 (slots 0,1,2,3)

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
                                                                          D
    ICLASS       P       MajOp        MinOp            s5           Parse N             t5           PS   u2              d5

1   1   1    1   1   0    0   1   -    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    u   u   d   d   d    d   d if (Pu) Rd=and(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu) Rd=and(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   0   s   s   s    s   s   P   P 1   t     t   t    t   t   0    u   u   d   d   d    d   d if (Pu.new) Rd=and(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   0   s   s   s    s   s   P   P 1   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu.new) Rd=and(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    u   u   d   d   d    d   d if (Pu) Rd=or(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu) Rd=or(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   1   s   s   s    s   s   P   P 1   t    t    t    t   t   0    u   u   d   d   d    d   d if (Pu.new) Rd=or(Rs,Rt)
1   1   1    1   1   0    0   1   -    0   1   s   s   s    s   s   P   P 1   t    t    t    t   t   1    u   u   d   d   d    d   d if (!Pu.new) Rd=or(Rs,Rt)
1   1   1    1   1   0    0   1   -    1   1   s   s   s    s   s   P   P 0   t    t    t    t   t   0    u   u   d   d   d    d   d if (Pu) Rd=xor(Rs,Rt)
1   1   1    1   1   0    0   1   -    1   1   s   s   s    s   s   P   P 0   t    t    t    t   t   1    u   u   d   d   d    d   d if (!Pu) Rd=xor(Rs,Rt)
1   1   1    1   1   0    0   1   -    1   1   s   s   s    s   s   P   P 1   t    t    t    t   t   0    u   u   d   d   d    d   d if (Pu.new) Rd=xor(Rs,Rt)
1   1   1    1   1   0    0   1   -    1   1   s   s   s    s   s   P   P 1   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu.new) Rd=xor(Rs,Rt)




                            Field name                                                           Description
                          DN                       Dot-new
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          P                        Predicated
                          PS                       Predicate sense




80-N2040-36 B                                                                 201

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                u2             Field to encode register u




80-N2040-36 B                                       202

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Conditional subtract
                          If the least-significant bit of predicate Pu is set, then subtract a 32-bit source register Rt
                          from register Rs. The result is placed in a 32-bit destination register. If the predicate is
                          false, the instruction does nothing.

                                                Syntax                                                                 Behavior
                           if ([!]Pu[.new])                                        if([!]Pu[.new][0]){
                           Rd=sub(Rt,Rs)                                               Rd=Rt-Rs;
                                                                                   } else {
                                                                                       NOP;
                                                                                   };


                          Class: ALU32 (slots 0,1,2,3)

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
                                                                           D
    ICLASS       P       MajOp        MinOp             s5           Parse N             t5           PS   u2              d5

1   1   1    1   1   0    1   1   0     -   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    u   u   d   d   d    d   d if (Pu) Rd=sub(Rt,Rs)
1   1   1    1   1   0    1   1   0     -   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu) Rd=sub(Rt,Rs)
1   1   1    1   1   0    1   1   0     -   1   s   s   s    s   s   P   P 1   t     t   t    t   t   0    u   u   d   d   d    d   d if (Pu.new) Rd=sub(Rt,Rs)
1   1   1    1   1   0    1   1   0     -   1   s   s   s    s   s   P   P 1   t     t   t    t   t   1    u   u   d   d   d    d   d if (!Pu.new) Rd=sub(Rt,Rs)




                            Field name                                                            Description
                          DN                        Dot-new
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          P                         Predicated
                          PS                        Predicate sense
                          ICLASS                    Instruction Class
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          u2                        Field to encode register u




80-N2040-36 B                                                                  203

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Conditional sign extend
                           Conditionally sign-extend the least-significant byte or halfword from Rs and put the 32-bit
                           result in Rd.


                                                 Rd=sxth(Rs)                                                  Rd=sxtb(Rs)

                                                                                     Rs                                                            Rs




                                   Sign-extend                                       Rd                   Sign-extend                              Rd


                                                   Syntax                                                             Behavior
                            if ([!]Pu[.new]) Rd=sxtb(Rs) if([!]Pu[.new][0]){
                                                             Rd=sxt8->32(Rs);
                                                         } else {
                                                             NOP;
                                                         };
                            if ([!]Pu[.new]) Rd=sxth(Rs) if([!]Pu[.new][0]){
                                                             Rd=sxt16->32(Rs);
                                                         } else {
                                                             NOP;
                                                         };


                           Class: ALU32 (slots 0,1,2,3)

                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp         MinOp             s5           Parse C       S dn     u2                          d5
0   1   1    1   0    0    0   0    1    0   1    s   s   s    s   s   P   P 1   -   0    0   u   u   -   -   -   d   d   d    d   d if (Pu) Rd=sxtb(Rs)
0   1   1    1   0    0    0   0    1    0   1    s   s   s    s   s   P   P 1   -   0    1   u   u   -   -   -   d   d   d    d   d if (Pu.new) Rd=sxtb(Rs)
0   1   1    1   0    0    0   0    1    0   1    s   s   s    s   s   P   P 1   -   1    0   u   u   -   -   -   d   d   d    d   d if (!Pu) Rd=sxtb(Rs)
0   1   1    1   0    0    0   0    1    0   1    s   s   s    s   s   P   P 1   -   1    1   u   u   -   -   -   d   d   d    d   d if (!Pu.new) Rd=sxtb(Rs)
0   1   1    1   0    0    0   0    1    1   1    s   s   s    s   s   P   P 1   -   0    0   u   u   -   -   -   d   d   d    d   d if (Pu) Rd=sxth(Rs)
0   1   1    1   0    0    0   0    1    1   1    s   s   s    s   s   P   P 1   -   0    1   u   u   -   -   -   d   d   d    d   d if (Pu.new) Rd=sxth(Rs)
0   1   1    1   0    0    0   0    1    1   1    s   s   s    s   s   P   P 1   -   1    0   u   u   -   -   -   d   d   d    d   d if (!Pu) Rd=sxth(Rs)
0   1   1    1   0    0    0   0    1    1   1    s   s   s    s   s   P   P 1   -   1    1   u   u   -   -   -   d   d   d    d   d if (!Pu.new) Rd=sxth(Rs)




                             Field name                                                            Description
                           MajOp                      Major Opcode
                           MinOp                      Minor Opcode
                           Rs                         No Rs read
                           C                          Conditional
                           S                          Predicate sense
                           dn                         Dot-new




80-N2040-36 B                                                                    204

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                u2             Field to encode register u




80-N2040-36 B                                       205

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Conditional transfer
                           If the LSB of predicate Pu is set, transfer register Rs or a signed immediate into
                           destination Rd. If the predicate is false, this instruction does nothing.

                                              Syntax                                                                Behavior
                            if ([!]Pu[.new]) Rd=#s12                              apply_extension(#s);
                                                                                  if ([!]Pu[.new][0]) Rd=#s;
                                                                                  else NOP;
                            if ([!]Pu[.new]) Rd=Rs                                Assembler mapped to: "if ([!]Pu[.new])
                                                                                  Rd=add(Rs,#0)"
                            if ([!]Pu[.new]) Rdd=Rss                              Assembler mapped to: "if ([!]Pu[.new])
                                                                                  Rdd=combine(Rss.H32,Rss.L32)"


                           Class: ALU32 (slots 0,1,2,3)

                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
                                                                          D
    ICLASS       Rs       MajOp    PS   u2                        Parse                                                 d5
                                                                          N
0   1   1    1   1    1    1   0   0    u   u 0   i   i   i   i   P   P 0     i     i   i   i   i   i   i   i   d   d   d    d   d if (Pu) Rd=#s12
0   1   1    1   1    1    1   0   0    u   u 0   i   i   i   i   P   P 1     i     i   i   i   i   i   i   i   d   d   d    d   d if (Pu.new) Rd=#s12
0   1   1    1   1    1    1   0   1    u   u 0   i   i   i   i   P   P 0     i     i   i   i   i   i   i   i   d   d   d    d   d if (!Pu) Rd=#s12
0   1   1    1   1    1    1   0   1    u   u 0   i   i   i   i   P   P 1     i     i   i   i   i   i   i   i   d   d   d    d   d if (!Pu.new) Rd=#s12




                             Field name                                                         Description
                           MajOp                  Major Opcode
                           MinOp                  Minor Opcode
                           Rs                     No Rs read
                           DN                     Dot-new
                           PS                     Predicate sense
                           ICLASS                 Instruction Class
                           Parse                  Packet/Loop parse bits
                           d5                     Field to encode register d
                           u2                     Field to encode register u




80-N2040-36 B                                                                 206

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Conditional zero extend
                           Conditionally zero-extend the least-significant byte or halfword from Rs and put the 32-bit
                           result in Rd.


                                                Rd=zxth(Rs)                                                  Rd=zxtb(Rs)

                                                                                    Rs                                                            Rs




                                   0x0000                                           Rd                   0x000000                                 Rd


                                                  Syntax                                                             Behavior
                            if ([!]Pu[.new]) Rd=zxtb(Rs) if([!]Pu[.new][0]){
                                                             Rd=zxt8->32(Rs);
                                                         } else {
                                                             NOP;
                                                         };
                            if ([!]Pu[.new]) Rd=zxth(Rs) if([!]Pu[.new][0]){
                                                             Rd=zxt16->32(Rs);
                                                         } else {
                                                             NOP;
                                                         };


                           Class: ALU32 (slots 0,1,2,3)

                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp             s5           Parse C       S dn     u2                          d5
0   1   1    1   0    0    0   0   1    0   0    s   s   s    s   s   P   P 1   -   0    0   u   u   -   -   -   d   d   d    d   d if (Pu) Rd=zxtb(Rs)
0   1   1    1   0    0    0   0   1    0   0    s   s   s    s   s   P   P 1   -   0    1   u   u   -   -   -   d   d   d    d   d if (Pu.new) Rd=zxtb(Rs)
0   1   1    1   0    0    0   0   1    0   0    s   s   s    s   s   P   P 1   -   1    0   u   u   -   -   -   d   d   d    d   d if (!Pu) Rd=zxtb(Rs)
0   1   1    1   0    0    0   0   1    0   0    s   s   s    s   s   P   P 1   -   1    1   u   u   -   -   -   d   d   d    d   d if (!Pu.new) Rd=zxtb(Rs)
0   1   1    1   0    0    0   0   1    1   0    s   s   s    s   s   P   P 1   -   0    0   u   u   -   -   -   d   d   d    d   d if (Pu) Rd=zxth(Rs)
0   1   1    1   0    0    0   0   1    1   0    s   s   s    s   s   P   P 1   -   0    1   u   u   -   -   -   d   d   d    d   d if (Pu.new) Rd=zxth(Rs)
0   1   1    1   0    0    0   0   1    1   0    s   s   s    s   s   P   P 1   -   1    0   u   u   -   -   -   d   d   d    d   d if (!Pu) Rd=zxth(Rs)
0   1   1    1   0    0    0   0   1    1   0    s   s   s    s   s   P   P 1   -   1    1   u   u   -   -   -   d   d   d    d   d if (!Pu.new) Rd=zxth(Rs)




                             Field name                                                           Description
                           MajOp                     Major Opcode
                           MinOp                     Minor Opcode
                           Rs                        No Rs read
                           C                         Conditional
                           S                         Predicate sense
                           dn                        Dot-new




80-N2040-36 B                                                                   207

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                u2             Field to encode register u




80-N2040-36 B                                       208

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Compare
                The register form compares two 32-bit registers for unsigned greater than, greater than, or
                equal.

                The immediate form compares a register against a signed or unsigned immediate value.
                The 8-bit predicate register Pd is set to all 1's or all 0's depending on the result. For 64-bit
                versions of this instruction, see the XTYPE compare instructions.

                               Syntax                                         Behavior
                Pd=[!]cmp.eq(Rs,#s10)                  apply_extension(#s);
                                                       Pd=Rs[!]=#s ? 0xff : 0x00;
                Pd=[!]cmp.eq(Rs,Rt)                    Pd=Rs[!]=Rt ? 0xff : 0x00;
                Pd=[!]cmp.gt(Rs,#s10)                  apply_extension(#s);
                                                       Pd=Rs<=#s ? 0xff : 0x00;
                Pd=[!]cmp.gt(Rs,Rt)                    Pd=Rs<=Rt ? 0xff : 0x00;
                Pd=[!]cmp.gtu(Rs,#u9)                  apply_extension(#u);
                                                       Pd=Rs.uw[0]<=#u ? 0xff : 0x00;
                Pd=[!]cmp.gtu(Rs,Rt)                   Pd=Rs.uw[0]<=Rt.uw[0] ? 0xff : 0x00;
                Pd=cmp.ge(Rs,#s8)                      Assembler mapped to: "Pd=cmp.gt(Rs,#s8-1)"
                Pd=cmp.geu(Rs,#u8)                     if ("#u8==0") {
                                                           Assembler mapped to:
                                                       "Pd=cmp.eq(Rs,Rs)";
                                                       } else {
                                                           Assembler mapped to:
                                                       "Pd=cmp.gtu(Rs,#u8-1)";
                                                       };
                Pd=cmp.lt(Rs,Rt)                       Assembler mapped to: "Pd=cmp.gt(Rt,Rs)"
                Pd=cmp.ltu(Rs,Rt)                      Assembler mapped to: "Pd=cmp.gtu(Rt,Rs)"


                Class: ALU32 (slots 0,1,2,3)

                Intrinsics

                Pd=!cmp.eq(Rs,#s10)                    Byte Q6_p_not_cmp_eq_RI(Word32 Rs, Word32
                                                       Is10)
                Pd=!cmp.eq(Rs,Rt)                      Byte Q6_p_not_cmp_eq_RR(Word32 Rs, Word32
                                                       Rt)
                Pd=!cmp.gt(Rs,#s10)                    Byte Q6_p_not_cmp_gt_RI(Word32 Rs, Word32
                                                       Is10)
                Pd=!cmp.gt(Rs,Rt)                      Byte Q6_p_not_cmp_gt_RR(Word32 Rs, Word32
                                                       Rt)
                Pd=!cmp.gtu(Rs,#u9)                    Byte Q6_p_not_cmp_gtu_RI(Word32 Rs, Word32
                                                       Iu9)
                Pd=!cmp.gtu(Rs,Rt)                     Byte Q6_p_not_cmp_gtu_RR(Word32 Rs, Word32
                                                       Rt)




80-N2040-36 B                                        209

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                            Pd=cmp.eq(Rs,#s10)                                          Byte Q6_p_cmp_eq_RI(Word32 Rs, Word32 Is10)
                            Pd=cmp.eq(Rs,Rt)                                            Byte Q6_p_cmp_eq_RR(Word32 Rs, Word32 Rt)
                            Pd=cmp.ge(Rs,#s8)                                           Byte Q6_p_cmp_ge_RI(Word32 Rs, Word32 Is8)
                            Pd=cmp.geu(Rs,#u8)                                          Byte Q6_p_cmp_geu_RI(Word32 Rs, Word32 Iu8)
                            Pd=cmp.gt(Rs,#s10)                                          Byte Q6_p_cmp_gt_RI(Word32 Rs, Word32 Is10)
                            Pd=cmp.gt(Rs,Rt)                                            Byte Q6_p_cmp_gt_RR(Word32 Rs, Word32 Rt)
                            Pd=cmp.gtu(Rs,#u9)                                          Byte Q6_p_cmp_gtu_RI(Word32 Rs, Word32 Iu9)
                            Pd=cmp.gtu(Rs,Rt)                                           Byte Q6_p_cmp_gtu_RR(Word32 Rs, Word32 Rt)
                            Pd=cmp.lt(Rs,Rt)                                            Byte Q6_p_cmp_lt_RR(Word32 Rs, Word32 Rt)
                            Pd=cmp.ltu(Rs,Rt)                                           Byte Q6_p_cmp_ltu_RR(Word32 Rs, Word32 Rt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7   6   5   4   3   2   1    0
    ICLASS       Rs       MajOp        MinOp               s5           Parse                                                          d2
0   1   1    1   0    1    0   1   0    0      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   0   0   0   d    d Pd=cmp.eq(Rs,#s10)
0   1   1    1   0    1    0   1   0    0      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   1   0   0   d    d Pd=!cmp.eq(Rs,#s10)
0   1   1    1   0    1    0   1   0    1      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   0   0   0   d    d Pd=cmp.gt(Rs,#s10)
0   1   1    1   0    1    0   1   0    1      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   1   0   0   d    d Pd=!cmp.gt(Rs,#s10)
0   1   1    1   0    1    0   1   1    0   0      s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   0   0   0   d    d Pd=cmp.gtu(Rs,#u9)
0   1   1    1   0    1    0   1   1    0   0      s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   1   0   0   d    d Pd=!cmp.gtu(Rs,#u9)
    ICLASS       P        MajOp        MinOp               s5           Parse                 t5                                       d2
1   1   1    1   0    0    1   0   -    0   0      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   0   0   0   d    d Pd=cmp.eq(Rs,Rt)
1   1   1    1   0    0    1   0   -    0   0      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   1   0   0   d    d Pd=!cmp.eq(Rs,Rt)
1   1   1    1   0    0    1   0   -    1   0      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   0   0   0   d    d Pd=cmp.gt(Rs,Rt)
1   1   1    1   0    0    1   0   -    1   0      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   1   0   0   d    d Pd=!cmp.gt(Rs,Rt)
1   1   1    1   0    0    1   0   -    1   1      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   0   0   0   d    d Pd=cmp.gtu(Rs,Rt)
1   1   1    1   0    0    1   0   -    1   1      s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   1   0   0   d    d Pd=!cmp.gtu(Rs,Rt)




                             Field name                                                                Description
                           MajOp                       Major Opcode
                           MinOp                       Minor Opcode
                           Rs                          No Rs read
                           MajOp                       Major Opcode
                           MinOp                       Minor Opcode
                           P                           Predicated
                           ICLASS                      Instruction Class
                           Parse                       Packet/Loop parse bits
                           d2                          Field to encode register d
                           s5                          Field to encode register s
                           t5                          Field to encode register t




80-N2040-36 B                                                                       210

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Compare to general register
                           The register form compares two 32-bit registers for unsigned greater than, greater than, or
                           equal. The immediate form compares a register against a signed or unsigned immediate
                           value. The resulting zero or one is placed in a general register.

                                                Syntax                                                                  Behavior
                            Rd=[!]cmp.eq(Rs,#s8)                                     apply_extension(#s);
                                                                                     Rd=(Rs[!]=#s);
                            Rd=[!]cmp.eq(Rs,Rt)                                      Rd=(Rs[!]=Rt);


                           Class: ALU32 (slots 0,1,2,3)

                           Intrinsics


                            Rd=!cmp.eq(Rs,#s8)                                       Word32 Q6_R_not_cmp_eq_RI(Word32 Rs, Word32
                                                                                     Is8)
                            Rd=!cmp.eq(Rs,Rt)                                        Word32 Q6_R_not_cmp_eq_RR(Word32 Rs, Word32
                                                                                     Rt)
                            Rd=cmp.eq(Rs,#s8)                                        Word32 Q6_R_cmp_eq_RI(Word32 Rs, Word32
                                                                                     Is8)
                            Rd=cmp.eq(Rs,Rt)                                         Word32 Q6_R_cmp_eq_RR(Word32 Rs, Word32 Rt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS       Rs       MajOp        MinOp            s5           Parse                                                  d5
0   1   1    1   0    0    1   1   -    1   0   s   s   s    s   s   P   P 1     i     i   i    i   i   i   i   i   d   d   d    d   d Rd=cmp.eq(Rs,#s8)
0   1   1    1   0    0    1   1   -    1   1   s   s   s    s   s   P   P 1     i     i   i    i   i   i   i   i   d   d   d    d   d Rd=!cmp.eq(Rs,#s8)
    ICLASS       P        MajOp        MinOp            s5           Parse                 t5                               d5
1   1   1    1   0    0    1   1   0    1   0   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=cmp.eq(Rs,Rt)
1   1   1    1   0    0    1   1   0    1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   d   d   d    d   d Rd=!cmp.eq(Rs,Rt)




                             Field name                                                             Description
                           MajOp                    Major Opcode
                           MinOp                    Minor Opcode
                           Rs                       No Rs read
                           MajOp                    Major Opcode
                           MinOp                    Minor Opcode
                           P                        Predicated
                           ICLASS                   Instruction Class
                           Parse                    Packet/Loop parse bits
                           d5                       Field to encode register d
                           s5                       Field to encode register s
                           t5                       Field to encode register t




80-N2040-36 B                                                                    211

                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



       11.2 CR
                The CR instruction class includes instructions which manage control registers, including
                hardware looping, modulo addressing, and status flags.

                CR instructions are executable on slot 3.

End loop instructions
                The endloop instructions mark the end of a hardware loop. If the Loop Count (LC) register
                indicates that a loop should continue to iterate, the LC register is decremented and the
                program flow changes to the address in the Start Address (SA) register.

                The endloopN instruction is actually a pseudo-instruction encoded in bits 15:14 of each
                instruction. Therefore, no distinct 32-bit encoding exists for this instruction.

                              Syntax                                      Behavior
                endloop0                             if (USR.LPCFG) {
                                                         if (USR.LPCFG==1) {
                                                             P3=0xff;
                                                         };
                                                         USR.LPCFG=USR.LPCFG-1;
                                                     };
                                                     if (LC0>1) {
                                                         PC=SA0;
                                                         LC0=LC0-1;
                                                     };
                endloop01                            if (USR.LPCFG) {
                                                         if (USR.LPCFG==1) {
                                                              P3=0xff;
                                                         };
                                                         USR.LPCFG=USR.LPCFG-1;
                                                     };
                                                     if (LC0>1) {
                                                         PC=SA0;
                                                         LC0=LC0-1;
                                                     } else {
                                                         if (LC1>1) {
                                                              PC=SA1;
                                                              LC1=LC1-1;
                                                         };
                                                     };
                endloop1                             if (LC1>1) {
                                                         PC=SA1;
                                                         LC1=LC1-1;
                                                     };


                Class: N/A

                Notes

                    ï®   This instruction cannot be grouped in a packet with any program flow
                        instructions.




80-N2040-36 B                                      212

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



                    ï®   The Next PC value is the address immediately following the last instruction in the
                        packet containing this instruction.
                    ï®   The PC value is the address of the start of the packet




80-N2040-36 B                                      213

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                             Instruction Set



Corner detection acceleration
                          The FASTCORNER9 instruction takes the Ps and Pt values and treats them as a circular
                          bit string. If any contiguous nine bits are set around the circle, the result is true, false
                          otherwise. The sense may be optionally inverted. This instruction is used to accelerate
                          FAST corner detection.

                                              Syntax                                                                        Behavior
                          Pd=[!]fastcorner9(Ps,Pt)                                   tmp.h[0]=(Ps<<8)|Pt;
                                                                                     tmp.h[1]=(Ps<<8)|Pt;
                                                                                     for (i = 1; i < 9; i++) {
                                                                                         tmp &= tmp >> 1;
                                                                                     };
                                                                                     Pd = tmp == 0 ? 0xff : 0x00;


                          Class: CR (slot 2,3)

                          Notes

                                  ï®   This instruction may execute on either slot2 or slot3, even though it is a CR-type

                          Intrinsics

                          Pd=!fastcorner9(Ps,Pt)                                     Byte Q6_p_not_fastcorner9_pp(Byte Ps, Byte
                                                                                     Pt)
                          Pd=fastcorner9(Ps,Pt)                                      Byte Q6_p_fastcorner9_pp(Byte Ps, Byte Pt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                     8   7   6   5   4   3    2   1    0
    ICLASS           sm                                       s2       Parse                       t2                                    d2
0   1   1    0   1   0    1   1   0   0   0   0   -   -   s        s   P   P 1   -     -   -   t        t   1   -   -   1    -   -   d    d Pd=fastcorner9(Ps,Pt)
0   1   1    0   1   0    1   1   0   0   0   1   -   -   s        s   P   P 1   -     -   -   t        t   1   -   -   1    -   -   d    d Pd=!fastcorner9(Ps,Pt)




                            Field name                                                                  Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d2                      Field to encode register d
                          s2                      Field to encode register s
                          t2                      Field to encode register t




80-N2040-36 B                                                                    214

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Logical reductions on predicates
                          The ANY8 instruction sets a destination predicate register to 0xff if any of the low 8 bits
                          in source predicate register Ps are set. Otherwise, the predicate is set to 0x00.

                          The ALL8 instruction sets a destination predicate register to 0xff if all of the low 8 bits in
                          the source predicate register Ps are set. Otherwise, the predicate is set to 0x00.

                                              Syntax                                                                   Behavior
                          Pd=all8(Ps)                                                (Ps==0xff) ? (Pd=0xff) : (Pd=0x00);
                          Pd=any8(Ps)                                                Ps ? (Pd=0xff) : (Pd=0x00);


                          Class: CR (slot 2,3)

                          Notes

                                  ï®   This instruction may execute on either slot2 or slot3, even though it is a CR-type

                          Intrinsics

                          Pd=all8(Ps)                                                Byte Q6_p_all8_p(Byte Ps)
                          Pd=any8(Ps)                                                Byte Q6_p_any8_p(Byte Ps)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1    0
    ICLASS           sm                                       s2       Parse                                                        d2
0   1   1    0   1   0    1   1   1   0   0   0   -   -   s        s   P   P 0   -     -   -   -   -   -   -   -   -    -   -   d    d Pd=any8(Ps)
0   1   1    0   1   0    1   1   1   0   1   0   -   -   s        s   P   P 0   -     -   -   -   -   -   -   -   -    -   -   d    d Pd=all8(Ps)




                            Field name                                                             Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d2                      Field to encode register d
                          s2                      Field to encode register s




80-N2040-36 B                                                                    215

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Looping instructions
                          loopN is a single instruction which sets up a hardware loop. The N in the instruction name
                          indicates the set of loop registers to use. Loop0 is the innermost loop, while loop1 is the
                          outer loop.The loopN instruction first sets the Start Address (SA) register based on a PC-
                          relative immediate add. The relative immediate is added to the PC and stored in SA. The
                          Loop Count (LC) register is set to either an unsigned immediate or to a register value.

                                              Syntax                                                                 Behavior
                          loop0(#r7:2,#U10)                                        apply_extension(#r);
                                                                                   #r=#r & ~0x3;
                                                                                   SA0=PC+#r;
                                                                                   LC0=#U;
                                                                                   USR.LPCFG=0;
                          loop0(#r7:2,Rs)                                          apply_extension(#r);
                                                                                   #r=#r & ~0x3;
                                                                                   SA0=PC+#r;
                                                                                   LC0=Rs;
                                                                                   USR.LPCFG=0;
                          loop1(#r7:2,#U10)                                        apply_extension(#r);
                                                                                   #r=#r & ~0x3;
                                                                                   SA1=PC+#r;
                                                                                   LC1=#U;
                          loop1(#r7:2,Rs)                                          apply_extension(#r);
                                                                                   #r=#r & ~0x3;
                                                                                   SA1=PC+#r;
                                                                                   LC1=Rs;


                          Class: CR (slot 3)

                          Notes

                                  ï®   This instruction cannot execute in the last address of a hardware loop.
                                  ï®   The Next PC value is the address immediately following the last instruction in the
                                      packet containing this instruction.
                                  ï®   The PC value is the address of the start of the packet
                                  ï®   A PC-relative address is formed by taking the decoded immediate value and
                                      adding it to the current PC value.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   0    0   0   0   0   0   s   s   s    s   s   P   P   -   i     i   i   i   i   -   -   -   i    i   -   -   -   loop0(#r7:2,Rs)
0   1   1    0   0   0    0   0   0   0   1   s   s   s    s   s   P   P   -   i     i   i   i   i   -   -   -   i    i   -   -   -   loop1(#r7:2,Rs)
    ICLASS           sm                                            Parse
0   1   1    0   1   0    0   1   0   0   0   I   I   I    I   I   P   P   -   i     i   i   i   i   I   I   I   i    i   -   I   I   loop0(#r7:2,#U10)
0   1   1    0   1   0    0   1   0   0   1   I   I   I    I   I   P   P   -   i     i   i   i   i   I   I   I   i    i   -   I   I   loop1(#r7:2,#U10)




80-N2040-36 B                                                                  216

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                sm             Supervisor mode only
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                s5             Field to encode register s




80-N2040-36 B                                       217

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



Add to PC
                          Add an immediate value to the Program Counter (PC) and place the result in a destination
                          register. This instruction is typically used with a constant extender to add a 32-bit
                          immediate value to PC.

                                              Syntax                                                                Behavior
                          Rd=add(pc,#u6)                                          Rd=PC+apply_extension(#u);


                          Class: CR (slot 3)

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           sm                                           Parse                                                 d5
0   1   1    0   1   0    1   0   0   1   0   0   1   0   0   1   P   P   -   i     i   i   i   i   i   -   -   d   d   d    d   d Rd=add(pc,#u6)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d5                      Field to encode register d




80-N2040-36 B                                                                 218

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Pipelined loop instructions
                spNloop0 is a single instruction which sets up a hardware loop with automatic predicate
                control. This features saves code size by enabling many software pipelined loops to be
                generated without prologue code. Upon executing this instruction, the P3 register is
                automatically cleared. After the loop has been executed N times (where N is selectable
                from 1-3), the P3 register is set. The intent is that store instructions in the loop are
                predicated with P3 and thus not enabled during the pipeline warm-up.

                In the spNloop0 instruction the loop 0 (inner-loop) registers are used. This instruction sets
                the Start Address (SA0) register based on a PC-relative immediate add. The relative
                immediate is added to the PC and stored in SA0. The Loop Count (LC0) is set to either an
                unsigned immediate or to a register value. The predicate P3 is cleared. The USR.LPCFG
                bits are set based on the N value.

                               Syntax                                       Behavior
                p3=sp1loop0(#r7:2,#U10)               apply_extension(#r);
                                                      #r=#r & ~0x3;
                                                      SA0=PC+#r;
                                                      LC0=#U;
                                                      USR.LPCFG=1;
                                                      P3=0;
                p3=sp1loop0(#r7:2,Rs)                 apply_extension(#r);
                                                      #r=#r & ~0x3;
                                                      SA0=PC+#r;
                                                      LC0=Rs;
                                                      USR.LPCFG=1;
                                                      P3=0;
                p3=sp2loop0(#r7:2,#U10)               apply_extension(#r);
                                                      #r=#r & ~0x3;
                                                      SA0=PC+#r;
                                                      LC0=#U;
                                                      USR.LPCFG=2;
                                                      P3=0;
                p3=sp2loop0(#r7:2,Rs)                 apply_extension(#r);
                                                      #r=#r & ~0x3;
                                                      SA0=PC+#r;
                                                      LC0=Rs;
                                                      USR.LPCFG=2;
                                                      P3=0;
                p3=sp3loop0(#r7:2,#U10)               apply_extension(#r);
                                                      #r=#r & ~0x3;
                                                      SA0=PC+#r;
                                                      LC0=#U;
                                                      USR.LPCFG=3;
                                                      P3=0;
                p3=sp3loop0(#r7:2,Rs)                 apply_extension(#r);
                                                      #r=#r & ~0x3;
                                                      SA0=PC+#r;
                                                      LC0=Rs;
                                                      USR.LPCFG=3;
                                                      P3=0;




80-N2040-36 B                                       219

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Class: CR (slot 3)

                          Notes

                                  ï®   The predicate generated by this instruction can not be used as a .new predicate,
                                      nor can it be automatically ANDed with another predicate.
                                  ï®   This instruction cannot execute in the last address of a hardware loop.
                                  ï®   The Next PC value is the address immediately following the last instruction in the
                                      packet containing this instruction.
                                  ï®   The PC value is the address of the start of the packet
                                  ï®   A PC-relative address is formed by taking the decoded immediate value and
                                      adding it to the current PC value.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   0    0   0   1   0   1   s   s   s    s   s   P   P   -   i     i   i   i   i   -   -   -   i   i   -   -   -   p3=sp1loop0(#r7:2,Rs)
0   1   1    0   0   0    0   0   1   1   0   s   s   s    s   s   P   P   -   i     i   i   i   i   -   -   -   i   i   -   -   -   p3=sp2loop0(#r7:2,Rs)
0   1   1    0   0   0    0   0   1   1   1   s   s   s    s   s   P   P   -   i     i   i   i   i   -   -   -   i   i   -   -   -   p3=sp3loop0(#r7:2,Rs)
    ICLASS           sm                                            Parse
0   1   1    0   1   0    0   1   1   0   1   I   I   I    I   I   P   P   -   i     i   i   i   i   I   I   I   i   i   -   I   I   p3=sp1loop0(#r7:2,#U10)
0   1   1    0   1   0    0   1   1   1   0   I   I   I    I   I   P   P   -   i     i   i   i   i   I   I   I   i   i   -   I   I   p3=sp2loop0(#r7:2,#U10)
0   1   1    0   1   0    0   1   1   1   1   I   I   I    I   I   P   P   -   i     i   i   i   i   I   I   I   i   i   -   I   I   p3=sp3loop0(#r7:2,#U10)




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  220

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Logical operations on predicates
                Perform bitwise logical operations on predicate registers.

                              Syntax                                         Behavior
                Pd=Ps                                Assembler mapped to: "Pd=or(Ps,Ps)"
                Pd=and(Ps,and(Pt,[!]Pu))             Pd = Ps & Pt & (~Pu);
                Pd=and(Ps,or(Pt,[!]Pu))              Pd = Ps & (Pt | (~Pu));
                Pd=and(Pt,[!]Ps)                     Pd=Pt & (~Ps);
                Pd=not(Ps)                           Pd=~Ps;
                Pd=or(Ps,and(Pt,[!]Pu))              Pd = Ps | (Pt & (~Pu));
                Pd=or(Ps,or(Pt,[!]Pu))               Pd = Ps | Pt | (~Pu);
                Pd=or(Pt,[!]Ps)                      Pd=Pt | (~Ps);
                Pd=xor(Ps,Pt)                        Pd=Ps ^ Pt;


                Class: CR (slot 2,3)

                Notes

                    ï®   This instruction may execute on either slot2 or slot3, even though it is a CR-type

                Intrinsics

                Pd=Ps                               Byte Q6_p_equals_p(Byte Ps)
                Pd=and(Ps,and(Pt,!Pu))              Byte Q6_p_and_and_ppnp(Byte Ps, Byte Pt,
                                                    Byte Pu)
                Pd=and(Ps,and(Pt,Pu))               Byte Q6_p_and_and_ppp(Byte Ps, Byte Pt,
                                                    Byte Pu)
                Pd=and(Ps,or(Pt,!Pu))               Byte Q6_p_and_or_ppnp(Byte Ps, Byte Pt,
                                                    Byte Pu)
                Pd=and(Ps,or(Pt,Pu))                Byte Q6_p_and_or_ppp(Byte Ps, Byte Pt, Byte
                                                    Pu)
                Pd=and(Pt,!Ps)                      Byte Q6_p_and_pnp(Byte Pt, Byte Ps)
                Pd=and(Pt,Ps)                       Byte Q6_p_and_pp(Byte Pt, Byte Ps)
                Pd=not(Ps)                          Byte Q6_p_not_p(Byte Ps)
                Pd=or(Ps,and(Pt,!Pu))               Byte Q6_p_or_and_ppnp(Byte Ps, Byte Pt,
                                                    Byte Pu)
                Pd=or(Ps,and(Pt,Pu))                Byte Q6_p_or_and_ppp(Byte Ps, Byte Pt, Byte
                                                    Pu)




80-N2040-36 B                                      221

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                 Instruction Set



                          Pd=or(Ps,or(Pt,!Pu))                                       Byte Q6_p_or_or_ppnp(Byte Ps, Byte Pt, Byte
                                                                                     Pu)
                          Pd=or(Ps,or(Pt,Pu))                                        Byte Q6_p_or_or_ppp(Byte Ps, Byte Pt, Byte
                                                                                     Pu)
                          Pd=or(Pt,!Ps)                                              Byte Q6_p_or_pnp(Byte Pt, Byte Ps)
                          Pd=or(Pt,Ps)                                               Byte Q6_p_or_pp(Byte Pt, Byte Ps)
                          Pd=xor(Ps,Pt)                                              Byte Q6_p_xor_pp(Byte Ps, Byte Pt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                     8   7    6       5   4   3   2   1    0
    ICLASS           sm                                       s2       Parse                       t2                                        d2
0   1   1    0   1   0    1   1   0   0   0   0   -   -   s        s   P   P 0   -     -   -   t        t   -        -   -   -   -   -   d    d Pd=and(Pt,Ps)
    ICLASS           sm                                       s2       Parse                       t2           u2                           d2
0   1   1    0   1   0    1   1   0   0   0   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=and(Ps,and(Pt,Pu))
    ICLASS           sm                                       s2       Parse                       t2                                        d2
0   1   1    0   1   0    1   1   0   0   1   0   -   -   s        s   P   P 0   -     -   -   t        t   -        -   -   -   -   -   d    d Pd=or(Pt,Ps)
    ICLASS           sm                                       s2       Parse                       t2           u2                           d2
0   1   1    0   1   0    1   1   0   0   1   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=and(Ps,or(Pt,Pu))
    ICLASS           sm                                       s2       Parse                       t2                                        d2
0   1   1    0   1   0    1   1   0   1   0   0   -   -   s        s   P   P 0   -     -   -   t        t   -        -   -   -   -   -   d    d Pd=xor(Ps,Pt)
    ICLASS           sm                                       s2       Parse                       t2           u2                           d2
0   1   1    0   1   0    1   1   0   1   0   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=or(Ps,and(Pt,Pu))
    ICLASS           sm                                       s2       Parse                       t2                                        d2
0   1   1    0   1   0    1   1   0   1   1   0   -   -   s        s   P   P 0   -     -   -   t        t   -        -   -   -   -   -   d    d Pd=and(Pt,!Ps)
    ICLASS           sm                                       s2       Parse                       t2           u2                           d2
0   1   1    0   1   0    1   1   0   1   1   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=or(Ps,or(Pt,Pu))
0   1   1    0   1   0    1   1   1   0   0   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=and(Ps,and(Pt,!Pu))
0   1   1    0   1   0    1   1   1   0   1   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=and(Ps,or(Pt,!Pu))
    ICLASS           sm                                       s2       Parse                                                                 d2
0   1   1    0   1   0    1   1   1   1   0   0   -   -   s        s   P   P 0   -     -   -   -        -   -        -   -   -   -   -   d    d Pd=not(Ps)
    ICLASS           sm                                       s2       Parse                       t2           u2                           d2
0   1   1    0   1   0    1   1   1   1   0   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=or(Ps,and(Pt,!Pu))
    ICLASS           sm                                       s2       Parse                       t2                                        d2
0   1   1    0   1   0    1   1   1   1   1   0   -   -   s        s   P   P 0   -     -   -   t        t   -        -   -   -   -   -   d    d Pd=or(Pt,!Ps)
    ICLASS           sm                                       s2       Parse                       t2           u2                           d2
0   1   1    0   1   0    1   1   1   1   1   1   -   -   s        s   P   P 0   -     -   -   t        t   u    u       -   -   -   -   d    d Pd=or(Ps,or(Pt,!Pu))




                            Field name                                                                  Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d2                      Field to encode register d
                          s2                      Field to encode register s
                          t2                      Field to encode register t
                          u2                      Field to encode register u




80-N2040-36 B                                                                    222

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                           Instruction Set



User control register transfer
                          Move 32- or 64-bit values between a user control register and a general register. The user
                          control registers include SA, LC, Predicates, M, USR, PC, UGP, GP, and CS, and
                          UPCYCLE. The figure shows the user control registers and their register field encodings.

                          Registers can be moved as singles or as aligned 64-bit pairs.

                          Note that the PC register is not writable. A program flow instruction must be used to
                          change the PC value.


                              0               SA0                 8                 USR                 16                                  24


                              1               LC0                 9                 PC

                              2               SA1                 10                UGP

                              3               LC1                 11                GP
                                                                                                                     Reserved                            Reserved
                              4               P3:0                12                CS0


                              5           Reserved                13                CS1

                              6               M0                  14           UPCYCLELO

                              7               M1                               UPCYCLEHI
                                                                  15                                    23                                   31




                                                     Syntax                                                                         Behavior
                          Cd=Rs                                                               Cd=Rs;
                          Cdd=Rss                                                             Cdd=Rss;
                          Rd=Cs                                                               Rd=Cs;
                          Rdd=Css                                                             Rdd=Css;


                          Class: CR (slot 3)

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                          8   7    6    5    4   3   2        1   0
    ICLASS           sm                                      s5            Parse                                                        d5
0   1   1    0   0   0    1       0   0   0    1     s   s   s    s    s   P    P    -    -     -   -   -    -   -     -   -    d   d   d        d   d Cd=Rs
0   1   1    0   0   0    1       1   0   0    1     s   s   s    s    s   P    P    -    -     -   -   -    -   -     -   -    d   d   d        d   d Cdd=Rss
0   1   1    0   1   0    0       0   0   0    0     s   s   s    s    s   P    P    -    -     -   -   -    -   -     -   -    d   d   d        d   d Rdd=Css
0   1   1    0   1   0    1       0   0   0    0     s   s   s    s    s   P    P    -    -     -   -   -    -   -     -   -    d   d   d        d   d Rd=Cs




                            Field name                                                                       Description
                          sm                             Supervisor mode only
                          ICLASS                         Instruction Class




80-N2040-36 B                                                                             223

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s




80-N2040-36 B                                       224

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



        11.3 JR
                         The JR instruction class includes instructions to change the program flow to a new
                         location contained in a register.

                         JR instructions are executable on slot 2.

Call subroutine from register
                         Change the program flow to a subroutine. This instruction first transfers the Next Program
                         Counter (NPC) value into the Link Register, and then jumps to a target address contained
                         in a register.

                         This instruction can only appear in slot 2.

                                             Syntax                                                                      Behavior
                         callr Rs                                                 LR=NPC;
                                                                                  PC=Rs;
                                                                                  ;
                         if ([!]Pu) callr Rs                                      ;
                                                                                  if ([!]Pu[0]) {
                                                                                      LR=NPC;
                                                                                      PC=Rs;
                                                                                  ;
                                                                                  };


                         Class: JR (slot 2)

                         Notes

                                 ï®   This instruction can be conditionally executed based on the value of a predicate
                                     register. If the instruction is preceded by 'if Pn', then the instruction only executes
                                     if the least-significant bit of the predicate register is 1. Similarly, if the instruction
                                     is preceded by 'if !Pn', then the instruction is executed only if the least-significant
                                     bit of Pn is 0.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8       7   6   5   4   3    2   1   0
    ICLASS                                           s5           Parse
0   1   0    1   0   0   0   0   1   0   1   s   s   s    s   s   P   P   -   -     -   -   -        -   -   -   -   -    -   -   -   -   callr Rs
    ICLASS                                           s5           Parse                         u2
0   1   0    1   0   0   0   1   0   0   0   s   s   s    s   s   P   P   -   -     -   -   u    u       -   -   -   -    -   -   -   -   if (Pu) callr Rs
0   1   0    1   0   0   0   1   0   0   1   s   s   s    s   s   P   P   -   -     -   -   u    u       -   -   -   -    -   -   -   -   if (!Pu) callr Rs




                           Field name                                                                Description
                         ICLASS                  Instruction Class




80-N2040-36 B                                                                 225

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                Parse          Packet/Loop parse bits
                s5             Field to encode register s
                u2             Field to encode register u




80-N2040-36 B                                       226

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



Hint an indirect jump address
                         Provide a hint indicating that there will soon be an indirect JUMPR to the address
                         specified in Rs.

                                             Syntax                                                                   Behavior
                         hintjr(Rs)                                               ;


                         Class: JR (slot 2)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1   0
    ICLASS                                           s5           Parse
0   1   0    1   0   0   1   0   1   0   1   s   s   s    s   s   P   P   -   -       -   -   -   -   -   -   -   -    -   -   -   -   hintjr(Rs)




                           Field name                                                             Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s




80-N2040-36 B                                                                 227

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



Jump to address from register
                         Change the program flow to a target address. This instruction changes the Program
                         Counter to a target address contained in a register.

                         This instruction can appear only in slot 2.

                                             Syntax                                                                      Behavior
                         if ([!]Pu) jumpr Rs                                      Assembler mapped to: "if ([!]Pu)
                                                                                  ""jumpr"":nt ""Rs"
                         if ([!]Pu[.new])                                         };
                         jumpr:<hint> Rs                                          {
                                                                                  if([!]Pu[.new][0]){
                                                                                      PC=Rs;
                                                                                  ;
                                                                                  };
                         jumpr Rs                                                 PC=Rs;


                         Class: JR (slot 2)

                         Notes

                                 ï®   This instruction can be conditionally executed based on the value of a predicate
                                     register. If the instruction is preceded by 'if Pn', then the instruction only executes
                                     if the least-significant bit of the predicate register is 1. Similarly, if the instruction
                                     is preceded by 'if !Pn', then the instruction is executed only if the least-significant
                                     bit of Pn is 0.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8       7   6   5   4   3    2   1   0
    ICLASS                                           s5           Parse
0   1   0    1   0   0   1   0   1   0   0   s   s   s    s   s   P   P   -   -     -   -   -        -   -   -   -   -    -   -   -   -   jumpr Rs
    ICLASS                                           s5           Parse                         u2
0   1   0    1   0   0   1   1   0   1   0   s   s   s    s   s   P   P   -   0    0    -   u    u       -   -   -   -    -   -   -   -   if (Pu) jumpr:nt Rs
0   1   0    1   0   0   1   1   0   1   0   s   s   s    s   s   P   P   -   0    1    -   u    u       -   -   -   -    -   -   -   -   if (Pu.new) jumpr:nt Rs
0   1   0    1   0   0   1   1   0   1   0   s   s   s    s   s   P   P   -   1    0    -   u    u       -   -   -   -    -   -   -   -   if (Pu) jumpr:t Rs
0   1   0    1   0   0   1   1   0   1   0   s   s   s    s   s   P   P   -   1    1    -   u    u       -   -   -   -    -   -   -   -   if (Pu.new) jumpr:t Rs
0   1   0    1   0   0   1   1   0   1   1   s   s   s    s   s   P   P   -   0    0    -   u    u       -   -   -   -    -   -   -   -   if (!Pu) jumpr:nt Rs
0   1   0    1   0   0   1   1   0   1   1   s   s   s    s   s   P   P   -   0    1    -   u    u       -   -   -   -    -   -   -   -   if (!Pu.new) jumpr:nt Rs
0   1   0    1   0   0   1   1   0   1   1   s   s   s    s   s   P   P   -   1    0    -   u    u       -   -   -   -    -   -   -   -   if (!Pu) jumpr:t Rs
0   1   0    1   0   0   1   1   0   1   1   s   s   s    s   s   P   P   -   1    1    -   u    u       -   -   -   -    -   -   -   -   if (!Pu.new) jumpr:t Rs




                           Field name                                                                Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s
                         u2                      Field to encode register u



80-N2040-36 B                                                                 228

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                            Instruction Set



       11.4 J
                The J instruction class includes branch instructions (jumps and calls) that obtain the target
                address from a (PC-relative) immediate address value.

                J instructions are executable on slot 2 and slot 3.

Call subroutine
                Change the program flow to a subroutine. This instruction first transfers the Next Program
                Counter (NPC) value into the Link Register, and then jumps to the target address.

                This instruction can appear in slots 2 or 3.

                                Syntax                                          Behavior
                call #r22:2                             apply_extension(#r);
                                                        #r=#r & ~0x3;
                                                        LR=NPC;
                                                        PC=PC+#r;
                                                        ;
                if ([!]Pu) call #r15:2                  apply_extension(#r);
                                                        #r=#r & ~0x3;
                                                        ;
                                                        if ([!]Pu[0]) {
                                                            LR=NPC;
                                                            PC=PC+#r;
                                                        ;
                                                        };


                Class: J (slots 2,3)

                Notes

                     ï®   This instruction can be conditionally executed based on the value of a predicate
                         register. If the instruction is preceded by 'if Pn', then the instruction only executes
                         if the least-significant bit of the predicate register is 1. Similarly, if the instruction
                         is preceded by 'if !Pn', then the instruction is executed only if the least-significant
                         bit of Pn is 0.
                     ï®   The Next PC value is the address immediately following the last instruction in the
                         packet containing this instruction.
                     ï®   The PC value is the address of the start of the packet
                     ï®   A PC-relative address is formed by taking the decoded immediate value and
                         adding it to the current PC value.




80-N2040-36 B                                          229

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8       7   6   5   4   3   2   1   0
    ICLASS                                                       Parse
0   1   0    1   1   0   1   i   i   i   i   i   i   i   i   i   P   P   i   i     i   i   i        i   i   i   i   i   i   i   i   0   call #r22:2
                                                                                 D
    ICLASS                                                       Parse                         u2
                                                                                 N
0   1   0    1   1   1   0   1   i   i   0   i   i   i   i   i   P   P   i   -   0     -   u    u       i   i   i   i   i   i   i   -   if (Pu) call #r15:2
0   1   0    1   1   1   0   1   i   i   1   i   i   i   i   i   P   P   i   -   0     -   u    u       i   i   i   i   i   i   i   -   if (!Pu) call #r15:2




                           Field name                                                               Description
                         ICLASS                  Instruction Class
                         DN                      Dot-new
                         Parse                   Packet/Loop parse bits
                         u2                      Field to encode register u




80-N2040-36 B                                                                230

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Compare and jump
                Compare two registers, or a register and immediate value, and write a predicate with the
                result. Then use the predicate result to conditionally jump to a PC-relative target address.

                The registers available as operands are restricted to R0-R7 and R16-R23. The predicate
                destination is restricted to P0 and P1.

                In assembly syntax, this instruction appears as two instructions in the packet: a compare
                and a separate conditional jump. The assembler may convert adjacent compare and jump
                instructions into compound compare-jump form.

                               Syntax                                       Behavior
                p[01]=cmp.eq(Rs,#-1); if             P[01]=(Rs==-1) ? 0xff : 0x00 if
                ([!]p[01].new) jump:<hint>           ([!]P[01].new[0]) {
                #r9:2                                    apply_extension(#r);
                                                         #r=#r & ~0x3;
                                                         PC=PC+#r;
                                                     };
                p[01]=cmp.eq(Rs,#U5); if             P[01]=(Rs==#U) ? 0xff : 0x00 if
                ([!]p[01].new) jump:<hint>           ([!]P[01].new[0]) {
                #r9:2                                    apply_extension(#r);
                                                         #r=#r & ~0x3;
                                                         PC=PC+#r;
                                                     };
                p[01]=cmp.eq(Rs,Rt); if              P[01]=(Rs==Rt) ? 0xff : 0x00 if
                ([!]p[01].new) jump:<hint>           ([!]P[01].new[0]) {
                #r9:2                                    apply_extension(#r);
                                                         #r=#r & ~0x3;
                                                         PC=PC+#r;
                                                     };
                p[01]=cmp.gt(Rs,#-1); if             P[01]=(Rs>-1) ? 0xff : 0x00 if
                ([!]p[01].new) jump:<hint>           ([!]P[01].new[0]) {
                #r9:2                                    apply_extension(#r);
                                                         #r=#r & ~0x3;
                                                         PC=PC+#r;
                                                     };




80-N2040-36 B                                       231

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                                             Syntax                                                                   Behavior
                         p[01]=cmp.gt(Rs,#U5); if                                   P[01]=(Rs>#U) ? 0xff : 0x00 if
                         ([!]p[01].new) jump:<hint>                                 ([!]P[01].new[0]) {
                         #r9:2                                                          apply_extension(#r);
                                                                                        #r=#r & ~0x3;
                                                                                        PC=PC+#r;
                                                                                    };
                         p[01]=cmp.gt(Rs,Rt); if                                    P[01]=(Rs>Rt) ? 0xff : 0x00 if
                         ([!]p[01].new) jump:<hint>                                 ([!]P[01].new[0]) {
                         #r9:2                                                          apply_extension(#r);
                                                                                        #r=#r & ~0x3;
                                                                                        PC=PC+#r;
                                                                                    };
                         p[01]=cmp.gtu(Rs,#U5); if                                  P[01]=(Rs.uw[0]>#U) ? 0xff : 0x00 if
                         ([!]p[01].new) jump:<hint>                                 ([!]P[01].new[0]) {
                         #r9:2                                                          apply_extension(#r);
                                                                                        #r=#r & ~0x3;
                                                                                        PC=PC+#r;
                                                                                    };
                         p[01]=cmp.gtu(Rs,Rt); if                                   P[01]=(Rs.uw[0]>Rt) ? 0xff : 0x00 if
                         ([!]p[01].new) jump:<hint>                                 ([!]P[01].new[0]) {
                         #r9:2                                                          apply_extension(#r);
                                                                                        #r=#r & ~0x3;
                                                                                        PC=PC+#r;
                                                                                    };
                         p[01]=tstbit(Rs,#0); if                                    P[01]=(Rs & 1) ? 0xff : 0x00 if
                         ([!]p[01].new) jump:<hint>                                 ([!]P[01].new[0]) {
                         #r9:2                                                          apply_extension(#r);
                                                                                        #r=#r & ~0x3;
                                                                                        PC=PC+#r;
                                                                                    };


                         Class: J (slots 0,1,2,3)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1   0
    ICLASS                                               s4           Parse
0   0   0    1   0   0   0   1   1   0   i   i   s   s        s   s   P   P 0   -     -   -   0   0   i   i   i   i    i   i   i   -   p0=cmp.eq(Rs,#-1); if (p0.new) jump:nt #r9:2
0   0   0    1   0   0   0   1   1   0   i   i   s   s        s   s   P   P 0   -     -   -   0   1   i   i   i   i    i   i   i   -   p0=cmp.gt(Rs,#-1); if (p0.new) jump:nt #r9:2
0   0   0    1   0   0   0   1   1   0   i   i   s   s        s   s   P   P 0   -     -   -   1   1   i   i   i   i    i   i   i   -   p0=tstbit(Rs,#0); if (p0.new) jump:nt #r9:2
0   0   0    1   0   0   0   1   1   0   i   i   s   s        s   s   P   P 1   -     -   -   0   0   i   i   i   i    i   i   i   -   p0=cmp.eq(Rs,#-1); if (p0.new) jump:t #r9:2
0   0   0    1   0   0   0   1   1   0   i   i   s   s        s   s   P   P 1   -     -   -   0   1   i   i   i   i    i   i   i   -   p0=cmp.gt(Rs,#-1); if (p0.new) jump:t #r9:2
0   0   0    1   0   0   0   1   1   0   i   i   s   s        s   s   P   P 1   -     -   -   1   1   i   i   i   i    i   i   i   -   p0=tstbit(Rs,#0); if (p0.new) jump:t #r9:2
0   0   0    1   0   0   0   1   1   1   i   i   s   s        s   s   P   P 0   -     -   -   0   0   i   i   i   i    i   i   i   -   p0=cmp.eq(Rs,#-1); if (!p0.new) jump:nt #r9:2
0   0   0    1   0   0   0   1   1   1   i   i   s   s        s   s   P   P 0   -     -   -   0   1   i   i   i   i    i   i   i   -   p0=cmp.gt(Rs,#-1); if (!p0.new) jump:nt #r9:2
0   0   0    1   0   0   0   1   1   1   i   i   s   s        s   s   P   P 0   -     -   -   1   1   i   i   i   i    i   i   i   -   p0=tstbit(Rs,#0); if (!p0.new) jump:nt #r9:2




80-N2040-36 B                                                                   232

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                 Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                         8   7   6   5   4   3   2   1   0
0   0   0   1   0   0   0   1   1   1   i   i   s   s   s   s   P   P 1   -     -   -   0   0   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,#-1); if (!p0.new) jump:t #r9:2
0   0   0   1   0   0   0   1   1   1   i   i   s   s   s   s   P   P 1   -     -   -   0   1   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,#-1); if (!p0.new) jump:t #r9:2
0   0   0   1   0   0   0   1   1   1   i   i   s   s   s   s   P   P 1   -     -   -   1   1   i   i   i   i   i   i   i   -   p0=tstbit(Rs,#0); if (!p0.new) jump:t #r9:2
0   0   0   1   0   0   0   0   0   0   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,#U5); if (p0.new) jump:nt #r9:2
0   0   0   1   0   0   0   0   0   0   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,#U5); if (p0.new) jump:t #r9:2
0   0   0   1   0   0   0   0   0   1   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,#U5); if (!p0.new) jump:nt #r9:2
0   0   0   1   0   0   0   0   0   1   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,#U5); if (!p0.new) jump:t #r9:2
0   0   0   1   0   0   0   0   1   0   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,#U5); if (p0.new) jump:nt #r9:2
0   0   0   1   0   0   0   0   1   0   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,#U5); if (p0.new) jump:t #r9:2
0   0   0   1   0   0   0   0   1   1   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,#U5); if (!p0.new) jump:nt #r9:2
0   0   0   1   0   0   0   0   1   1   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,#U5); if (!p0.new) jump:t #r9:2
0   0   0   1   0   0   0   1   0   0   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,#U5); if (p0.new) jump:nt #r9:2
0   0   0   1   0   0   0   1   0   0   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,#U5); if (p0.new) jump:t #r9:2
0   0   0   1   0   0   0   1   0   1   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,#U5); if (!p0.new) jump:nt #r9:2
0   0   0   1   0   0   0   1   0   1   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,#U5); if (!p0.new) jump:t #r9:2
0   0   0   1   0   0   1   1   1   0   i   i   s   s   s   s   P   P 0   -     -   -   0   0   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#-1); if (p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   1   1   0   i   i   s   s   s   s   P   P 0   -     -   -   0   1   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#-1); if (p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   1   1   0   i   i   s   s   s   s   P   P 0   -     -   -   1   1   i   i   i   i   i   i   i   -   p1=tstbit(Rs,#0); if (p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   1   1   0   i   i   s   s   s   s   P   P 1   -     -   -   0   0   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#-1); if (p1.new) jump:t #r9:2
0   0   0   1   0   0   1   1   1   0   i   i   s   s   s   s   P   P 1   -     -   -   0   1   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#-1); if (p1.new) jump:t #r9:2
0   0   0   1   0   0   1   1   1   0   i   i   s   s   s   s   P   P 1   -     -   -   1   1   i   i   i   i   i   i   i   -   p1=tstbit(Rs,#0); if (p1.new) jump:t #r9:2
0   0   0   1   0   0   1   1   1   1   i   i   s   s   s   s   P   P 0   -     -   -   0   0   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#-1); if (!p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   1   1   1   i   i   s   s   s   s   P   P 0   -     -   -   0   1   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#-1); if (!p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   1   1   1   i   i   s   s   s   s   P   P 0   -     -   -   1   1   i   i   i   i   i   i   i   -   p1=tstbit(Rs,#0); if (!p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   1   1   1   i   i   s   s   s   s   P   P 1   -     -   -   0   0   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#-1); if (!p1.new) jump:t #r9:2
0   0   0   1   0   0   1   1   1   1   i   i   s   s   s   s   P   P 1   -     -   -   0   1   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#-1); if (!p1.new) jump:t #r9:2
0   0   0   1   0   0   1   1   1   1   i   i   s   s   s   s   P   P 1   -     -   -   1   1   i   i   i   i   i   i   i   -   p1=tstbit(Rs,#0); if (!p1.new) jump:t #r9:2
0   0   0   1   0   0   1   0   0   0   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#U5); if (p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   0   0   0   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#U5); if (p1.new) jump:t #r9:2
0   0   0   1   0   0   1   0   0   1   i   i   s   s   s   s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#U5); if (!p1.new) jump:nt #r9:2
0   0   0   1   0   0   1   0   0   1   i   i   s   s   s   s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,#U5); if (!p1.new) jump:t #r9:2




80-N2040-36 B                                                             233

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7   6   5   4   3   2   1   0
0   0   0    1   0   0   1   0   1   0   i   i   s   s        s   s   P   P 0   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#U5); if (p1.new) jump:nt #r9:2
0   0   0    1   0   0   1   0   1   0   i   i   s   s        s   s   P   P 1   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#U5); if (p1.new) jump:t #r9:2
0   0   0    1   0   0   1   0   1   1   i   i   s   s        s   s   P   P 0   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#U5); if (!p1.new) jump:nt #r9:2
0   0   0    1   0   0   1   0   1   1   i   i   s   s        s   s   P   P 1   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,#U5); if (!p1.new) jump:t #r9:2
0   0   0    1   0   0   1   1   0   0   i   i   s   s        s   s   P   P 0   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,#U5); if (p1.new) jump:nt #r9:2
0   0   0    1   0   0   1   1   0   0   i   i   s   s        s   s   P   P 1   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,#U5); if (p1.new) jump:t #r9:2
0   0   0    1   0   0   1   1   0   1   i   i   s   s        s   s   P   P 0   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,#U5); if (!p1.new) jump:nt #r9:2
0   0   0    1   0   0   1   1   0   1   i   i   s   s        s   s   P   P 1   I     I   I        I   I   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,#U5); if (!p1.new) jump:t #r9:2
    ICLASS                                               s4           Parse                   t4
0   0   0    1   0   1   0   0   0   0   i   i   s   s        s   s   P   P 0   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,Rt); if (p0.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   0   0   i   i   s   s        s   s   P   P 0   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,Rt); if (p1.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   0   0    i   i   s   s        s   s   P   P 1   0     t   t        t   t   i   i   i   i   i   i   i   -  p0=cmp.eq(Rs,Rt); if (p0.new) jump:t #r9:2
0   0   0    1   0   1   0   0   0   0   i   i   s   s        s   s   P   P 1   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,Rt); if (p1.new) jump:t #r9:2
0   0   0    1   0   1   0   0   0   1   i   i   s   s        s   s   P   P 0   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,Rt); if (!p0.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   0   1   i   i   s   s        s   s   P   P 0   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,Rt); if (!p1.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   0   1   i   i   s   s        s   s   P   P 1   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.eq(Rs,Rt); if (!p0.new) jump:t #r9:2
0   0   0    1   0   1   0   0   0   1   i   i   s   s        s   s   P   P 1   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.eq(Rs,Rt); if (!p1.new) jump:t #r9:2
0   0   0    1   0   1   0   0   1   0   i   i   s   s        s   s   P   P 0   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,Rt); if (p0.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   1   0   i   i   s   s        s   s   P   P 0   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,Rt); if (p1.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   1   0   i   i   s   s        s   s   P   P 1   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,Rt); if (p0.new) jump:t #r9:2
0   0   0    1   0   1   0   0   1   0   i   i   s   s        s   s   P   P 1   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,Rt); if (p1.new) jump:t #r9:2
0   0   0    1   0   1   0   0   1   1   i   i   s   s        s   s   P   P 0   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,Rt); if (!p0.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   1   1   i   i   s   s        s   s   P   P 0   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,Rt); if (!p1.new) jump:nt #r9:2
0   0   0    1   0   1   0   0   1   1   i   i   s   s        s   s   P   P 1   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.gt(Rs,Rt); if (!p0.new) jump:t #r9:2
0   0   0    1   0   1   0   0   1   1   i   i   s   s        s   s   P   P 1   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.gt(Rs,Rt); if (!p1.new) jump:t #r9:2
0   0   0    1   0   1   0   1   0   0   i   i   s   s        s   s   P   P 0   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,Rt); if (p0.new) jump:nt #r9:2
0   0   0    1   0   1   0   1   0   0   i   i   s   s        s   s   P   P 0   1     t   t        t   t   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,Rt); if (p1.new) jump:nt #r9:2
0   0   0    1   0   1   0   1   0   0   i   i   s   s        s   s   P   P 1   0     t   t        t   t   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,Rt); if (p0.new) jump:t #r9:2


80-N2040-36 B                                                                   234

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                         8   7   6   5   4   3   2   1   0
0   0   0   1   0   1   0   1   0   0   i   i   s   s   s   s   P   P 1   1     t   t   t   t   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,Rt); if (p1.new) jump:t #r9:2
0   0   0   1   0   1   0   1   0   1   i   i   s   s   s   s   P   P 0   0     t   t   t   t   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,Rt); if (!p0.new) jump:nt #r9:2
0   0   0   1   0   1   0   1   0   1   i   i   s   s   s   s   P   P 0   1     t   t   t   t   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,Rt); if (!p1.new) jump:nt #r9:2
0   0   0   1   0   1   0   1   0   1   i   i   s   s   s   s   P   P 1   0     t   t   t   t   i   i   i   i   i   i   i   -   p0=cmp.gtu(Rs,Rt); if (!p0.new) jump:t #r9:2
0   0   0   1   0   1   0   1   0   1   i   i   s   s   s   s   P   P 1   1     t   t   t   t   i   i   i   i   i   i   i   -   p1=cmp.gtu(Rs,Rt); if (!p1.new) jump:t #r9:2




                          Field name                                                        Description
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        s4                      Field to encode register s
                        t4                      Field to encode register t




80-N2040-36 B                                                             235

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                              Instruction Set



Jump to address
                         Change the program flow to a target address. This instruction changes the Program
                         Counter to a target address which is relative to the PC address. The offset from the current
                         PC address is contained in the instruction encoding.

                         A speculated jump instruction includes a hint ("taken" or "not taken") which specifies the
                         expected value of the conditional expression. If the actual generated value of the predicate
                         differs from this expected value, the jump instruction incurs a performance penalty.

                         This instruction can appear in slots 2 or 3.

                                                 Syntax                                                                     Behavior
                         if ([!]Pu) jump #r15:2                                      Assembler mapped to: "if ([!]Pu)
                                                                                     ""jump"":nt ""#r15:2"
                         if ([!]Pu) jump:<hint>                                      ;
                         #r15:2                                                      if ([!]Pu[0]) {
                                                                                         apply_extension(#r);
                                                                                         #r=#r & ~0x3;
                                                                                         PC=PC+#r;
                                                                                     ;
                                                                                     };
                         jump #r22:2                                                 apply_extension(#r);
                                                                                     #r=#r & ~0x3;
                                                                                     PC=PC+#r;


                         Class: J (slots 0,1,2,3)

                         Notes

                                 ï®       This instruction can be conditionally executed based on the value of a predicate
                                         register. If the instruction is preceded by 'if Pn', then the instruction only executes
                                         if the least-significant bit of the predicate register is 1. Similarly, if the instruction
                                         is preceded by 'if !Pn', then the instruction is executed only if the least-significant
                                         bit of Pn is 0.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8       7   6   5   4   3    2   1   0
    ICLASS                                                           Parse
0   1   0    1   1   0   0   i       i   i   i   i   i   i   i   i   P   P   i   i     i   i   i        i   i   i   i   i    i   i   i   -   jump #r22:2
                                                                                    D
    ICLASS                                                           Parse       PT N              u2

0   1   0    1   1   1   0   0       i   i   0   i   i   i   i   i   P   P   i   0    0    -   u    u       i   i   i   i    i   i   i   -   if (Pu) jump:nt #r15:2
0   1   0    1   1   1   0   0       i   i   0   i   i   i   i   i   P   P   i   1    0    -   u    u       i   i   i   i    i   i   i   -   if (Pu) jump:t #r15:2
0   1   0    1   1   1   0   0       i   i   1   i   i   i   i   i   P   P   i   0    0    -   u    u       i   i   i   i    i   i   i   -   if (!Pu) jump:nt #r15:2
0   1   0    1   1   1   0   0       i   i   1   i   i   i   i   i   P   P   i   1    0    -   u    u       i   i   i   i    i   i   i   -   if (!Pu) jump:t #r15:2




80-N2040-36 B                                                                    236

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                DN             Dot-new
                PT             Predict-taken
                Parse          Packet/Loop parse bits
                u2             Field to encode register u




80-N2040-36 B                                       237

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Jump to address conditioned on new predicate
                         Perform speculated jump.

                         Jump if the LSB of the newly-generated predicate is true. The predicate must be generated
                         in the same packet as the speculated jump instruction.

                         A speculated jump instruction includes a hint ("taken" or "not taken") which specifies the
                         expected value of the conditional expression. If the actual generated value of the predicate
                         differs from this expected value, the jump instruction incurs a performance penalty.

                         This instruction can appear in slots 2 or 3.

                                                             Syntax                                                               Behavior
                         if ([!]Pu.new) jump:<hint> #r15:2                                                   };
                                                                                                             {
                                                                                                             if([!]Pu.new[0]){
                                                                                                                 apply_extension(#r);
                                                                                                                 #r=#r & ~0x3;
                                                                                                                 PC=PC+#r;
                                                                                                             ;
                                                                                                             };


                         Class: J (slots 0,1,2,3)

                         Notes

                                 ï®       This instruction can be conditionally executed based on the value of a predicate
                                         register. If the instruction is preceded by 'if Pn', then the instruction only executes
                                         if the least-significant bit of the predicate register is 1. Similarly, if the instruction
                                         is preceded by 'if !Pn', then the instruction is executed only if the least-significant
                                         bit of Pn is 0.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6    5   4   3   2   1    0
                                                                                    D
    ICLASS                                                           Parse       PT N        u2

0   1   0    1   1   1   0   0       i   i   0   i   i   i   i   i   P   P   i   0   1   -   u   u   i   i    i   i   i   i   i    -   if (Pu.new) jump:nt #r15:2
0   1   0    1   1   1   0   0       i   i   0   i   i   i   i   i   P   P   i   1   1   -   u   u   i   i    i   i   i   i   i    -   if (Pu.new) jump:t #r15:2
0   1   0    1   1   1   0   0       i   i   1   i   i   i   i   i   P   P   i   0   1   -   u   u   i   i    i   i   i   i   i    -   if (!Pu.new) jump:nt #r15:2
0   1   0    1   1   1   0   0       i   i   1   i   i   i   i   i   P   P   i   1   1   -   u   u   i   i    i   i   i   i   i    -   if (!Pu.new) jump:t #r15:2




                           Field name                                                             Description
                         ICLASS                      Instruction Class
                         DN                          Dot-new
                         PT                          Predict-taken
                         Parse                       Packet/Loop parse bits
                         u2                          Field to encode register u




80-N2040-36 B                                                                    238

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Jump to address condition on register value
                Perform register-conditional jump.

                Jump if the specified register expression is true.

                A register-conditional jump includes a hint ("taken" or "not taken") which specifies the
                expected value of the register expression. If the actual generated value of the expression
                differs from this expected value, the jump instruction incurs a performance penalty.

                This instruction can appear only in slot 3.

                               Syntax                                        Behavior
                if (Rs!=#0) jump:nt #r13:2            if (Rs != 0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs!=#0) jump:t #r13:2             if (Rs != 0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs<=#0) jump:nt #r13:2            if (Rs<=0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs<=#0) jump:t #r13:2             if (Rs<=0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs==#0) jump:nt #r13:2            if (Rs == 0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs==#0) jump:t #r13:2             if (Rs == 0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs>=#0) jump:nt #r13:2            if (Rs>=0) {
                                                          PC=PC+#r;
                                                      };
                if (Rs>=#0) jump:t #r13:2             if (Rs>=0) {
                                                          PC=PC+#r;
                                                      };


                Class: J (slot 3)

                Notes

                     ï®   This instruction will be deprecated in a future version.




80-N2040-36 B                                        239

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   0    0   1   0   0   i   s   s   s    s   s   P   P   i   0     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs!=#0) jump:nt #r13:2
0   1   1    0   0   0    0   1   0   0   i   s   s   s    s   s   P   P   i   1     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs!=#0) jump:t #r13:2
0   1   1    0   0   0    0   1   0   1   i   s   s   s    s   s   P   P   i   0     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs>=#0) jump:nt #r13:2
0   1   1    0   0   0    0   1   0   1   i   s   s   s    s   s   P   P   i   1     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs>=#0) jump:t #r13:2
0   1   1    0   0   0    0   1   1   0   i   s   s   s    s   s   P   P   i   0     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs==#0) jump:nt #r13:2
0   1   1    0   0   0    0   1   1   0   i   s   s   s    s   s   P   P   i   1     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs==#0) jump:t #r13:2
0   1   1    0   0   0    0   1   1   1   i   s   s   s    s   s   P   P   i   0     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs<=#0) jump:nt #r13:2
0   1   1    0   0   0    0   1   1   1   i   s   s   s    s   s   P   P   i   1     i   i   i   i   i   i   i   i   i   i   i   -   if (Rs<=#0) jump:t #r13:2




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  240

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                              Instruction Set



Transfer and jump
                         Move an unsigned immediate or register value into a destination register and
                         unconditionally jump. In assembly syntax, this instruction appears as two instructions in
                         the packet, a transfer and a separate jump. The assembler may convert adjacent transfer
                         and jump instructions into compound transfer-jump form.

                                             Syntax                                                                          Behavior
                         Rd=#U6 ; jump #r9:2                                          apply_extension(#r);
                                                                                      #r=#r & ~0x3;
                                                                                      Rd=#U;
                                                                                      PC=PC+#r;
                         Rd=Rs ; jump #r9:2                                           apply_extension(#r);
                                                                                      #r=#r & ~0x3;
                                                                                      Rd=Rs;
                                                                                      PC=PC+#r;


                         Class: J (slots 2,3)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7   6   5   4   3    2   1   0
    ICLASS                                               d4           Parse
0   0   0    1   0   1   1   0   -   -   i   i   d   d        d   d   P   P   I   I     I   I        I   I   i   i   i   i    i   i   i   -   Rd=#U6 ; jump #r9:2
    ICLASS                                               s4           Parse                     d4
0   0   0    1   0   1   1   1   -   -   i   i   s   s        s   s   P   P   -   -    d    d    d       d   i   i   i   i    i   i   i   -   Rd=Rs ; jump #r9:2




                           Field name                                                                    Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         d4                      Field to encode register d
                         s4                      Field to encode register s




80-N2040-36 B                                                                     241

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



       11.5 LD
                The LD instruction class includes load instructions, which are used to load values into
                registers.

                LD instructions are executable on slot 0 and slot 1.

Load doubleword
                Load a 64-bit doubleword from memory and place in a destination register pair.

                               Syntax                                      Behavior
                Rdd=memd(Re=#U6)                     apply_extension(#U);
                                                     EA=#U;
                                                     Rdd = *EA;
                                                     Re=#U;
                Rdd=memd(Rs+#s11:3)                  apply_extension(#s);
                                                     EA=Rs+#s;
                                                     Rdd = *EA;
                Rdd=memd(Rs+Rt<<#u2)                 EA=Rs+(Rt<<#u);
                                                     Rdd = *EA;
                Rdd=memd(Rt<<#u2+#U6)                apply_extension(#U);
                                                     EA=#U+(Rt<<#u);
                                                     Rdd = *EA;
                Rdd=memd(Rx++#s4:3)                  EA=Rx;
                                                     Rx=Rx+#s;
                                                     Rdd = *EA;
                Rdd=memd(Rx++#s4:3:circ(Mu)) EA=Rx;
                                             Rx=Rx=circ_add(Rx,#s,MuV);
                                             Rdd = *EA;
                Rdd=memd(Rx++I:circ(Mu))             EA=Rx;
                                                     Rx=Rx=circ_add(Rx,I<<3,MuV);
                                                     Rdd = *EA;
                Rdd=memd(Rx++Mu)                     EA=Rx;
                                                     Rx=Rx+MuV;
                                                     Rdd = *EA;
                Rdd=memd(Rx++Mu:brev)                EA=Rx.h[1] | brev(Rx.h[0]);
                                                     Rx=Rx+MuV;
                                                     Rdd = *EA;
                Rdd=memd(gp+#u16:3)                  apply_extension(#u);
                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                     Rdd = *EA;




80-N2040-36 B                                       242

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                              s5           Parse                 t5                               d5
0   0   1    1   1   0   1   0    1     1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   -   -   d   d   d    d   d Rdd=memd(Rs+Rt<<#u2)
                                            U
    ICLASS                        Type                               Parse                                                  d5
                                            N
0   1   0    0   1   i   i   1    1     1   0   i   i   i    i   i   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rdd=memd(gp+#u16:3)
                                            U
    ICLASS       Amode           Type       N           s5           Parse                                                  d5

1   0   0    1   0   i   i   1    1     1   0   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rdd=memd(Rs+#s11:3)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                               d5
                                            N
1   0   0    1   1   0   0   1    1     1   0   x   x   x    x   x   P   P   u 0       -   -    0   i   i   i   i   d   d   d    d   d Rdd=memd(Rx++#s4:3:circ(Mu))

1   0   0    1   1   0   0   1    1     1   0   x   x   x    x   x   P   P   u 0       -   -    1   -   0   -   -   d   d   d    d   d Rdd=memd(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                  d5
                                            N
1   0   0    1   1   0   1   1    1     1   0   e   e   e    e   e   P   P 0     1     I   I    I   I   -   I   I   d   d   d    d   d Rdd=memd(Re=#U6)

    ICLASS       Amode           Type       U           x5           Parse                                                  d5
                                            N
1   0   0    1   1   0   1   1    1     1   0   x   x   x    x   x   P   P 0     0     -   -    -   i   i   i   i   d   d   d    d   d Rdd=memd(Rx++#s4:3)

    ICLASS       Amode           Type       U           t5           Parse                                                  d5
                                            N
1   0   0    1   1   1   0   1    1     1   0   t   t   t    t   t   P   P   i   1     I   I    I   I   i   I   I   d   d   d    d   d Rdd=memd(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type       N           x5           Parse u1                                               d5

1   0   0    1   1   1   0   1    1     1   0   x   x   x    x   x   P   P   u 0       -   -    -   -   0   -   -   d   d   d    d   d Rdd=memd(Rx++Mu)
1   0   0    1   1   1   1   1    1     1   0   x   x   x    x   x   P   P   u 0       -   -    -   -   0   -   -   d   d   d    d   d Rdd=memd(Rx++Mu:brev)




                           Field name                                                               Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    243

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Load doubleword conditionally
                         Load a 64-bit doubleword from memory and place in a destination register pair.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                                                          Syntax                                                         Behavior
                                             if ([!]Pt[.new]) Rdd=memd(#u6)                                             if ([!]Pt[.new][0]) {
                                                                                                                            apply_extension(#u);
                                                                                                                            EA=#u;
                                                                                                                            Rdd = *EA;
                                                                                                                        } else {
                                                                                                                            NOP;
                                                                                                                        };
                                             if ([!]Pt[.new]) Rdd=memd(Rs+#u6:3)                                        if ([!]Pt[.new][0]) {
                                                                                                                            apply_extension(#u);
                                                                                                                            EA=Rs+#u;
                                                                                                                            Rdd = *EA;
                                                                                                                        } else {
                                                                                                                            NOP;
                                                                                                                        };
                                             if ([!]Pt[.new]) Rdd=memd(Rx++#s4:3)                                       if([!]Pt[.new][0]){
                                                                                                                            EA=Rx;
                                                                                                                            Rx=Rx+#s;
                                                                                                                            Rdd = *EA;
                                                                                                                        } else {
                                                                                                                            NOP;
                                                                                                                        };
                                             if ([!]Pv[.new]) Rdd=memd(Rs+Rt<<#u2) if ([!]Pv[.new][0]) {
                                                                                       EA=Rs+(Rt<<#u);
                                                                                       Rdd = *EA;
                                                                                   } else {
                                                                                       NOP;
                                                                                   };


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                           s5           Parse                    t5                               d5
0   0   1    1   0   0   0   0   1   1   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (Pv) Rdd=memd(Rs+Rt<<#u2)
0   0   1    1   0   0   0   1   1   1   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv) Rdd=memd(Rs+Rt<<#u2)
0   0   1    1   0   0   1   0   1   1   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (Pv.new) Rdd=memd(Rs+Rt<<#u2)
0   0   1    1   0   0   1   1   1   1   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv.new) Rdd=memd(Rs+Rt<<#u2)
                        Pr
                     Se ed
                                         U
    ICLASS           ns Ne       Type
                                         N           s5           Parse           t2                                        d5
                     e w

0   1   0    0   0   0   0   1   1   1   0   s   s   s    s   s   P   P 0     t        t   i    i   i   i   i   i   d   d   d    d   d   if (Pt) Rdd=memd(Rs+#u6:3)




80-N2040-36 B                                                                 244

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7   6   5   4   3   2    1   0
0   1   0    0   0   0   1   1    1     1   0   s   s   s    s   s   P   P 0   t     t   i        i   i   i   i   i   d   d   d    d   d   if (Pt.new) Rdd=memd(Rs+#u6:3)
0   1   0    0   0   1   0   1    1     1   0   s   s   s    s   s   P   P 0   t     t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt) Rdd=memd(Rs+#u6:3)
0   1   0    0   0   1   1   1    1     1   0   s   s   s    s   s   P   P 0   t     t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rdd=memd(Rs+#u6:3)
                                            U
    ICLASS       Amode           Type       N           x5           Parse                   t2                               d5

1   0   0    1   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1   0   0     t        t   i   i   i   i   d   d   d    d   d   if (Pt) Rdd=memd(Rx++#s4:3)
1   0   0    1   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1   0   1     t        t   i   i   i   i   d   d   d    d   d   if (!Pt) Rdd=memd(Rx++#s4:3)
1   0   0    1   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1   1   0     t        t   i   i   i   i   d   d   d    d   d   if (Pt.new) Rdd=memd(Rx++#s4:3)
1   0   0    1   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1   1   1     t        t   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rdd=memd(Rx++#s4:3)
                                            U
    ICLASS       Amode           Type                                Parse                   t2                               d5
                                            N
1   0   0    1   1   1   1   1    1     1   0   i   i   i    i   i   P   P 1   0   0     t        t   i   1   -   -   d   d   d    d   d if (Pt) Rdd=memd(#u6)
1   0   0    1   1   1   1   1    1     1   0   i   i   i    i   i   P   P 1   0   1     t        t   i   1   -   -   d   d   d    d   d if (!Pt) Rdd=memd(#u6)
1   0   0    1   1   1   1   1    1     1   0   i   i   i    i   i   P   P 1   1   0     t        t   i   1   -   -   d   d   d    d   d if (Pt.new) Rdd=memd(#u6)
1   0   0    1   1   1   1   1    1     1   0   i   i   i    i   i   P   P 1   1   1     t        t   i   1   -   -   d   d   d    d   d if (!Pt.new) Rdd=memd(#u6)




                           Field name                                                                 Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t2                         Field to encode register t
                         t5                         Field to encode register t
                         v2                         Field to encode register v
                         x5                         Field to encode register x




80-N2040-36 B                                                                  245

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Load byte
                         Load a signed byte from memory. The byte at the effective address in memory is placed in
                         the least-significant 8 bits of the destination register. The destination register is then sign-
                         extended from 8 bits to 32.

                                                Syntax                                                                  Behavior
                         Rd=memb(Re=#U6)                                             apply_extension(#U);
                                                                                     EA=#U;
                                                                                     Rd = *EA;
                                                                                     Re=#U;
                         Rd=memb(Rs+#s11:0)                                          apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     Rd = *EA;
                         Rd=memb(Rs+Rt<<#u2)                                         EA=Rs+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memb(Rt<<#u2+#U6)                                        apply_extension(#U);
                                                                                     EA=#U+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memb(Rx++#s4:0)                                          EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     Rd = *EA;
                         Rd=memb(Rx++#s4:0:circ(Mu))                                 EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,#s,MuV);
                                                                                     Rd = *EA;
                         Rd=memb(Rx++I:circ(Mu))                                     EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                                                     Rd = *EA;
                         Rd=memb(Rx++Mu)                                             EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memb(Rx++Mu:brev)                                        EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memb(gp+#u16:0)                                          apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     Rd = *EA;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                              s5           Parse                 t5                               d5
0   0   1    1   1   0   1   0    0     0   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   -   -   d   d   d    d   d Rd=memb(Rs+Rt<<#u2)
                                            U
    ICLASS                        Type                               Parse                                                  d5
                                            N
0   1   0    0   1   i   i   1    0     0   0   i   i   i    i   i   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=memb(gp+#u16:0)
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                  d5
                                            N




80-N2040-36 B                                                                    246

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   0   i   i   1    0     0   0   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=memb(Rs+#s11:0)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   0   0   1    0     0   0   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d Rd=memb(Rx++#s4:0:circ(Mu))
1   0   0    1   1   0   0   1    0     0   0   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d Rd=memb(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     0   0   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=memb(Re=#U6)

    ICLASS       Amode           Type       U           x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     0   0   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=memb(Rx++#s4:0)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   1    0     0   0   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=memb(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   1    0     0   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memb(Rx++Mu)
1   0   0    1   1   1   1   1    0     0   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memb(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    247

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Load byte conditionally
                         Load a signed byte from memory. The byte at the effective address in memory is placed in
                         the least-significant 8 bits of the destination register. The destination register is then sign-
                         extended from 8 bits to 32.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                                              Syntax                                                               Behavior
                         if ([!]Pt[.new]) Rd=memb(#u6)                                                        if ([!]Pt[.new][0]) {
                                                                                                                  apply_extension(#u);
                                                                                                                  EA=#u;
                                                                                                                  Rd = *EA;
                                                                                                              } else {
                                                                                                                  NOP;
                                                                                                              };
                         if ([!]Pt[.new]) Rd=memb(Rs+#u6:0)                                                   if ([!]Pt[.new][0]) {
                                                                                                                  apply_extension(#u);
                                                                                                                  EA=Rs+#u;
                                                                                                                  Rd = *EA;
                                                                                                              } else {
                                                                                                                  NOP;
                                                                                                              };
                         if ([!]Pt[.new]) Rd=memb(Rx++#s4:0)                                                  if([!]Pt[.new][0]){
                                                                                                                  EA=Rx;
                                                                                                                  Rx=Rx+#s;
                                                                                                                  Rd = *EA;
                                                                                                              } else {
                                                                                                                  NOP;
                                                                                                              };
                         if ([!]Pv[.new]) Rd=memb(Rs+Rt<<#u2)                                                 if ([!]Pv[.new][0]) {
                                                                                                                  EA=Rs+(Rt<<#u);
                                                                                                                  Rd = *EA;
                                                                                                              } else {
                                                                                                                  NOP;
                                                                                                              };


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS                                           s5            Parse                 t5                               d5
0   0   1    1   0   0   0   0   0   0   0   s   s   s    s    s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv) Rd=memb(Rs+Rt<<#u2)
0   0   1    1   0   0   0   1   0   0   0   s   s   s    s    s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv) Rd=memb(Rs+Rt<<#u2)
0   0   1    1   0   0   1   0   0   0   0   s   s   s    s    s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv.new) Rd=memb(Rs+Rt<<#u2)
0   0   1    1   0   0   1   1   0   0   0   s   s   s    s    s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv.new) Rd=memb(Rs+Rt<<#u2)




80-N2040-36 B                                                                  248

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7   6   5   4   3   2    1   0
                        Pr
                     Se
                        ed                  U
    ICLASS           ns           Type                  s5           Parse         t2                                            d5
                        Ne                  N
                      e
                        w
0   1   0    0   0   0   0   1    0     0   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memb(Rs+#u6:0)
0   1   0    0   0   0   1   1    0     0   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memb(Rs+#u6:0)
0   1   0    0   0   1   0   1    0     0   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memb(Rs+#u6:0)
0   1   0    0   0   1   1   1    0     0   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memb(Rs+#u6:0)
                                            U
    ICLASS       Amode           Type                   x5           Parse                      t2                               d5
                                            N
1   0   0    1   1   0   1   1    0     0   0   x   x   x    x   x   P   P 1   0        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memb(Rx++#s4:0)
1   0   0    1   1   0   1   1    0     0   0   x   x   x    x   x   P   P 1   0        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memb(Rx++#s4:0)
1   0   0    1   1   0   1   1    0     0   0   x   x   x    x   x   P   P 1   1        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memb(Rx++#s4:0)
1   0   0    1   1   0   1   1    0     0   0   x   x   x    x   x   P   P 1   1        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memb(Rx++#s4:0)

    ICLASS       Amode           Type       U                        Parse                      t2                               d5
                                            N
1   0   0    1   1   1   1   1    0     0   0   i   i   i    i   i   P   P 1   0        0   t        t   i   1   -   -   d   d   d    d   d if (Pt) Rd=memb(#u6)
1   0   0    1   1   1   1   1    0     0   0   i   i   i    i   i   P   P 1   0        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt) Rd=memb(#u6)
1   0   0    1   1   1   1   1    0     0   0   i   i   i    i   i   P   P 1   1        0   t        t   i   1   -   -   d   d   d    d   d if (Pt.new) Rd=memb(#u6)
1   0   0    1   1   1   1   1    0     0   0   i   i   i    i   i   P   P 1   1        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt.new) Rd=memb(#u6)




                           Field name                                                                    Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t2                         Field to encode register t
                         t5                         Field to encode register t
                         v2                         Field to encode register v
                         x5                         Field to encode register x




80-N2040-36 B                                                                  249

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Load byte into shifted vector
                Shift a 64-bit vector right by one byte. Insert a byte from memory into the vacated upper
                byte of the vector.


                 Mem
                                                                Ryy




                                                      Ryy


                           Syntax                                          Behavior
           Ryy=memb_fifo(Re=#U6)                    apply_extension(#U);
                                                    EA=#U;
                                                    {
                                                        tmpV = *EA;
                                                        Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                    };
                                                    ;
                                                    Re=#U;
           Ryy=memb_fifo(Rs)                        Assembler mapped to:
                                                    "Ryy=memb_fifo""(Rs+#0)"
           Ryy=memb_fifo(Rs+#s11:0)                 apply_extension(#s);
                                                    EA=Rs+#s;
                                                    {
                                                        tmpV = *EA;
                                                        Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                    };
                                                    ;
           Ryy=memb_fifo(Rt<<#u2+#U6)               apply_extension(#U);
                                                    EA=#U+(Rt<<#u);
                                                    {
                                                        tmpV = *EA;
                                                        Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                    };
                                                    ;




80-N2040-36 B                                      250

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                                            Syntax                                                                     Behavior
                 Ryy=memb_fifo(Rx++#s4:0)                                            EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                                                     };
                                                                                     ;
                 Ryy=memb_fifo(Rx++#s4:0:circ(Mu)) EA=Rx;
                                                   Rx=Rx=circ_add(Rx,#s,MuV);
                                                   {
                                                       tmpV = *EA;
                                                       Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                   };
                                                   ;
                 Ryy=memb_fifo(Rx++I:circ(Mu))                                       EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                                                     };
                                                                                     ;
                 Ryy=memb_fifo(Rx++Mu)                                               EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                                                     };
                                                                                     ;
                 Ryy=memb_fifo(Rx++Mu:brev)                                          EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                                                     };
                                                                                     ;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                 y5
                                            N
1   0   0    1   0   i   i   0    1     0   0   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   y   y   y    y   y   Ryy=memb_fifo(Rs+#s11:0)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              y5
                                            N

1   0   0    1   1   0   0   0    1     0   0   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   y   y   y    y   y Ryy=memb_fifo(Rx++#s4:0:circ(Mu))
1   0   0    1   1   0   0   0    1     0   0   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   y   y   y    y   y   Ryy=memb_fifo(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type       N           e5           Parse                                                 y5

1   0   0    1   1   0   1   0    1     0   0   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   y   y   y    y   y Ryy=memb_fifo(Re=#U6)
                                            U
    ICLASS       Amode           Type       N
                                                        x5           Parse                                                 y5




80-N2040-36 B                                                                    251

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   1   0   1   0    1     0   0   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   y   y   y    y   y   Ryy=memb_fifo(Rx++#s4:0)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 y5
                                            N
1   0   0    1   1   1   0   0    1     0   0   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   y   y   y    y   y   Ryy=memb_fifo(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type       N           x5           Parse u1                                              y5

1   0   0    1   1   1   0   0    1     0   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   y   y   y    y   y   Ryy=memb_fifo(Rx++Mu)
1   0   0    1   1   1   1   0    1     0   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   y   y   y    y   y   Ryy=memb_fifo(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x
                         y5                         Field to encode register y




80-N2040-36 B                                                                    252

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



Load half into shifted vector
                Shift a 64-bit vector right by one halfword. Insert a halfword from memory into the
                vacated upper halfword of the vector.


                  Mem
                                                                 Ryy




                                                    Ryy


                           Syntax                                         Behavior
           Ryy=memh_fifo(Re=#U6)                    apply_extension(#U);
                                                    EA=#U;
                                                    {
                                                        tmpV = *EA;
                                                        Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                    };
                                                    ;
                                                    Re=#U;
           Ryy=memh_fifo(Rs)                        Assembler mapped to:
                                                    "Ryy=memh_fifo""(Rs+#0)"
           Ryy=memh_fifo(Rs+#s11:1)                 apply_extension(#s);
                                                    EA=Rs+#s;
                                                    {
                                                        tmpV = *EA;
                                                        Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                    };
                                                    ;
           Ryy=memh_fifo(Rt<<#u2+#U6)               apply_extension(#U);
                                                    EA=#U+(Rt<<#u);
                                                    {
                                                        tmpV = *EA;
                                                        Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                    };
                                                    ;




80-N2040-36 B                                      253

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                                            Syntax                                                                     Behavior
                 Ryy=memh_fifo(Rx++#s4:1)                                            EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                                                     };
                                                                                     ;
                 Ryy=memh_fifo(Rx++#s4:1:circ(Mu)) EA=Rx;
                                                   Rx=Rx=circ_add(Rx,#s,MuV);
                                                   {
                                                       tmpV = *EA;
                                                       Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                   };
                                                   ;
                 Ryy=memh_fifo(Rx++I:circ(Mu))                                       EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                                                     };
                                                                                     ;
                 Ryy=memh_fifo(Rx++Mu)                                               EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                                                     };
                                                                                     ;
                 Ryy=memh_fifo(Rx++Mu:brev)                                          EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     {
                                                                                         tmpV = *EA;
                                                                                         Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                                                     };
                                                                                     ;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                 y5
                                            N
1   0   0    1   0   i   i   0    0     1   0   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   y   y   y    y   y   Ryy=memh_fifo(Rs+#s11:1)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              y5
                                            N

1   0   0    1   1   0   0   0    0     1   0   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   y   y   y    y   y   Ryy=memh_fifo(Rx++#s4:1:circ(Mu))
1   0   0    1   1   0   0   0    0     1   0   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   y   y   y    y   y   Ryy=memh_fifo(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type       N           e5           Parse                                                 y5

1   0   0    1   1   0   1   0    0     1   0   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   y   y   y    y   y Ryy=memh_fifo(Re=#U6)
                                            U
    ICLASS       Amode           Type       N
                                                        x5           Parse                                                 y5




80-N2040-36 B                                                                    254

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   1   0   1   0    0     1   0   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   y   y   y    y   y   Ryy=memh_fifo(Rx++#s4:1)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 y5
                                            N
1   0   0    1   1   1   0   0    0     1   0   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   y   y   y    y   y   Ryy=memh_fifo(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type       N           x5           Parse u1                                              y5

1   0   0    1   1   1   0   0    0     1   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   y   y   y    y   y  Ryy=memh_fifo(Rx++Mu)
1   0   0    1   1   1   1   0    0     1   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   y   y   y    y   y  Ryy=memh_fifo(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x
                         y5                         Field to encode register y




80-N2040-36 B                                                                    255

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Load halfword
                         Load a signed halfword from memory. The 16-bit halfword at the effective address in
                         memory is placed in the least-significant 16 bits of the destination register. The destination
                         register is then sign-extended from 16 bits to 32.

                                                Syntax                                                                  Behavior
                         Rd=memh(Re=#U6)                                             apply_extension(#U);
                                                                                     EA=#U;
                                                                                     Rd = *EA;
                                                                                     Re=#U;
                         Rd=memh(Rs+#s11:1)                                          apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     Rd = *EA;
                         Rd=memh(Rs+Rt<<#u2)                                         EA=Rs+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memh(Rt<<#u2+#U6)                                        apply_extension(#U);
                                                                                     EA=#U+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memh(Rx++#s4:1)                                          EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     Rd = *EA;
                         Rd=memh(Rx++#s4:1:circ(Mu))                                 EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,#s,MuV);
                                                                                     Rd = *EA;
                         Rd=memh(Rx++I:circ(Mu))                                     EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                                                     Rd = *EA;
                         Rd=memh(Rx++Mu)                                             EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memh(Rx++Mu:brev)                                        EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memh(gp+#u16:1)                                          apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     Rd = *EA;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                              s5           Parse                 t5                               d5
0   0   1    1   1   0   1   0    0     1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   -   -   d   d   d    d   d Rd=memh(Rs+Rt<<#u2)
                                            U
    ICLASS                        Type                               Parse                                                  d5
                                            N
0   1   0    0   1   i   i   1    0     1   0   i   i   i    i   i   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=memh(gp+#u16:1)
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                  d5
                                            N




80-N2040-36 B                                                                    256

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   0   i   i   1    0     1   0   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=memh(Rs+#s11:1)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   0   0   1    0     1   0   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d  Rd=memh(Rx++#s4:1:circ(Mu))
1   0   0    1   1   0   0   1    0     1   0   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d Rd=memh(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     1   0   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=memh(Re=#U6)

    ICLASS       Amode           Type       U           x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     1   0   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=memh(Rx++#s4:1)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   1    0     1   0   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=memh(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   1    0     1   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memh(Rx++Mu)
1   0   0    1   1   1   1   1    0     1   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memh(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    257

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Load halfword conditionally
                         Load a signed halfword from memory. The 16-bit halfword at the effective address in
                         memory is placed in the least-significant 16 bits of the destination register. The destination
                         register is then sign-extended from 16 bits to 32.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                             Syntax                                                                  Behavior
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memh(#u6)                                                 apply_extension(#u);
                                                                                      EA=#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memh(Rs+#u6:1)                                            apply_extension(#u);
                                                                                      EA=Rs+#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if([!]Pt[.new][0]){
                         Rd=memh(Rx++#s4:1)                                           EA=Rx;
                                                                                      Rx=Rx+#s;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]) {
                         Rd=memh(Rs+Rt<<#u2)                                          EA=Rs+(Rt<<#u);
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS                                           s5           Parse                 t5                               d5

0   0   1    1   0   0   0   0   0   1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv) Rd=memh(Rs+Rt<<#u2)
0   0   1    1   0   0   0   1   0   1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv) Rd=memh(Rs+Rt<<#u2)
0   0   1    1   0   0   1   0   0   1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv.new) Rd=memh(Rs+Rt<<#u2)
0   0   1    1   0   0   1   1   0   1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv.new) Rd=memh(Rs+Rt<<#u2)




80-N2040-36 B                                                                 258

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7   6   5   4   3   2    1   0
                        Pr
                     Se
                        ed                  U
    ICLASS           ns           Type                  s5           Parse         t2                                            d5
                        Ne                  N
                      e
                        w
0   1   0    0   0   0   0   1    0     1   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memh(Rs+#u6:1)
0   1   0    0   0   0   1   1    0     1   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memh(Rs+#u6:1)
0   1   0    0   0   1   0   1    0     1   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memh(Rs+#u6:1)
0   1   0    0   0   1   1   1    0     1   0   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memh(Rs+#u6:1)
                                            U
    ICLASS       Amode           Type                   x5           Parse                      t2                               d5
                                            N
1   0   0    1   1   0   1   1    0     1   0   x   x   x    x   x   P   P 1   0        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt) Pd=memh(Rx++#s4:1)
1   0   0    1   1   0   1   1    0     1   0   x   x   x    x   x   P   P 1   0        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memh(Rx++#s4:1)
1   0   0    1   1   0   1   1    0     1   0   x   x   x    x   x   P   P 1   1        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memh(Rx++#s4:1)
1   0   0    1   1   0   1   1    0     1   0   x   x   x    x   x   P   P 1   1        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memh(Rx++#s4:1)

    ICLASS       Amode           Type       U                        Parse                      t2                               d5
                                            N
1   0   0    1   1   1   1   1    0     1   0   i   i   i    i   i   P   P 1   0        0   t        t   i   1   -   -   d   d   d    d   d if (Pt) Rd=memh(#u6)
1   0   0    1   1   1   1   1    0     1   0   i   i   i    i   i   P   P 1   0        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt) Rd=memh(#u6)
1   0   0    1   1   1   1   1    0     1   0   i   i   i    i   i   P   P 1   1        0   t        t   i   1   -   -   d   d   d    d   d if (Pt.new) Rd=memh(#u6)
1   0   0    1   1   1   1   1    0     1   0   i   i   i    i   i   P   P 1   1        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt.new) Rd=memh(#u6)




                           Field name                                                                    Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t2                         Field to encode register t
                         t5                         Field to encode register t
                         v2                         Field to encode register v
                         x5                         Field to encode register x




80-N2040-36 B                                                                  259

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Load unsigned byte
                         Load an unsigned byte from memory. The byte at the effective address in memory is
                         placed in the least-significant 8 bits of the destination register. The destination register is
                         then zero-extended from 8 bits to 32.

                                                Syntax                                                                  Behavior
                         Rd=memub(Re=#U6)                                            apply_extension(#U);
                                                                                     EA=#U;
                                                                                     Rd = *EA;
                                                                                     Re=#U;
                         Rd=memub(Rs+#s11:0)                                         apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     Rd = *EA;
                         Rd=memub(Rs+Rt<<#u2)                                        EA=Rs+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memub(Rt<<#u2+#U6)                                       apply_extension(#U);
                                                                                     EA=#U+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memub(Rx++#s4:0)                                         EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     Rd = *EA;
                         Rd=memub(Rx++#s4:0:circ(Mu)) EA=Rx;
                                                      Rx=Rx=circ_add(Rx,#s,MuV);
                                                      Rd = *EA;
                         Rd=memub(Rx++I:circ(Mu))                                    EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                                                     Rd = *EA;
                         Rd=memub(Rx++Mu)                                            EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memub(Rx++Mu:brev)                                       EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memub(gp+#u16:0)                                         apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     Rd = *EA;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                              s5           Parse                 t5                               d5
0   0   1    1   1   0   1   0    0     0   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   -   -   d   d   d    d   d Rd=memub(Rs+Rt<<#u2)
                                            U
    ICLASS                        Type                               Parse                                                  d5
                                            N
0   1   0    0   1   i   i   1    0     0   1   i   i   i    i   i   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=memub(gp+#u16:0)
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                  d5
                                            N




80-N2040-36 B                                                                    260

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   0   i   i   1    0     0   1   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=memub(Rs+#s11:0)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   0   0   1    0     0   1   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d   Rd=memub(Rx++#s4:0:circ(Mu))
1   0   0    1   1   0   0   1    0     0   1   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d  Rd=memub(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     0   1   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=memub(Re=#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     0   1   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=memub(Rx++#s4:0)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   1    0     0   1   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=memub(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   1    0     0   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memub(Rx++Mu)
1   0   0    1   1   1   1   1    0     0   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memub(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    261

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Load unsigned byte conditionally
                         Load an unsigned byte from memory. The byte at the effective address in memory is
                         placed in the least-significant 8 bits of the destination register. The destination register is
                         then zero-extended from 8 bits to 32.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                             Syntax                                                                  Behavior
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memub(#u6)                                                apply_extension(#u);
                                                                                      EA=#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memub(Rs+#u6:0)                                           apply_extension(#u);
                                                                                      EA=Rs+#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if([!]Pt[.new][0]){
                         Rd=memub(Rx++#s4:0)                                          EA=Rx;
                                                                                      Rx=Rx+#s;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]) {
                         Rd=memub(Rs+Rt<<#u2)                                         EA=Rs+(Rt<<#u);
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS                                           s5           Parse                 t5                               d5

0   0   1    1   0   0   0   0   0   0   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv) Rd=memub(Rs+Rt<<#u2)
0   0   1    1   0   0   0   1   0   0   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv) Rd=memub(Rs+Rt<<#u2)
0   0   1    1   0   0   1   0   0   0   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv.new) Rd=memub(Rs+Rt<<#u2)
0   0   1    1   0   0   1   1   0   0   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv.new) Rd=memub(Rs+Rt<<#u2)



80-N2040-36 B                                                                 262

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7   6   5   4   3   2    1   0
                        Pr
                     Se
                        ed                  U
    ICLASS           ns           Type                  s5           Parse         t2                                            d5
                        Ne                  N
                      e
                        w
0   1   0    0   0   0   0   1    0     0   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memub(Rs+#u6:0)
0   1   0    0   0   0   1   1    0     0   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memub(Rs+#u6:0)
0   1   0    0   0   1   0   1    0     0   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memub(Rs+#u6:0)
0   1   0    0   0   1   1   1    0     0   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memub(Rs+#u6:0)
                                            U
    ICLASS       Amode           Type                   x5           Parse                      t2                               d5
                                            N
1   0   0    1   1   0   1   1    0     0   1   x   x   x    x   x   P   P 1   0        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memub(Rx++#s4:0)
1   0   0    1   1   0   1   1    0     0   1   x   x   x    x   x   P   P 1   0        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memub(Rx++#s4:0)
1   0   0    1   1   0   1   1    0     0   1   x   x   x    x   x   P   P 1   1        0   t        t   i   i   i   i   d   d   d    d   d    if (Pt.new) Rd=memub(Rx++#s4:0)
1   0   0    1   1   0   1   1    0     0   1   x   x   x    x   x   P   P 1   1        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memub(Rx++#s4:0)

    ICLASS       Amode           Type       U                        Parse                      t2                               d5
                                            N
1   0   0    1   1   1   1   1    0     0   1   i   i   i    i   i   P   P 1   0        0   t        t   i   1   -   -   d   d   d    d   d if (Pt) Rd=memub(#u6)
1   0   0    1   1   1   1   1    0     0   1   i   i   i    i   i   P   P 1   0        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt) Rd=memub(#u6)
1   0   0    1   1   1   1   1    0     0   1   i   i   i    i   i   P   P 1   1        0   t        t   i   1   -   -   d   d   d    d   d if (Pt.new) Rd=memub(#u6)
1   0   0    1   1   1   1   1    0     0   1   i   i   i    i   i   P   P 1   1        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt.new) Rd=memub(#u6)




                           Field name                                                                    Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t2                         Field to encode register t
                         t5                         Field to encode register t
                         v2                         Field to encode register v
                         x5                         Field to encode register x




80-N2040-36 B                                                                  263

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Load unsigned halfword
                         Load an unsigned halfword from memory. The 16-bit halfword at the effective address in
                         memory is placed in the least-significant 16 bits of the destination register. The destination
                         register is zero-extended from 16 bits to 32.

                                                Syntax                                                                  Behavior
                         Rd=memuh(Re=#U6)                                            apply_extension(#U);
                                                                                     EA=#U;
                                                                                     Rd = *EA;
                                                                                     Re=#U;
                         Rd=memuh(Rs+#s11:1)                                         apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     Rd = *EA;
                         Rd=memuh(Rs+Rt<<#u2)                                        EA=Rs+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memuh(Rt<<#u2+#U6)                                       apply_extension(#U);
                                                                                     EA=#U+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memuh(Rx++#s4:1)                                         EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     Rd = *EA;
                         Rd=memuh(Rx++#s4:1:circ(Mu)) EA=Rx;
                                                      Rx=Rx=circ_add(Rx,#s,MuV);
                                                      Rd = *EA;
                         Rd=memuh(Rx++I:circ(Mu))                                    EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                                                     Rd = *EA;
                         Rd=memuh(Rx++Mu)                                            EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memuh(Rx++Mu:brev)                                       EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memuh(gp+#u16:1)                                         apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     Rd = *EA;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                              s5           Parse                 t5                               d5
0   0   1    1   1   0   1   0    0     1   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   -   -   d   d   d    d   d Rd=memuh(Rs+Rt<<#u2)
                                            U
    ICLASS                        Type                               Parse                                                  d5
                                            N
0   1   0    0   1   i   i   1    0     1   1   i   i   i    i   i   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=memuh(gp+#u16:1)
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                  d5
                                            N




80-N2040-36 B                                                                    264

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   0   i   i   1    0     1   1   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=memuh(Rs+#s11:1)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   0   0   1    0     1   1   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d  Rd=memuh(Rx++#s4:1:circ(Mu))
1   0   0    1   1   0   0   1    0     1   1   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d  Rd=memuh(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     1   1   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=memuh(Re=#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    0     1   1   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=memuh(Rx++#s4:1)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   1    0     1   1   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=memuh(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   1    0     1   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memuh(Rx++Mu)
1   0   0    1   1   1   1   1    0     1   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memuh(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    265

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Load unsigned halfword conditionally
                         Load an unsigned halfword from memory. The 16-bit halfword at the effective address in
                         memory is placed in the least-significant 16 bits of the destination register. The destination
                         register is zero-extended from 16 bits to 32.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                             Syntax                                                                  Behavior
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memuh(#u6)                                                apply_extension(#u);
                                                                                      EA=#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memuh(Rs+#u6:1)                                           apply_extension(#u);
                                                                                      EA=Rs+#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if([!]Pt[.new][0]){
                         Rd=memuh(Rx++#s4:1)                                          EA=Rx;
                                                                                      Rx=Rx+#s;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]) {
                         Rd=memuh(Rs+Rt<<#u2)                                         EA=Rs+(Rt<<#u);
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS                                           s5           Parse                 t5                               d5

0   0   1    1   0   0   0   0   0   1   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv) Rd=memuh(Rs+Rt<<#u2)
0   0   1    1   0   0   0   1   0   1   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv) Rd=memuh(Rs+Rt<<#u2)
0   0   1    1   0   0   1   0   0   1   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (Pv.new) Rd=memuh(Rs+Rt<<#u2)
0   0   1    1   0   0   1   1   0   1   1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv.new) Rd=memuh(Rs+Rt<<#u2)




80-N2040-36 B                                                                 266

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7   6   5   4   3   2    1   0
                        Pr
                     Se
                        ed                  U
    ICLASS           ns           Type                  s5           Parse         t2                                            d5
                        Ne                  N
                      e
                        w
0   1   0    0   0   0   0   1    0     1   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memuh(Rs+#u6:1)
0   1   0    0   0   0   1   1    0     1   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memuh(Rs+#u6:1)
0   1   0    0   0   1   0   1    0     1   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memuh(Rs+#u6:1)
0   1   0    0   0   1   1   1    0     1   1   s   s   s    s   s   P   P 0   t        t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memuh(Rs+#u6:1)
                                            U
    ICLASS       Amode           Type                   x5           Parse                      t2                               d5
                                            N
1   0   0    1   1   0   1   1    0     1   1   x   x   x    x   x   P   P 1   0        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memuh(Rx++#s4:1)
1   0   0    1   1   0   1   1    0     1   1   x   x   x    x   x   P   P 1   0        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memuh(Rx++#s4:1)
1   0   0    1   1   0   1   1    0     1   1   x   x   x    x   x   P   P 1   1        0   t        t   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memuh(Rx++#s4:1)
1   0   0    1   1   0   1   1    0     1   1   x   x   x    x   x   P   P 1   1        1   t        t   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memuh(Rx++#s4:1)

    ICLASS       Amode           Type       U                        Parse                      t2                               d5
                                            N
1   0   0    1   1   1   1   1    0     1   1   i   i   i    i   i   P   P 1   0        0   t        t   i   1   -   -   d   d   d    d   d if (Pt) Rd=memuh(#u6)
1   0   0    1   1   1   1   1    0     1   1   i   i   i    i   i   P   P 1   0        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt) Rd=memuh(#u6)
1   0   0    1   1   1   1   1    0     1   1   i   i   i    i   i   P   P 1   1        0   t        t   i   1   -   -   d   d   d    d   d if (Pt.new) Rd=memuh(#u6)
1   0   0    1   1   1   1   1    0     1   1   i   i   i    i   i   P   P 1   1        1   t        t   i   1   -   -   d   d   d    d   d if (!Pt.new) Rd=memuh(#u6)




                           Field name                                                                    Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t2                         Field to encode register t
                         t5                         Field to encode register t
                         v2                         Field to encode register v
                         x5                         Field to encode register x




80-N2040-36 B                                                                  267

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Load word
                         Load a 32-bit word from memory and place in a destination register.

                                                Syntax                                                                  Behavior
                         Rd=memw(Re=#U6)                                             apply_extension(#U);
                                                                                     EA=#U;
                                                                                     Rd = *EA;
                                                                                     Re=#U;
                         Rd=memw(Rs+#s11:2)                                          apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     Rd = *EA;
                         Rd=memw(Rs+Rt<<#u2)                                         EA=Rs+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memw(Rt<<#u2+#U6)                                        apply_extension(#U);
                                                                                     EA=#U+(Rt<<#u);
                                                                                     Rd = *EA;
                         Rd=memw(Rx++#s4:2)                                          EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     Rd = *EA;
                         Rd=memw(Rx++#s4:2:circ(Mu))                                 EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,#s,MuV);
                                                                                     Rd = *EA;
                         Rd=memw(Rx++I:circ(Mu))                                     EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                                                     Rd = *EA;
                         Rd=memw(Rx++Mu)                                             EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memw(Rx++Mu:brev)                                        EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     Rd = *EA;
                         Rd=memw(gp+#u16:2)                                          apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     Rd = *EA;


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                              s5           Parse                 t5                               d5
0   0   1    1   1   0   1   0    1     0   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   -   -   d   d   d    d   d Rd=memw(Rs+Rt<<#u2)
                                            U
    ICLASS                        Type                               Parse                                                  d5
                                            N
0   1   0    0   1   i   i   1    1     0   0   i   i   i    i   i   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=memw(gp+#u16:2)
                                            U
    ICLASS       Amode           Type       N           s5           Parse                                                  d5

1   0   0    1   0   i   i   1    1     0   0   s   s   s    s   s   P   P   i   i     i   i    i   i   i   i   i   d   d   d    d   d Rd=memw(Rs+#s11:2)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                               d5
                                            N




80-N2040-36 B                                                                    268

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   1   0   0   1    1     0   0   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d   Rd=memw(Rx++#s4:2:circ(Mu))
1   0   0    1   1   0   0   1    1     0   0   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d   Rd=memw(Rx++I:circ(Mu))
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    1     0   0   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=memw(Re=#U6)

    ICLASS       Amode           Type       U           x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   1    1     0   0   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=memw(Rx++#s4:2)
                                            U
    ICLASS       Amode           Type       N           t5           Parse                                                 d5

1   0   0    1   1   1   0   1    1     0   0   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=memw(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   1    1     0   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memw(Rx++Mu)
1   0   0    1   1   1   1   1    1     0   0   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memw(Rx++Mu:brev)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    269

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Load word conditionally
                         Load a 32-bit word from memory and place in a destination register.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                             Syntax                                                                     Behavior
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memw(#u6)                                                 apply_extension(#u);
                                                                                      EA=#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if ([!]Pt[.new][0]) {
                         Rd=memw(Rs+#u6:2)                                            apply_extension(#u);
                                                                                      EA=Rs+#u;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pt[.new])                                         if([!]Pt[.new][0]){
                         Rd=memw(Rx++#s4:2)                                           EA=Rx;
                                                                                      Rx=Rx+#s;
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]) {
                         Rd=memw(Rs+Rt<<#u2)                                          EA=Rs+(Rt<<#u);
                                                                                      Rd = *EA;
                                                                                  } else {
                                                                                      NOP;
                                                                                  };


                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS                                           s5           Parse                    t5                               d5
0   0   1    1   0   0   0   0   1   0   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (Pv) Rd=memw(Rs+Rt<<#u2)
0   0   1    1   0   0   0   1   1   0   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv) Rd=memw(Rs+Rt<<#u2)
0   0   1    1   0   0   1   0   1   0   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (Pv.new) Rd=memw(Rs+Rt<<#u2)
0   0   1    1   0   0   1   1   1   0   0   s   s   s    s   s   P   P   i   t        t   t    t   t   i   v   v   d   d   d    d   d   if (!Pv.new) Rd=memw(Rs+Rt<<#u2)
                        Pr
                     Se ed
                                         U
    ICLASS           ns Ne       Type
                                         N           s5           Parse           t2                                        d5
                     e w

0   1   0    0   0   0   0   1   1   0   0   s   s   s    s   s   P   P 0     t        t   i    i   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memw(Rs+#u6:2)




80-N2040-36 B                                                                 270

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7   6   5   4   3   2    1   0
0   1   0    0   0   0   1   1    1     0   0   s   s   s    s   s   P   P 0   t     t   i        i   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memw(Rs+#u6:2)
0   1   0    0   0   1   0   1    1     0   0   s   s   s    s   s   P   P 0   t     t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memw(Rs+#u6:2)
0   1   0    0   0   1   1   1    1     0   0   s   s   s    s   s   P   P 0   t     t   i        i   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memw(Rs+#u6:2)
                                            U
    ICLASS       Amode           Type       N           x5           Parse                   t2                               d5

1   0   0    1   1   0   1   1    1     0   0   x   x   x    x   x   P   P 1   0   0     t        t   i   i   i   i   d   d   d    d   d   if (Pt) Rd=memw(Rx++#s4:2)
1   0   0    1   1   0   1   1    1     0   0   x   x   x    x   x   P   P 1   0   1     t        t   i   i   i   i   d   d   d    d   d   if (!Pt) Rd=memw(Rx++#s4:2)
1   0   0    1   1   0   1   1    1     0   0   x   x   x    x   x   P   P 1   1   0     t        t   i   i   i   i   d   d   d    d   d   if (Pt.new) Rd=memw(Rx++#s4:2)
1   0   0    1   1   0   1   1    1     0   0   x   x   x    x   x   P   P 1   1   1     t        t   i   i   i   i   d   d   d    d   d   if (!Pt.new) Rd=memw(Rx++#s4:2)
                                            U
    ICLASS       Amode           Type                                Parse                   t2                               d5
                                            N
1   0   0    1   1   1   1   1    1     0   0   i   i   i    i   i   P   P 1   0   0     t        t   i   1   -   -   d   d   d    d   d if (Pt) Rd=memw(#u6)
1   0   0    1   1   1   1   1    1     0   0   i   i   i    i   i   P   P 1   0   1     t        t   i   1   -   -   d   d   d    d   d if (!Pt) Rd=memw(#u6)
1   0   0    1   1   1   1   1    1     0   0   i   i   i    i   i   P   P 1   1   0     t        t   i   1   -   -   d   d   d    d   d if (Pt.new) Rd=memw(#u6)
1   0   0    1   1   1   1   1    1     0   0   i   i   i    i   i   P   P 1   1   1     t        t   i   1   -   -   d   d   d    d   d if (!Pt.new) Rd=memw(#u6)




                           Field name                                                                 Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Type                       Type
                         UN                         Unsigned
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t2                         Field to encode register t
                         t5                         Field to encode register t
                         v2                         Field to encode register v
                         x5                         Field to encode register x




80-N2040-36 B                                                                  271

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Deallocate stack frame
                Deallocate a stack frame from the call stack. The instruction first loads the saved FP and
                saved LR values from the address at FP. It then points SP back to the previous frame.

                The stack layout is seen in the following figure.


                                                Stack in Memory

                                                    Saved LR
                                                    Saved FP




                  Higher Address
                                                 Procedure Local
                                                 Data on Stack

                                                                                 Stack frame



                                                    Saved LR
                                                    Saved FP                          FP register



                                                 Procedure Local
                                                 Data on Stack

                                                                                      SP register
                 Lower Address




                                                Unallocated Stack




                               Syntax                                      Behavior
                deallocframe                         EA=FP;
                                                     tmp = *EA;
                                                     tmp = frame_unscramble(tmp);
                                                     LR=tmp.w[1];
                                                     FP=tmp.w[0];
                                                     SP=EA+8;




80-N2040-36 B                                       272

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2   1   0
                                            U
    ICLASS       Amode           Type                               Parse
                                            N
1   0   0    1   0   0   0   0    0     0   0   1   1   1   1   0   P   P 0   -     -   -   -   -   -   -   -   1   1   1   1   0   deallocframe




                           Field name                                                           Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits




80-N2040-36 B                                                                 273

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Deallocate frame and return
                Return from a function with a stack frame. This instruction is equivalent to deallocframe
                followed by jumpr R31.

                              Syntax                                      Behavior
                dealloc_return                      EA=FP;
                                                    tmp = *EA;
                                                    tmp = frame_unscramble(tmp);
                                                    LR=tmp.w[1];
                                                    FP=tmp.w[0];
                                                    SP=EA+8;
                                                    PC=tmp.w[1];
                if ([!]Ps) dealloc_return           ;
                                                    ;
                                                    if ([!]Ps[0]) {
                                                        EA=FP;
                                                        tmp = *EA;
                                                        tmp = frame_unscramble(tmp);
                                                        LR=tmp.w[1];
                                                        FP=tmp.w[0];
                                                        SP=EA+8;
                                                        PC=tmp.w[1];
                                                    } else {
                                                        NOP;
                                                    };
                if ([!]Ps.new)                      ;
                dealloc_return:nt                   if ([!]Ps.new[0]) {
                                                        EA=FP;
                                                        tmp = *EA;
                                                        tmp = frame_unscramble(tmp);
                                                        LR=tmp.w[1];
                                                        FP=tmp.w[0];
                                                        SP=EA+8;
                                                        PC=tmp.w[1];
                                                    } else {
                                                        NOP;
                                                    };
                if ([!]Ps.new)                      ;
                dealloc_return:t                    if ([!]Ps.new[0]) {
                                                        EA=FP;
                                                        tmp = *EA;
                                                        tmp = frame_unscramble(tmp);
                                                        LR=tmp.w[1];
                                                        FP=tmp.w[0];
                                                        SP=EA+8;
                                                        PC=tmp.w[1];
                                                    } else {
                                                        NOP;
                                                    };




80-N2040-36 B                                      274

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Class: LD (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2   1   0
                                            U
    ICLASS       Amode           Type                               Parse
                                            N
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 0   0   0   0   -        -   -   -   -   1   1   1   1   0   dealloc_return
                                            U
    ICLASS       Amode           Type                               Parse                     s2
                                            N
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 0   0   1   0   s        s   -   -   -   1   1   1   1   0   if (Ps.new) dealloc_return:nt
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 0   1   0   0   s        s   -   -   -   1   1   1   1   0   if (Ps) dealloc_return
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 0   1   1   0   s        s   -   -   -   1   1   1   1   0   if (Ps.new) dealloc_return:t
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 1   0   1   0   s        s   -   -   -   1   1   1   1   0   if (!Ps.new) dealloc_return:nt
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 1   1   0   0   s        s   -   -   -   1   1   1   1   0   if (!Ps) dealloc_return
1   0   0    1   0   1   1   0    0     0   0   1   1   1   1   0   P   P 1   1   1   0   s        s   -   -   -   1   1   1   1   0   if (!Ps.new) dealloc_return:t




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         s2                         Field to encode register s




80-N2040-36 B                                                                 275

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                              Instruction Set



Load and unpack bytes to halfwords
                Load contiguous bytes from memory and vector unpack them into halfwords.
                                                           Rdd=memubh(amode)

                                                                                mem


                   zero           zero            zero           zero           Rdd



                                                           Rd=memubh(amode)

                                                                                mem


                                                  zero           zero           Rdd




80-N2040-36 B                                   276

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                            Instruction Set



                               Syntax                                Behavior
                Rd=membh(Re=#U6)                 apply_extension(#U);
                                                 EA=#U;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                                                 Re=#U;
                Rd=membh(Rs)                     Assembler mapped to: "Rd=membh""(Rs+#0)"
                Rd=membh(Rs+#s11:1)              apply_extension(#s);
                                                 EA=Rs+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rd=membh(Rt<<#u2+#U6)            apply_extension(#U);
                                                 EA=#U+(Rt<<#u);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rd=membh(Rx++#s4:1)              EA=Rx;
                                                 Rx=Rx+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rd=membh(Rx++#s4:1:circ(Mu))     EA=Rx;
                                                 Rx=Rx=circ_add(Rx,#s,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rd=membh(Rx++I:circ(Mu))         EA=Rx;
                                                 Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;




80-N2040-36 B                                   277

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                            Instruction Set



                             Syntax                                  Behavior
                Rd=membh(Rx++Mu)                 EA=Rx;
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rd=membh(Rx++Mu:brev)            EA=Rx.h[1] | brev(Rx.h[0]);
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rd=memubh(Re=#U6)                apply_extension(#U);
                                                 EA=#U;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                                                 Re=#U;
                Rd=memubh(Rs+#s11:1)             apply_extension(#s);
                                                 EA=Rs+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rd=memubh(Rt<<#u2+#U6)           apply_extension(#U);
                                                 EA=#U+(Rt<<#u);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rd=memubh(Rx++#s4:1)             EA=Rx;
                                                 Rx=Rx+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;




80-N2040-36 B                                   278

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                            Instruction Set



                             Syntax                                  Behavior
                Rd=memubh(Rx++#s4:1:circ(Mu))    EA=Rx;
                                                 Rx=Rx=circ_add(Rx,#s,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rd=memubh(Rx++I:circ(Mu))        EA=Rx;
                                                 Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rd=memubh(Rx++Mu)                EA=Rx;
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rd=memubh(Rx++Mu:brev)           EA=Rx.h[1] | brev(Rx.h[0]);
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rdd=membh(Re=#U6)                apply_extension(#U);
                                                 EA=#U;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                                                 Re=#U;
                Rdd=membh(Rs)                    Assembler mapped to: "Rdd=membh""(Rs+#0)"
                Rdd=membh(Rs+#s11:2)             apply_extension(#s);
                                                 EA=Rs+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;




80-N2040-36 B                                   279

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                            Instruction Set



                             Syntax                                  Behavior
                Rdd=membh(Rt<<#u2+#U6)           apply_extension(#U);
                                                 EA=#U+(Rt<<#u);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rdd=membh(Rx++#s4:2)             EA=Rx;
                                                 Rx=Rx+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rdd=membh(Rx++#s4:2:circ(Mu))    EA=Rx;
                                                 Rx=Rx=circ_add(Rx,#s,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rdd=membh(Rx++I:circ(Mu))        EA=Rx;
                                                 Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rdd=membh(Rx++Mu)                EA=Rx;
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;
                Rdd=membh(Rx++Mu:brev)           EA=Rx.h[1] | brev(Rx.h[0]);
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.b[i];
                                                     };
                                                 };
                                                 ;




80-N2040-36 B                                   280

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                            Instruction Set



                             Syntax                                  Behavior
                Rdd=memubh(Re=#U6)               apply_extension(#U);
                                                 EA=#U;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                                                 Re=#U;
                Rdd=memubh(Rs+#s11:2)            apply_extension(#s);
                                                 EA=Rs+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rdd=memubh(Rt<<#u2+#U6)          apply_extension(#U);
                                                 EA=#U+(Rt<<#u);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;




80-N2040-36 B                                   281

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                            Instruction Set



                             Syntax                                  Behavior
                Rdd=memubh(Rx++#s4:2)            EA=Rx;
                                                 Rx=Rx+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rdd=memubh(Rx++#s4:2:circ(Mu)) EA=Rx;
                                               Rx=Rx=circ_add(Rx,#s,MuV);
                                               {
                                                   tmpV = *EA;
                                                   for (i=0;i<4;i++) {
                                                       Rdd.h[i]=tmpV.ub[i];
                                                   };
                                               };
                                               ;
                Rdd=memubh(Rx++I:circ(Mu))       EA=Rx;
                                                 Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rdd=memubh(Rx++Mu)               EA=Rx;
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;
                Rdd=memubh(Rx++Mu:brev)          EA=Rx.h[1] | brev(Rx.h[0]);
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.h[i]=tmpV.ub[i];
                                                     };
                                                 };
                                                 ;




80-N2040-36 B                                   282

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                         Class: LD (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                 d5
                                            N
1   0   0    1   0   i   i   0    0     0   1   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=membh(Rs+#s11:1)
1   0   0    1   0   i   i   0    0     1   1   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rd=memubh(Rs+#s11:1)
1   0   0    1   0   i   i   0    1     0   1   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rdd=memubh(Rs+#s11:2)
1   0   0    1   0   i   i   0    1     1   1   s   s   s    s   s   P   P   i   i     i   i   i   i   i   i   i   d   d   d    d   d Rdd=membh(Rs+#s11:2)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   0   0   0    0     0   1   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d  Rd=membh(Rx++#s4:1:circ(Mu))
1   0   0    1   1   0   0   0    0     0   1   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d Rd=membh(Rx++I:circ(Mu))
1   0   0    1   1   0   0   0    0     1   1   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d Rd=memubh(Rx++#s4:1:circ(Mu))
1   0   0    1   1   0   0   0    0     1   1   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d Rd=memubh(Rx++I:circ(Mu))
1   0   0    1   1   0   0   0    1     0   1   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d  Rdd=memubh(Rx++#s4:2:circ(Mu))
1   0   0    1   1   0   0   0    1     0   1   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d Rdd=memubh(Rx++I:circ(Mu))
1   0   0    1   1   0   0   0    1     1   1   x   x   x    x   x   P   P   u 0       -   -   0   i   i   i   i   d   d   d    d   d Rdd=membh(Rx++#s4:2:circ(Mu))
1   0   0    1   1   0   0   0    1     1   1   x   x   x    x   x   P   P   u 0       -   -   1   -   0   -   -   d   d   d    d   d Rdd=membh(Rx++I:circ(Mu))

    ICLASS       Amode           Type       U           e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   0    0     0   1   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=membh(Re=#U6)
                                            U
    ICLASS       Amode           Type       N           x5           Parse                                                 d5

1   0   0    1   1   0   1   0    0     0   1   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=membh(Rx++#s4:1)

    ICLASS       Amode           Type       U           e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   0    0     1   1   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rd=memubh(Re=#U6)

    ICLASS       Amode           Type       U
                                            N           x5           Parse                                                 d5

1   0   0    1   1   0   1   0    0     1   1   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rd=memubh(Rx++#s4:1)
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   0    1     0   1   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rdd=memubh(Re=#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   0    1     0   1   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rdd=memubh(Rx++#s4:2)
                                            U
    ICLASS       Amode           Type                   e5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   0    1     1   1   e   e   e    e   e   P   P 0     1     I   I   I   I   -   I   I   d   d   d    d   d Rdd=membh(Re=#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse                                                 d5
                                            N
1   0   0    1   1   0   1   0    1     1   1   x   x   x    x   x   P   P 0     0     -   -   -   i   i   i   i   d   d   d    d   d Rdd=membh(Rx++#s4:2)
                                            U
    ICLASS       Amode           Type       N
                                                        t5           Parse                                                 d5

1   0   0    1   1   1   0   0    0     0   1   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=membh(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type       N
                                                        x5           Parse u1                                              d5




80-N2040-36 B                                                                    283

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    1   1   1   0   0    0     0   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=membh(Rx++Mu)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   0    0     1   1   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rd=memubh(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   0    0     1   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memubh(Rx++Mu)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   0    1     0   1   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d  Rdd=memubh(Rt<<#u2+#U6)
                                            U
    ICLASS       Amode           Type       N           x5           Parse u1                                              d5

1   0   0    1   1   1   0   0    1     0   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rdd=memubh(Rx++Mu)
                                            U
    ICLASS       Amode           Type                   t5           Parse                                                 d5
                                            N
1   0   0    1   1   1   0   0    1     1   1   t   t   t    t   t   P   P   i   1     I   I   I   I   i   I   I   d   d   d    d   d Rdd=membh(Rt<<#u2+#U6)

                                            U
    ICLASS       Amode           Type                   x5           Parse u1                                              d5
                                            N
1   0   0    1   1   1   0   0    1     1   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rdd=membh(Rx++Mu)
1   0   0    1   1   1   1   0    0     0   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=membh(Rx++Mu:brev)
1   0   0    1   1   1   1   0    0     1   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rd=memubh(Rx++Mu:brev)
1   0   0    1   1   1   1   0    1     0   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rdd=memubh(Rx++Mu:brev)
1   0   0    1   1   1   1   0    1     1   1   x   x   x    x   x   P   P   u 0       -   -   -   -   0   -   -   d   d   d    d   d Rdd=membh(Rx++Mu:brev)



                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         x5                         Field to encode register x




80-N2040-36 B                                                                    284

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                               Instruction Set



       11.6 MEMOP
                The MEMOP instruction class includes simple operations on values in memory.

                MEMOP instructions are executable on slot 0.




80-N2040-36 B                                    285

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Operation on memory byte
                         Perform ALU or bit operation on the memory byte at the effective address.

                                             Syntax                                                               Behavior
                         memb(Rs+#u6:0)=clrbit(#U5)                             apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp &= (~(1<<#U));
                                                                                *EA = tmp;
                         memb(Rs+#u6:0)=setbit(#U5)                             apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp |= (1<<#U);
                                                                                *EA = tmp;
                         memb(Rs+#u6:0)[+-]=#U5                                 apply_extension(#u);
                                                                                EA=Rs[+-]#u;
                                                                                tmp = *EA;
                                                                                tmp [+-]= #U;
                                                                                *EA = tmp;
                         memb(Rs+#u6:0)[+-|&]=Rt                                apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp [+-|&]= Rt;
                                                                                *EA = tmp;


                         Class: MEMOP (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3    2    1   0
    ICLASS                                           s5           Parse                                                t5
0   0   1    1   1   1   1   0   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   0   t    t   t    t   t   memb(Rs+#u6:0)+=Rt
0   0   1    1   1   1   1   0   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   1   t    t   t    t   t   memb(Rs+#u6:0)-=Rt
0   0   1    1   1   1   1   0   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   0   t    t   t    t   t   memb(Rs+#u6:0)&=Rt
0   0   1    1   1   1   1   0   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   1   t    t   t    t   t   memb(Rs+#u6:0)|=Rt
    ICLASS                                           s5           Parse
0   0   1    1   1   1   1   1   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   0   I    I   I    I   I   memb(Rs+#u6:0)+=#U5
0   0   1    1   1   1   1   1   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   1   I    I   I    I   I   memb(Rs+#u6:0)-=#U5
0   0   1    1   1   1   1   1   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   0   I    I   I    I   I   memb(Rs+#u6:0)=clrbit(#U5)
0   0   1    1   1   1   1   1   -   0   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   1   I    I   I    I   I   memb(Rs+#u6:0)=setbit(#U5)




                           Field name                                                         Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s
                         t5                      Field to encode register t




80-N2040-36 B                                                               286

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Operation on memory halfword
                         Perform ALU or bit operation on the memory halfword at the effective address.

                                             Syntax                                                               Behavior
                         memh(Rs+#u6:1)=clrbit(#U5)                             apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp &= (~(1<<#U));
                                                                                *EA = tmp;
                         memh(Rs+#u6:1)=setbit(#U5)                             apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp |= (1<<#U);
                                                                                *EA = tmp;
                         memh(Rs+#u6:1)[+-]=#U5                                 apply_extension(#u);
                                                                                EA=Rs[+-]#u;
                                                                                tmp = *EA;
                                                                                tmp [+-]= #U;
                                                                                *EA = tmp;
                         memh(Rs+#u6:1)[+-|&]=Rt                                apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp [+-|&]= Rt;
                                                                                *EA = tmp;


                         Class: MEMOP (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3    2    1   0
    ICLASS                                           s5           Parse                                                t5
0   0   1    1   1   1   1   0   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   0   t    t   t    t   t   memh(Rs+#u6:1)+=Rt
0   0   1    1   1   1   1   0   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   1   t    t   t    t   t   memh(Rs+#u6:1)-=Rt
0   0   1    1   1   1   1   0   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   0   t    t   t    t   t   memh(Rs+#u6:1)&=Rt
0   0   1    1   1   1   1   0   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   1   t    t   t    t   t   memh(Rs+#u6:1)|=Rt
    ICLASS                                           s5           Parse
0   0   1    1   1   1   1   1   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   0   I    I   I    I   I   memh(Rs+#u6:1)+=#U5
0   0   1    1   1   1   1   1   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   1   I    I   I    I   I   memh(Rs+#u6:1)-=#U5
0   0   1    1   1   1   1   1   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   0   I    I   I    I   I   memh(Rs+#u6:1)=clrbit(#U5)
0   0   1    1   1   1   1   1   -   0   1   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   1   I    I   I    I   I   memh(Rs+#u6:1)=setbit(#U5)




                           Field name                                                         Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s
                         t5                      Field to encode register t




80-N2040-36 B                                                               287

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Operation on memory word
                         Perform ALU or bit operation on the memory word at the effective address.

                                             Syntax                                                               Behavior
                         memw(Rs+#u6:2)=clrbit(#U5)                             apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp &= (~(1<<#U));
                                                                                *EA = tmp;
                         memw(Rs+#u6:2)=setbit(#U5)                             apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp |= (1<<#U);
                                                                                *EA = tmp;
                         memw(Rs+#u6:2)[+-]=#U5                                 apply_extension(#u);
                                                                                EA=Rs[+-]#u;
                                                                                tmp = *EA;
                                                                                tmp [+-]= #U;
                                                                                *EA = tmp;
                         memw(Rs+#u6:2)[+-|&]=Rt                                apply_extension(#u);
                                                                                EA=Rs+#u;
                                                                                tmp = *EA;
                                                                                tmp [+-|&]= Rt;
                                                                                *EA = tmp;


                         Class: MEMOP (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3    2    1   0
    ICLASS                                           s5           Parse                                                t5
0   0   1    1   1   1   1   0   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   0   t    t   t    t   t   memw(Rs+#u6:2)+=Rt
0   0   1    1   1   1   1   0   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   1   t    t   t    t   t   memw(Rs+#u6:2)-=Rt
0   0   1    1   1   1   1   0   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   0   t    t   t    t   t   memw(Rs+#u6:2)&=Rt
0   0   1    1   1   1   1   0   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   1   t    t   t    t   t   memw(Rs+#u6:2)|=Rt
    ICLASS                                           s5           Parse
0   0   1    1   1   1   1   1   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   0   I    I   I    I   I   memw(Rs+#u6:2)+=#U5
0   0   1    1   1   1   1   1   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   0   1   I    I   I    I   I   memw(Rs+#u6:2)-=#U5
0   0   1    1   1   1   1   1   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   0   I    I   I    I   I   memw(Rs+#u6:2)=clrbit(#U5)
0   0   1    1   1   1   1   1   -   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   i   1   1   I    I   I    I   I   memw(Rs+#u6:2)=setbit(#U5)




                           Field name                                                         Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s
                         t5                      Field to encode register t




80-N2040-36 B                                                               288

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



       11.7 NV
                The NV instruction class includes instructions which take the register source operand from
                another instruction in the same packet.

                NV instructions are executable on slot 0.


     11.7.1 NV/J
                The NV/J instruction subclass includes jump instructions which take the register source
                operand from another instruction in the same packet.

Jump to address condition on new register value
                Compare a register or constant against the value produced by a slot 1 instruction. If the
                comparison is true, the program counter is changed to a target address, relative to the
                current PC.

                This instruction is executable only on slot 0.

                               Syntax                                       Behavior
                if ([!]cmp.eq(Ns.new,#-1))            ;
                jump:<hint> #r9:2                     if ((Ns.new[!]=(-1))) {
                                                          apply_extension(#r);
                                                          #r=#r & ~0x3;
                                                          PC=PC+#r;
                                                      };
                if ([!]cmp.eq(Ns.new,#U5))            ;
                jump:<hint> #r9:2                     if ((Ns.new[!]=(#U))) {
                                                          apply_extension(#r);
                                                          #r=#r & ~0x3;
                                                          PC=PC+#r;
                                                      };
                if ([!]cmp.eq(Ns.new,Rt))             ;
                jump:<hint> #r9:2                     if ((Ns.new[!]=Rt)) {
                                                          apply_extension(#r);
                                                          #r=#r & ~0x3;
                                                          PC=PC+#r;
                                                      };
                if ([!]cmp.gt(Ns.new,#-1))            ;
                jump:<hint> #r9:2                     if ([!](Ns.new>(-1))) {
                                                          apply_extension(#r);
                                                          #r=#r & ~0x3;
                                                          PC=PC+#r;
                                                      };
                if ([!]cmp.gt(Ns.new,#U5))            ;
                jump:<hint> #r9:2                     if ([!](Ns.new>(#U))) {
                                                          apply_extension(#r);
                                                          #r=#r & ~0x3;
                                                          PC=PC+#r;
                                                      };




80-N2040-36 B                                       289

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                                             Syntax                                                                Behavior
                         if ([!]cmp.gt(Ns.new,Rt))                              ;
                         jump:<hint> #r9:2                                      if ([!](Ns.new>Rt)) {
                                                                                    apply_extension(#r);
                                                                                    #r=#r & ~0x3;
                                                                                    PC=PC+#r;
                                                                                };
                         if ([!]cmp.gt(Rt,Ns.new))                              ;
                         jump:<hint> #r9:2                                      if ([!](Rt>Ns.new)) {
                                                                                    apply_extension(#r);
                                                                                    #r=#r & ~0x3;
                                                                                    PC=PC+#r;
                                                                                };
                         if ([!]cmp.gtu(Ns.new,#U5))                            ;
                         jump:<hint> #r9:2                                      if ([!](Ns.new.uw[0]>(#U))) {
                                                                                    apply_extension(#r);
                                                                                    #r=#r & ~0x3;
                                                                                    PC=PC+#r;
                                                                                };
                         if ([!]cmp.gtu(Ns.new,Rt))                             ;
                         jump:<hint> #r9:2                                      if ([!](Ns.new.uw[0]>Rt.uw[0])) {
                                                                                    apply_extension(#r);
                                                                                    #r=#r & ~0x3;
                                                                                    PC=PC+#r;
                                                                                };
                         if ([!]cmp.gtu(Rt,Ns.new))                             ;
                         jump:<hint> #r9:2                                      if ([!](Rt.uw[0]>Ns.new.uw[0])) {
                                                                                    apply_extension(#r);
                                                                                    #r=#r & ~0x3;
                                                                                    PC=PC+#r;
                                                                                };
                         if ([!]tstbit(Ns.new,#0))                              ;
                         jump:<hint> #r9:2                                      if ([!]((Ns.new) & 1)) {
                                                                                    apply_extension(#r);
                                                                                    #r=#r & ~0x3;
                                                                                    PC=PC+#r;
                                                                                };


                         Class: NV (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2   1   0
    ICLASS                                               s3       Parse               t5
0   0   1    0   0   0   0   0   0   0   i   i   -   s   s    s   P   P 0   t     t   t    t   t   i   i   i   i    i   i   i   -   if (cmp.eq(Ns.new,Rt)) jump:nt #r9:2
0   0   1    0   0   0   0   0   0   0   i   i   -   s   s    s   P   P 1   t     t   t    t   t   i   i   i   i    i   i   i   -   if (cmp.eq(Ns.new,Rt)) jump:t #r9:2
0   0   1    0   0   0   0   0   0   1   i   i   -   s   s    s   P   P 0   t     t   t    t   t   i   i   i   i    i   i   i   -   if (!cmp.eq(Ns.new,Rt)) jump:nt #r9:2
0   0   1    0   0   0   0   0   0   1   i   i   -   s   s    s   P   P 1   t     t   t    t   t   i   i   i   i    i   i   i   -   if (!cmp.eq(Ns.new,Rt)) jump:t #r9:2
0   0   1    0   0   0   0   0   1   0   i   i   -   s   s    s   P   P 0   t     t   t    t   t   i   i   i   i    i   i   i   -   if (cmp.gt(Ns.new,Rt)) jump:nt #r9:2
0   0   1    0   0   0   0   0   1   0   i   i   -   s   s    s   P   P 1   t     t   t    t   t   i   i   i   i    i   i   i   -   if (cmp.gt(Ns.new,Rt)) jump:t #r9:2




80-N2040-36 B                                                               290

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3   2   1   0
0   0   1    0   0   0   0   0   1   1   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gt(Ns.new,Rt)) jump:nt #r9:2
0   0   1    0   0   0   0   0   1   1   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gt(Ns.new,Rt)) jump:t #r9:2
0   0   1    0   0   0   0   1   0   0   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (cmp.gtu(Ns.new,Rt)) jump:nt #r9:2
0   0   1    0   0   0   0   1   0   0   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (cmp.gtu(Ns.new,Rt)) jump:t #r9:2
0   0   1    0   0   0   0   1   0   1   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gtu(Ns.new,Rt)) jump:nt #r9:2
0   0   1    0   0   0   0   1   0   1   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gtu(Ns.new,Rt)) jump:t #r9:2
0   0   1    0   0   0   0   1   1   0   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (cmp.gt(Rt,Ns.new)) jump:nt #r9:2
0   0   1    0   0   0   0   1   1   0   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (cmp.gt(Rt,Ns.new)) jump:t #r9:2
0   0   1    0   0   0   0   1   1   1   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gt(Rt,Ns.new)) jump:nt #r9:2
0   0   1    0   0   0   0   1   1   1   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gt(Rt,Ns.new)) jump:t #r9:2
0   0   1    0   0   0   1   0   0   0   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (cmp.gtu(Rt,Ns.new)) jump:nt #r9:2
0   0   1    0   0   0   1   0   0   0   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (cmp.gtu(Rt,Ns.new)) jump:t #r9:2
0   0   1    0   0   0   1   0   0   1   i   i   -   s   s    s   P   P 0   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gtu(Rt,Ns.new)) jump:nt #r9:2
0   0   1    0   0   0   1   0   0   1   i   i   -   s   s    s   P   P 1   t     t   t   t   t   i   i   i   i   i   i   i   -   if (!cmp.gtu(Rt,Ns.new)) jump:t #r9:2
    ICLASS                                               s3       Parse
0   0   1    0   0   1   0   0   0   0   i   i   -   s   s    s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   if (cmp.eq(Ns.new,#U5)) jump:nt #r9:2
0   0   1    0   0   1   0   0   0   0   i   i   -   s   s    s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   if (cmp.eq(Ns.new,#U5)) jump:t #r9:2
0   0   1    0   0   1   0   0   0   1   i   i   -   s   s    s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   if (!cmp.eq(Ns.new,#U5)) jump:nt #r9:2
0   0   1    0   0   1   0   0   0   1   i   i   -   s   s    s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   if (!cmp.eq(Ns.new,#U5)) jump:t #r9:2
0   0   1    0   0   1   0   0   1   0   i   i   -   s   s    s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   if (cmp.gt(Ns.new,#U5)) jump:nt #r9:2
0   0   1    0   0   1   0   0   1   0   i   i   -   s   s    s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   if (cmp.gt(Ns.new,#U5)) jump:t #r9:2
0   0   1    0   0   1   0   0   1   1   i   i   -   s   s    s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   if (!cmp.gt(Ns.new,#U5)) jump:nt #r9:2
0   0   1    0   0   1   0   0   1   1   i   i   -   s   s    s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   if (!cmp.gt(Ns.new,#U5)) jump:t #r9:2
0   0   1    0   0   1   0   1   0   0   i   i   -   s   s    s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   if (cmp.gtu(Ns.new,#U5)) jump:nt #r9:2
0   0   1    0   0   1   0   1   0   0   i   i   -   s   s    s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   if (cmp.gtu(Ns.new,#U5)) jump:t #r9:2
0   0   1    0   0   1   0   1   0   1   i   i   -   s   s    s   P   P 0   I     I   I   I   I   i   i   i   i   i   i   i   -   if (!cmp.gtu(Ns.new,#U5)) jump:nt #r9:2
0   0   1    0   0   1   0   1   0   1   i   i   -   s   s    s   P   P 1   I     I   I   I   I   i   i   i   i   i   i   i   -   if (!cmp.gtu(Ns.new,#U5)) jump:t #r9:2
0   0   1    0   0   1   0   1   1   0   i   i   -   s   s    s   P   P 0   -     -   -   -   -   i   i   i   i   i   i   i   -   if (tstbit(Ns.new,#0)) jump:nt #r9:2
0   0   1    0   0   1   0   1   1   0   i   i   -   s   s    s   P   P 1   -     -   -   -   -   i   i   i   i   i   i   i   -   if (tstbit(Ns.new,#0)) jump:t #r9:2
0   0   1    0   0   1   0   1   1   1   i   i   -   s   s    s   P   P 0   -     -   -   -   -   i   i   i   i   i   i   i   -   if (!tstbit(Ns.new,#0)) jump:nt #r9:2
0   0   1    0   0   1   0   1   1   1   i   i   -   s   s    s   P   P 1   -     -   -   -   -   i   i   i   i   i   i   i   -   if (!tstbit(Ns.new,#0)) jump:t #r9:2
0   0   1    0   0   1   1   0   0   0   i   i   -   s   s    s   P   P 0   -     -   -   -   -   i   i   i   i   i   i   i   -   if (cmp.eq(Ns.new,#-1)) jump:nt #r9:2




80-N2040-36 B                                                               291

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                         8   7   6   5   4   3   2   1   0
0   0   1   0   0   1   1   0   0   0   i   i   -   s   s   s   P   P 1   -     -   -   -   -   i   i   i   i   i   i   i   -   if (cmp.eq(Ns.new,#-1)) jump:t #r9:2
0   0   1   0   0   1   1   0   0   1   i   i   -   s   s   s   P   P 0   -     -   -   -   -   i   i   i   i   i   i   i   -   if (!cmp.eq(Ns.new,#-1)) jump:nt #r9:2
0   0   1   0   0   1   1   0   0   1   i   i   -   s   s   s   P   P 1   -     -   -   -   -   i   i   i   i   i   i   i   -   if (!cmp.eq(Ns.new,#-1)) jump:t #r9:2
0   0   1   0   0   1   1   0   1   0   i   i   -   s   s   s   P   P 0   -     -   -   -   -   i   i   i   i   i   i   i   -   if (cmp.gt(Ns.new,#-1)) jump:nt #r9:2
0   0   1   0   0   1   1   0   1   0   i   i   -   s   s   s   P   P 1   -     -   -   -   -   i   i   i   i   i   i   i   -   if (cmp.gt(Ns.new,#-1)) jump:t #r9:2
0   0   1   0   0   1   1   0   1   1   i   i   -   s   s   s   P   P 0   -     -   -   -   -   i   i   i   i   i   i   i   -   if (!cmp.gt(Ns.new,#-1)) jump:nt #r9:2
0   0   1   0   0   1   1   0   1   1   i   i   -   s   s   s   P   P 1   -     -   -   -   -   i   i   i   i   i   i   i   -   if (!cmp.gt(Ns.new,#-1)) jump:t #r9:2




                          Field name                                                        Description
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        s3                      Field to encode register s
                        t5                      Field to encode register t




80-N2040-36 B                                                             292

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



     11.7.2 NV/ST
                  The NV/ST instruction subclass includes store instructions which take the register source
                  operand from another instruction in the same packet.

Store new-value byte
                  Store the least-significant byte in a source register in memory at the effective address.

                               Syntax                                          Behavior
                memb(Re=#U6)=Nt.new                     apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Nt.new&0xff;
                                                        Re=#U;
                memb(Rs+#s11:0)=Nt.new                  apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Nt.new&0xff;
                memb(Rs+Ru<<#u2)=Nt.new                 EA=Rs+(Ru<<#u);
                                                        *EA = Nt.new&0xff;
                memb(Ru<<#u2+#U6)=Nt.new                apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Nt.new&0xff;
                memb(Rx++#s4:0)=Nt.new                  EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Nt.new&0xff;
                memb(Rx++#s4:0:circ(Mu))=Nt.new EA=Rx;
                                                Rx=Rx=circ_add(Rx,#s,MuV);
                                                *EA = Nt.new&0xff;
                memb(Rx++I:circ(Mu))=Nt.new             EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                        *EA = Nt.new&0xff;
                memb(Rx++Mu)=Nt.new                     EA=Rx;
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new&0xff;
                memb(Rx++Mu:brev)=Nt.new                EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new&0xff;
                memb(gp+#u16:0)=Nt.new                  apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        *EA = Nt.new&0xff;


                  Class: NV (slots 0)

                  Notes

                       ï®   Forms of this instruction which use a new-value operand produced in the packet
                           must execute on slot 0.
                       ï®   This instruction can execute only in slot 0, even though it is an ST instruction.




80-N2040-36 B                                          293

                   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1    0
    ICLASS                                               s5           Parse               u5                                    t3
0   0   1    1   1   0   1   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   -   -   0   0   t   t    t   memb(Rs+Ru<<#u2)=Nt.new
    ICLASS                            Type                            Parse                    t3
0   1   0    0   1   i   i   0    1     0    1   i   i   i    i   i   P   P   i   0   0   t    t    t   i   i   i   i   i   i   i    i   memb(gp+#u16:0)=Nt.new
                                             U
    ICLASS       Amode           Type                    s5           Parse                    t3
                                             N
1   0   1    0   0   i   i   1    1     0    1   s   s   s    s   s   P   P   i   0   0   t    t    t   i   i   i   i   i   i   i    i   memb(Rs+#s11:0)=Nt.new

    ICLASS       Amode           Type        U           x5           Parse u1                 t3
                                             N
1   0   1    0   1   0   0   1    1     0    1   x   x   x    x   x   P   P   u 0     0   t    t    t   0   -   -   -   -   -   1    -   memb(Rx++I:circ(Mu))=Nt.new
1   0   1    0   1   0   0   1    1     0    1   x   x   x    x   x   P   P   u 0     0   t    t    t   0   i   i   i   i   -   0    -   memb(Rx++#s4:0:circ(Mu))=Nt.new
                                             U
    ICLASS       Amode           Type                    e5           Parse                    t3
                                             N
1   0   1    0   1   0   1   1    1     0    1   e   e   e    e   e   P   P 0     0   0   t    t    t   1   -   I   I   I   I   I    I   memb(Re=#U6)=Nt.new
                                             U
    ICLASS       Amode           Type        N           x5           Parse                    t3

1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 0     0   0   t    t    t   0   i   i   i   i   -   0    -   memb(Rx++#s4:0)=Nt.new
                                             U
    ICLASS       Amode           Type                    u5           Parse                    t3
                                             N
1   0   1    0   1   1   0   1    1     0    1   u   u   u    u   u   P   P   i   0   0   t    t    t   1   i   I   I   I   I   I    I   memb(Ru<<#u2+#U6)=Nt.new

    ICLASS       Amode           Type        U           x5           Parse u1                 t3
                                             N
1   0   1    0   1   1   0   1    1     0    1   x   x   x    x   x   P   P   u 0     0   t    t    t   0   -   -   -   -   -   -    -   memb(Rx++Mu)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   x   x   x    x   x   P   P   u 0     0   t    t    t   0   -   -   -   -   -   -    -   memb(Rx++Mu:brev)=Nt.new




                           Field name                                                               Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         Parse                       Packet/Loop parse bits
                         e5                          Field to encode register e
                         s5                          Field to encode register s
                         t3                          Field to encode register t
                         u1                          Field to encode register u
                         u5                          Field to encode register u
                         x5                          Field to encode register x
                         Amode                       Amode
                         Type                        Type
                         UN                          Unsigned




80-N2040-36 B                                                                     294

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Store new-value byte conditionally
                Store the least-significant byte in a source register in memory at the effective address.

                This instruction is conditional based on a predicate value. If the predicate is true, the
                instruction is performed, otherwise it is treated as a NOP.

                               Syntax                                        Behavior
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memb(#u6)=Nt.new                          apply_extension(#u);
                                                          EA=#u;
                                                          *EA = Nt[.new]&0xff;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      apply_extension(#u);
                memb(Rs+#u6:0)=Nt.new                 if ([!]Pv[.new][0]) {
                                                          EA=Rs+#u;
                                                          *EA = Nt[.new]&0xff;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memb(Rs+Ru<<#u2)=Nt.new                   EA=Rs+(Ru<<#u);
                                                          *EA = Nt[.new]&0xff;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]){
                memb(Rx++#s4:0)=Nt.new                    EA=Rx;
                                                          Rx=Rx+#s;
                                                          *EA = Nt[.new]&0xff;
                                                      } else {
                                                          NOP;
                                                      };


                Class: NV (slots 0)

                Notes

                     ï®   Forms of this instruction which use a new-value operand produced in the packet
                         must execute on slot 0.
                     ï®   This instruction can execute only in slot 0, even though it is an ST instruction.




80-N2040-36 B                                        295

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1    0
    ICLASS                                               s5           Parse               u5                                    t3
0   0   1    1   0   1   0   0    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     0   t   t    t   if (Pv) memb(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   0   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     0   t   t    t   if (!Pv) memb(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   1   0    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     0   t   t    t   if (Pv.new) memb(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   1   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     0   t   t    t   if (!Pv.new) memb(Rs+Ru<<#u2)=Nt.new
                        Pr
                     Se
                        ed
    ICLASS           ns Ne            Type               s5           Parse                    t3
                     e w

0   1   0    0   0   0   0   0    1     0    1   s   s   s    s   s   P   P   i   0   0   t    t    t   i   i   i   i   i   0   v    v   if (Pv) memb(Rs+#u6:0)=Nt.new
0   1   0    0   0   0   1   0    1     0    1   s   s   s    s   s   P   P   i   0   0   t    t    t   i   i   i   i   i   0   v    v   if (Pv.new) memb(Rs+#u6:0)=Nt.new
0   1   0    0   0   1   0   0    1     0    1   s   s   s    s   s   P   P   i   0   0   t    t    t   i   i   i   i   i   0   v    v   if (!Pv) memb(Rs+#u6:0)=Nt.new
0   1   0    0   0   1   1   0    1     0    1   s   s   s    s   s   P   P   i   0   0   t    t    t   i   i   i   i   i   0   v    v   if (!Pv.new) memb(Rs+#u6:0)=Nt.new
                                             U
    ICLASS       Amode           Type        N           x5           Parse                    t3

1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   0   t    t    t   0   i   i   i   i   0   v    v   if (Pv) memb(Rx++#s4:0)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   0   t    t    t   0   i   i   i   i   1   v    v   if (!Pv) memb(Rx++#s4:0)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   0   t    t    t   1   i   i   i   i   0   v    v   if (Pv.new) memb(Rx++#s4:0)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   0   t    t    t   1   i   i   i   i   1   v    v   if (!Pv.new) memb(Rx++#s4:0)=Nt.new

                                             U
    ICLASS       Amode           Type        N                        Parse                    t3

1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 0     0   0   t    t    t   1   i   i   i   i   0   v    v if (Pv) memb(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 0     0   0   t    t    t   1   i   i   i   i   1   v    v if (!Pv) memb(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 1     0   0   t    t    t   1   i   i   i   i   0   v    v if (Pv.new) memb(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 1     0   0   t    t    t   1   i   i   i   i   1   v    v if (!Pv.new) memb(#u6)=Nt.new




                           Field name                                                               Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         PredNew                     PredNew
                         Sense                       Sense
                         Parse                       Packet/Loop parse bits
                         s5                          Field to encode register s
                         t3                          Field to encode register t
                         u5                          Field to encode register u
                         v2                          Field to encode register v
                         x5                          Field to encode register x




80-N2040-36 B                                                                     296

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                 297

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Store new-value halfword
                  Store the upper or lower 16-bits of a source register in memory at the effective address.

                               Syntax                                          Behavior
                memh(Re=#U6)=Nt.new                     apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Nt.new.h[0];
                                                        Re=#U;
                memh(Rs+#s11:1)=Nt.new                  apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Nt.new.h[0];
                memh(Rs+Ru<<#u2)=Nt.new                 EA=Rs+(Ru<<#u);
                                                        *EA = Nt.new.h[0];
                memh(Ru<<#u2+#U6)=Nt.new                apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Nt.new.h[0];
                memh(Rx++#s4:1)=Nt.new                  EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Nt.new.h[0];
                memh(Rx++#s4:1:circ(Mu))=Nt.new EA=Rx;
                                                Rx=Rx=circ_add(Rx,#s,MuV);
                                                *EA = Nt.new.h[0];
                memh(Rx++I:circ(Mu))=Nt.new             EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                        *EA = Nt.new.h[0];
                memh(Rx++Mu)=Nt.new                     EA=Rx;
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new.h[0];
                memh(Rx++Mu:brev)=Nt.new                EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new.h[0];
                memh(gp+#u16:1)=Nt.new                  apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        *EA = Nt.new.h[0];


                  Class: NV (slots 0)

                  Notes

                       ï®   Forms of this instruction which use a new-value operand produced in the packet
                           must execute on slot 0.
                       ï®   This instruction can execute only in slot 0, even though it is an ST instruction.




80-N2040-36 B                                          298

                   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1    0
    ICLASS                                               s5           Parse               u5                                    t3
0   0   1    1   1   0   1   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   -   -   0   1   t   t    t   memh(Rs+Ru<<#u2)=Nt.new
    ICLASS                            Type                            Parse                    t3
0   1   0    0   1   i   i   0    1     0    1   i   i   i    i   i   P   P   i   0   1   t    t    t   i   i   i   i   i   i   i    i   memh(gp+#u16:1)=Nt.new
                                             U
    ICLASS       Amode           Type                    s5           Parse                    t3
                                             N
1   0   1    0   0   i   i   1    1     0    1   s   s   s    s   s   P   P   i   0   1   t    t    t   i   i   i   i   i   i   i    i   memh(Rs+#s11:1)=Nt.new

    ICLASS       Amode           Type        U           x5           Parse u1                 t3
                                             N
1   0   1    0   1   0   0   1    1     0    1   x   x   x    x   x   P   P   u 0     1   t    t    t   0   -   -   -   -   -   1    -   memh(Rx++I:circ(Mu))=Nt.new

1   0   1    0   1   0   0   1    1     0    1   x   x   x    x   x   P   P   u 0     1   t    t    t   0   i   i   i   i   -   0    -   memh(Rx++#s4:1:circ(Mu))=Nt.new
                                             U
    ICLASS       Amode           Type                    e5           Parse                    t3
                                             N
1   0   1    0   1   0   1   1    1     0    1   e   e   e    e   e   P   P 0     0   1   t    t    t   1   -   I   I   I   I   I    I   memh(Re=#U6)=Nt.new
                                             U
    ICLASS       Amode           Type        N           x5           Parse                    t3

1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 0     0   1   t    t    t   0   i   i   i   i   -   0    -   memh(Rx++#s4:1)=Nt.new
                                             U
    ICLASS       Amode           Type                    u5           Parse                    t3
                                             N
1   0   1    0   1   1   0   1    1     0    1   u   u   u    u   u   P   P   i   0   1   t    t    t   1   i   I   I   I   I   I    I   memh(Ru<<#u2+#U6)=Nt.new

    ICLASS       Amode           Type        U           x5           Parse u1                 t3
                                             N
1   0   1    0   1   1   0   1    1     0    1   x   x   x    x   x   P   P   u 0     1   t    t    t   0   -   -   -   -   -   -    -   memh(Rx++Mu)=Nt.new

1   0   1    0   1   1   1   1    1     0    1   x   x   x    x   x   P   P   u 0     1   t    t    t   0   -   -   -   -   -   -    -   memh(Rx++Mu:brev)=Nt.new




                           Field name                                                               Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         Parse                       Packet/Loop parse bits
                         e5                          Field to encode register e
                         s5                          Field to encode register s
                         t3                          Field to encode register t
                         u1                          Field to encode register u
                         u5                          Field to encode register u
                         x5                          Field to encode register x
                         Amode                       Amode
                         Type                        Type
                         UN                          Unsigned




80-N2040-36 B                                                                     299

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Store new-value halfword conditionally
                Store the upper or lower 16-bits of a source register in memory at the effective address.

                This instruction is conditional based on a predicate value. If the predicate is true, the
                instruction is performed, otherwise it is treated as a NOP.

                               Syntax                                        Behavior
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memh(#u6)=Nt.new                          apply_extension(#u);
                                                          EA=#u;
                                                          *EA = Nt[.new].h[0];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      apply_extension(#u);
                memh(Rs+#u6:1)=Nt.new                 if ([!]Pv[.new][0]) {
                                                          EA=Rs+#u;
                                                          *EA = Nt[.new].h[0];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memh(Rs+Ru<<#u2)=Nt.new                   EA=Rs+(Ru<<#u);
                                                          *EA = Nt[.new].h[0];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]){
                memh(Rx++#s4:1)=Nt.new                    EA=Rx;
                                                          Rx=Rx+#s;
                                                          *EA = Nt[.new].h[0];
                                                      } else {
                                                          NOP;
                                                      };


                Class: NV (slots 0)

                Notes

                     ï®   Forms of this instruction which use a new-value operand produced in the packet
                         must execute on slot 0.
                     ï®   This instruction can execute only in slot 0, even though it is an ST instruction.




80-N2040-36 B                                        300

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1    0
    ICLASS                                               s5           Parse               u5                                    t3
0   0   1    1   0   1   0   0    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     1   t   t    t   if (Pv) memh(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   0   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     1   t   t    t   if (!Pv) memh(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   1   0    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     1   t   t    t   if (Pv.new) memh(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   1   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 0     1   t   t    t   if (!Pv.new) memh(Rs+Ru<<#u2)=Nt.new
                        Pr
                     Se
                        ed
    ICLASS           ns Ne            Type               s5           Parse                    t3
                     e w

0   1   0    0   0   0   0   0    1     0    1   s   s   s    s   s   P   P   i   0   1   t    t    t   i   i   i   i   i   0   v    v   if (Pv) memh(Rs+#u6:1)=Nt.new
0   1   0    0   0   0   1   0    1     0    1   s   s   s    s   s   P   P   i   0   1   t    t    t   i   i   i   i   i   0   v    v   if (Pv.new) memh(Rs+#u6:1)=Nt.new
0   1   0    0   0   1   0   0    1     0    1   s   s   s    s   s   P   P   i   0   1   t    t    t   i   i   i   i   i   0   v    v   if (!Pv) memh(Rs+#u6:1)=Nt.new
0   1   0    0   0   1   1   0    1     0    1   s   s   s    s   s   P   P   i   0   1   t    t    t   i   i   i   i   i   0   v    v   if (!Pv.new) memh(Rs+#u6:1)=Nt.new
                                             U
    ICLASS       Amode           Type        N           x5           Parse                    t3

1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   1   t    t    t   0   i   i   i   i   0   v    v   if (Pv) memh(Rx++#s4:1)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   1   t    t    t   0   i   i   i   i   1   v    v   if (!Pv) memh(Rx++#s4:1)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   1   t    t    t   1   i   i   i   i   0   v    v   if (Pv.new) memh(Rx++#s4:1)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     0   1   t    t    t   1   i   i   i   i   1   v    v   if (!Pv.new) memh(Rx++#s4:1)=Nt.new
                                             U
    ICLASS       Amode           Type        N                        Parse                    t3

1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 0     0   1   t    t    t   1   i   i   i   i   0   v    v if (Pv) memh(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 0     0   1   t    t    t   1   i   i   i   i   1   v    v if (!Pv) memh(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 1     0   1   t    t    t   1   i   i   i   i   0   v    v if (Pv.new) memh(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 1     0   1   t    t    t   1   i   i   i   i   1   v    v if (!Pv.new) memh(#u6)=Nt.new




                           Field name                                                               Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         PredNew                     PredNew
                         Sense                       Sense
                         Parse                       Packet/Loop parse bits
                         s5                          Field to encode register s
                         t3                          Field to encode register t
                         u5                          Field to encode register u
                         v2                          Field to encode register v
                         x5                          Field to encode register x




80-N2040-36 B                                                                     301

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                 302

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Store new-value word
                  Store a 32-bit register in memory at the effective address.

                               Syntax                                           Behavior
                memw(Re=#U6)=Nt.new                     apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Nt.new;
                                                        Re=#U;
                memw(Rs+#s11:2)=Nt.new                  apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Nt.new;
                memw(Rs+Ru<<#u2)=Nt.new                 EA=Rs+(Ru<<#u);
                                                        *EA = Nt.new;
                memw(Ru<<#u2+#U6)=Nt.new                apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Nt.new;
                memw(Rx++#s4:2)=Nt.new                  EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Nt.new;
                memw(Rx++#s4:2:circ(Mu))=Nt.new EA=Rx;
                                                Rx=Rx=circ_add(Rx,#s,MuV);
                                                *EA = Nt.new;
                memw(Rx++I:circ(Mu))=Nt.new             EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                        *EA = Nt.new;
                memw(Rx++Mu)=Nt.new                     EA=Rx;
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new;
                memw(Rx++Mu:brev)=Nt.new                EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new;
                memw(gp+#u16:2)=Nt.new                  apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        *EA = Nt.new;


                  Class: NV (slots 0)

                  Notes

                       ï®   Forms of this instruction which use a new-value operand produced in the packet
                           must execute on slot 0.
                       ï®   This instruction can execute only in slot 0, even though it is an ST instruction.




80-N2040-36 B                                          303

                   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1    0
    ICLASS                                               s5           Parse               u5                                    t3
0   0   1    1   1   0   1   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   -   -   1   0   t   t    t   memw(Rs+Ru<<#u2)=Nt.new
    ICLASS                            Type                            Parse                    t3
0   1   0    0   1   i   i   0    1     0    1   i   i   i    i   i   P   P   i   1   0   t    t    t   i   i   i   i   i   i   i    i   memw(gp+#u16:2)=Nt.new
                                             U
    ICLASS       Amode           Type                    s5           Parse                    t3
                                             N
1   0   1    0   0   i   i   1    1     0    1   s   s   s    s   s   P   P   i   1   0   t    t    t   i   i   i   i   i   i   i    i   memw(Rs+#s11:2)=Nt.new

    ICLASS       Amode           Type        U           x5           Parse u1                 t3
                                             N
1   0   1    0   1   0   0   1    1     0    1   x   x   x    x   x   P   P   u 1     0   t    t    t   0   -   -   -   -   -   1    -   memw(Rx++I:circ(Mu))=Nt.new

1   0   1    0   1   0   0   1    1     0    1   x   x   x    x   x   P   P   u 1     0   t    t    t   0   i   i   i   i   -   0    -   memw(Rx++#s4:2:circ(Mu))=Nt.new
                                             U
    ICLASS       Amode           Type                    e5           Parse                    t3
                                             N
1   0   1    0   1   0   1   1    1     0    1   e   e   e    e   e   P   P 0     1   0   t    t    t   1   -   I   I   I   I   I    I   memw(Re=#U6)=Nt.new
                                             U
    ICLASS       Amode           Type        N           x5           Parse                    t3

1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 0     1   0   t    t    t   0   i   i   i   i   -   0    -   memw(Rx++#s4:2)=Nt.new
                                             U
    ICLASS       Amode           Type                    u5           Parse                    t3
                                             N
1   0   1    0   1   1   0   1    1     0    1   u   u   u    u   u   P   P   i   1   0   t    t    t   1   i   I   I   I   I   I    I   memw(Ru<<#u2+#U6)=Nt.new

    ICLASS       Amode           Type        U           x5           Parse u1                 t3
                                             N
1   0   1    0   1   1   0   1    1     0    1   x   x   x    x   x   P   P   u 1     0   t    t    t   0   -   -   -   -   -   -    -   memw(Rx++Mu)=Nt.new

1   0   1    0   1   1   1   1    1     0    1   x   x   x    x   x   P   P   u 1     0   t    t    t   0   -   -   -   -   -   -    -   memw(Rx++Mu:brev)=Nt.new




                           Field name                                                               Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         Parse                       Packet/Loop parse bits
                         e5                          Field to encode register e
                         s5                          Field to encode register s
                         t3                          Field to encode register t
                         u1                          Field to encode register u
                         u5                          Field to encode register u
                         x5                          Field to encode register x
                         Amode                       Amode
                         Type                        Type
                         UN                          Unsigned




80-N2040-36 B                                                                     304

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Store new-value word conditionally
                Store a 32-bit register in memory at the effective address.

                This instruction is conditional based on a predicate value. If the predicate is true, the
                instruction is performed, otherwise it is treated as a NOP.

                               Syntax                                         Behavior
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memw(#u6)=Nt.new                          apply_extension(#u);
                                                          EA=#u;
                                                          *EA = Nt[.new];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      apply_extension(#u);
                memw(Rs+#u6:2)=Nt.new                 if ([!]Pv[.new][0]) {
                                                          EA=Rs+#u;
                                                          *EA = Nt[.new];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memw(Rs+Ru<<#u2)=Nt.new                   EA=Rs+(Ru<<#u);
                                                          *EA = Nt[.new];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]){
                memw(Rx++#s4:2)=Nt.new                    EA=Rx;
                                                          Rx=Rx+#s;
                                                          *EA = Nt[.new];
                                                      } else {
                                                          NOP;
                                                      };


                Class: NV (slots 0)

                Notes

                     ï®   Forms of this instruction which use a new-value operand produced in the packet
                         must execute on slot 0.
                     ï®   This instruction can execute only in slot 0, even though it is an ST instruction.




80-N2040-36 B                                        305

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1    0
    ICLASS                                               s5           Parse               u5                                    t3
0   0   1    1   0   1   0   0    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 1     0   t   t    t   if (Pv) memw(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   0   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 1     0   t   t    t   if (!Pv) memw(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   1   0    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 1     0   t   t    t   if (Pv.new) memw(Rs+Ru<<#u2)=Nt.new
0   0   1    1   0   1   1   1    1     0    1   s   s   s    s   s   P   P   i   u   u   u    u    u   i   v   v 1     0   t   t    t   if (!Pv.new) memw(Rs+Ru<<#u2)=Nt.new
                        Pr
                     Se
                        ed
    ICLASS           ns Ne            Type               s5           Parse                    t3
                     e w

0   1   0    0   0   0   0   0    1     0    1   s   s   s    s   s   P   P   i   1   0   t    t    t   i   i   i   i   i   0   v    v   if (Pv) memw(Rs+#u6:2)=Nt.new
0   1   0    0   0   0   1   0    1     0    1   s   s   s    s   s   P   P   i   1   0   t    t    t   i   i   i   i   i   0   v    v   if (Pv.new) memw(Rs+#u6:2)=Nt.new
0   1   0    0   0   1   0   0    1     0    1   s   s   s    s   s   P   P   i   1   0   t    t    t   i   i   i   i   i   0   v    v   if (!Pv) memw(Rs+#u6:2)=Nt.new
0   1   0    0   0   1   1   0    1     0    1   s   s   s    s   s   P   P   i   1   0   t    t    t   i   i   i   i   i   0   v    v   if (!Pv.new) memw(Rs+#u6:2)=Nt.new
                                             U
    ICLASS       Amode           Type        N           x5           Parse                    t3

1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     1   0   t    t    t   0   i   i   i   i   0   v    v   if (Pv) memw(Rx++#s4:2)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     1   0   t    t    t   0   i   i   i   i   1   v    v   if (!Pv) memw(Rx++#s4:2)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     1   0   t    t    t   1   i   i   i   i   0   v    v   if (Pv.new) memw(Rx++#s4:2)=Nt.new
1   0   1    0   1   0   1   1    1     0    1   x   x   x    x   x   P   P 1     1   0   t    t    t   1   i   i   i   i   1   v    v   if (!Pv.new) memw(Rx++#s4:2)=Nt.new

                                             U
    ICLASS       Amode           Type        N                        Parse                    t3

1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 0     1   0   t    t    t   1   i   i   i   i   0   v    v  if (Pv) memw(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 0     1   0   t    t    t   1   i   i   i   i   1   v    v  if (!Pv) memw(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 1     1   0   t    t    t   1   i   i   i   i   0   v    v  if (Pv.new) memw(#u6)=Nt.new
1   0   1    0   1   1   1   1    1     0    1   -   -   -    i   i   P   P 1     1   0   t    t    t   1   i   i   i   i   1   v    v  if (!Pv.new) memw(#u6)=Nt.new




                           Field name                                                               Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         PredNew                     PredNew
                         Sense                       Sense
                         Parse                       Packet/Loop parse bits
                         s5                          Field to encode register s
                         t3                          Field to encode register t
                         u5                          Field to encode register u
                         v2                          Field to encode register v
                         x5                          Field to encode register x




80-N2040-36 B                                                                     306

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                 307

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



       11.8 ST
                The ST instruction class includes store instructions, used to store values in memory.

                ST instructions are executable on slot 0 and slot 1.

Store doubleword
                Store a 64-bit register pair in memory at the effective address.

                               Syntax                                       Behavior
                memd(Re=#U6)=Rtt                     apply_extension(#U);
                                                     EA=#U;
                                                     *EA = Rtt;
                                                     Re=#U;
                memd(Rs+#s11:3)=Rtt                  apply_extension(#s);
                                                     EA=Rs+#s;
                                                     *EA = Rtt;
                memd(Rs+Ru<<#u2)=Rtt                 EA=Rs+(Ru<<#u);
                                                     *EA = Rtt;
                memd(Ru<<#u2+#U6)=Rtt                apply_extension(#U);
                                                     EA=#U+(Ru<<#u);
                                                     *EA = Rtt;
                memd(Rx++#s4:3)=Rtt                  EA=Rx;
                                                     Rx=Rx+#s;
                                                     *EA = Rtt;
                memd(Rx++#s4:3:circ(Mu))=Rtt EA=Rx;
                                             Rx=Rx=circ_add(Rx,#s,MuV);
                                             *EA = Rtt;
                memd(Rx++I:circ(Mu))=Rtt             EA=Rx;
                                                     Rx=Rx=circ_add(Rx,I<<3,MuV);
                                                     *EA = Rtt;
                memd(Rx++Mu)=Rtt                     EA=Rx;
                                                     Rx=Rx+MuV;
                                                     *EA = Rtt;
                memd(Rx++Mu:brev)=Rtt                EA=Rx.h[1] | brev(Rx.h[0]);
                                                     Rx=Rx+MuV;
                                                     *EA = Rtt;
                memd(gp+#u16:3)=Rtt                  apply_extension(#u);
                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                     *EA = Rtt;




80-N2040-36 B                                       308

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2    1   0
    ICLASS                                               s5           Parse                 u5                               t5
0   0   1    1   1   0   1   1    1     1    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   -   -   t   t   t    t   t   memd(Rs+Ru<<#u2)=Rtt
    ICLASS                            Type                            Parse                 t5
0   1   0    0   1   i   i   0    1     1    0   i   i   i    i   i   P   P   i   t     t   t    t   t   i   i   i   i   i   i    i   i   memd(gp+#u16:3)=Rtt
                                             U
    ICLASS       Amode           Type                    s5           Parse                 t5
                                             N
1   0   1    0   0   i   i   1    1     1    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   i    i   i   memd(Rs+#s11:3)=Rtt
                                             U
    ICLASS       Amode           Type                    x5           Parse u1              t5
                                             N
1   0   1    0   1   0   0   1    1     1    0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -    1   -   memd(Rx++I:circ(Mu))=Rtt
1   0   1    0   1   0   0   1    1     1    0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   i   i   i   i   -    0   -   memd(Rx++#s4:3:circ(Mu))=Rtt
                                             U
    ICLASS       Amode           Type                    e5           Parse                 t5
                                             N
1   0   1    0   1   0   1   1    1     1    0   e   e   e    e   e   P   P 0     t     t   t    t   t   1   -   I   I   I   I    I   I   memd(Re=#U6)=Rtt
                                             U
    ICLASS       Amode           Type        N
                                                         x5           Parse                 t5

1   0   1    0   1   0   1   1    1     1    0   x   x   x    x   x   P   P 0     t     t   t    t   t   0   i   i   i   i   -    0   -   memd(Rx++#s4:3)=Rtt
                                             U
    ICLASS       Amode           Type        N           u5           Parse                 t5

1   0   1    0   1   1   0   1    1     1    0   u   u   u    u   u   P   P   i   t     t   t    t   t   1   i   I   I   I   I    I   I   memd(Ru<<#u2+#U6)=Rtt
                                             U
    ICLASS       Amode           Type        N           x5           Parse u1              t5

1   0   1    0   1   1   0   1    1     1    0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -    -   -   memd(Rx++Mu)=Rtt
1   0   1    0   1   1   1   1    1     1    0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -    -   -   memd(Rx++Mu:brev)=Rtt




                           Field name                                                                Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         Parse                       Packet/Loop parse bits
                         e5                          Field to encode register e
                         s5                          Field to encode register s
                         t5                          Field to encode register t
                         u1                          Field to encode register u
                         u5                          Field to encode register u
                         x5                          Field to encode register x
                         Amode                       Amode
                         Type                        Type
                         UN                          Unsigned




80-N2040-36 B                                                                     309

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



Store doubleword conditionally
                         Store a 64-bit register pair in memory at the effective address.

                         This instruction is conditional based on a predicate value. If the predicate is true, the
                         instruction is performed, otherwise it is treated as a NOP.

                                                Syntax                                                                  Behavior
                         if ([!]Pv[.new])                                            if ([!]Pv[.new][0]) {
                         memd(#u6)=Rtt                                                   apply_extension(#u);
                                                                                         EA=#u;
                                                                                         *EA = Rtt;
                                                                                     } else {
                                                                                         NOP;
                                                                                     };
                         if ([!]Pv[.new])                                            apply_extension(#u);
                         memd(Rs+#u6:3)=Rtt                                          if ([!]Pv[.new][0]) {
                                                                                         EA=Rs+#u;
                                                                                         *EA = Rtt;
                                                                                     } else {
                                                                                         NOP;
                                                                                     };
                         if ([!]Pv[.new])                                            if ([!]Pv[.new][0]) {
                         memd(Rs+Ru<<#u2)=Rtt                                            EA=Rs+(Ru<<#u);
                                                                                         *EA = Rtt;
                                                                                     } else {
                                                                                         NOP;
                                                                                     };
                         if ([!]Pv[.new])                                            if ([!]Pv[.new][0]){
                         memd(Rx++#s4:3)=Rtt                                             EA=Rx;
                                                                                         Rx=Rx+#s;
                                                                                         *EA = Rtt;
                                                                                     } else {
                                                                                         NOP;
                                                                                     };


                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3    2    1   0
    ICLASS                                              s5           Parse                 u5                                t5
0   0   1    1   0   1   0   0   1    1     0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   v   v   t    t   t    t   t   if (Pv) memd(Rs+Ru<<#u2)=Rtt
0   0   1    1   0   1   0   1   1    1     0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   v   v   t    t   t    t   t   if (!Pv) memd(Rs+Ru<<#u2)=Rtt
0   0   1    1   0   1   1   0   1    1     0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   v   v   t    t   t    t   t   if (Pv.new) memd(Rs+Ru<<#u2)=Rtt
0   0   1    1   0   1   1   1   1    1     0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   v   v   t    t   t    t   t   if (!Pv.new) memd(Rs+Ru<<#u2)=Rtt
                        Pr
                     Se ed
    ICLASS           ns Ne           Type               s5           Parse                 t5
                     e w

0   1   0    0   0   0   0   0   1    1     0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i    i   0    v   v   if (Pv) memd(Rs+#u6:3)=Rtt




80-N2040-36 B                                                                    310

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1   0
0   1   0    0   0   0   1   0    1     1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (Pv.new) memd(Rs+#u6:3)=Rtt
0   1   0    0   0   1   0   0    1     1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (!Pv) memd(Rs+#u6:3)=Rtt
0   1   0    0   0   1   1   0    1     1   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (!Pv.new) memd(Rs+#u6:3)=Rtt
                                            U
    ICLASS       Amode           Type       N           x5           Parse                 t5

1   0   1    0   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   0   v   v   if (Pv) memd(Rx++#s4:3)=Rtt
1   0   1    0   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   1   v   v   if (!Pv) memd(Rx++#s4:3)=Rtt
1   0   1    0   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   0   v   v   if (Pv.new) memd(Rx++#s4:3)=Rtt
1   0   1    0   1   0   1   1    1     1   0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   1   v   v   if (!Pv.new) memd(Rx++#s4:3)=Rtt
                                            U
    ICLASS       Amode           Type                                Parse                 t5
                                            N
1   0   1    0   1   1   1   1    1     1   0   -   -   -    i   i   P   P 0     t     t   t    t   t   1   i   i   i   i   0   v   v if (Pv) memd(#u6)=Rtt
1   0   1    0   1   1   1   1    1     1   0   -   -   -    i   i   P   P 0     t     t   t    t   t   1   i   i   i   i   1   v   v if (!Pv) memd(#u6)=Rtt
1   0   1    0   1   1   1   1    1     1   0   -   -   -    i   i   P   P 1     t     t   t    t   t   1   i   i   i   i   0   v   v if (Pv.new) memd(#u6)=Rtt
1   0   1    0   1   1   1   1    1     1   0   -   -   -    i   i   P   P 1     t     t   t    t   t   1   i   i   i   i   1   v   v if (!Pv.new) memd(#u6)=Rtt




                           Field name                                                               Description
                         ICLASS                     Instruction Class
                         Type                       Type
                         PredNew                    PredNew
                         Sense                      Sense
                         Parse                      Packet/Loop parse bits
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u5                         Field to encode register u
                         v2                         Field to encode register v
                         x5                         Field to encode register x
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    311

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Store byte
                         Store the least-significant byte in a source register at the effective address.

                                                Syntax                                                                  Behavior
                         memb(Re=#U6)=Rt                                             apply_extension(#U);
                                                                                     EA=#U;
                                                                                     *EA = Rt&0xff;
                                                                                     Re=#U;
                         memb(Rs+#s11:0)=Rt                                          apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     *EA = Rt&0xff;
                         memb(Rs+#u6:0)=#S8                                          EA=Rs+#u;
                                                                                     apply_extension(#S);
                                                                                     *EA = #S;
                         memb(Rs+Ru<<#u2)=Rt                                         EA=Rs+(Ru<<#u);
                                                                                     *EA = Rt&0xff;
                         memb(Ru<<#u2+#U6)=Rt                                        apply_extension(#U);
                                                                                     EA=#U+(Ru<<#u);
                                                                                     *EA = Rt&0xff;
                         memb(Rx++#s4:0)=Rt                                          EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     *EA = Rt&0xff;
                         memb(Rx++#s4:0:circ(Mu))=Rt                                 EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,#s,MuV);
                                                                                     *EA = Rt&0xff;
                         memb(Rx++I:circ(Mu))=Rt                                     EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                                                     *EA = Rt&0xff;
                         memb(Rx++Mu)=Rt                                             EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     *EA = Rt&0xff;
                         memb(Rx++Mu:brev)=Rt                                        EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     *EA = Rt&0xff;
                         memb(gp+#u16:0)=Rt                                          apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     *EA = Rt&0xff;


                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3    2    1   0
    ICLASS                                              s5           Parse                 u5                                t5
0   0   1    1   1   0   1   1   0    0     0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   -   -   t    t   t    t   t   memb(Rs+Ru<<#u2)=Rt
    ICLASS                                              s5           Parse
0   0   1    1   1   1   0   -   -    0     0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   I   I   I    I   I    I   I   memb(Rs+#u6:0)=#S8
    ICLASS                           Type                            Parse                 t5




80-N2040-36 B                                                                    312

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1   0
0   1   0    0   1   i   i   0    0     0   0   i   i   i    i   i   P   P   i   t     t   t    t   t   i   i   i   i   i   i   i   i   memb(gp+#u16:0)=Rt
                                            U
    ICLASS       Amode           Type                   s5           Parse                 t5
                                            N
1   0   1    0   0   i   i   1    0     0   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   i   i   i   memb(Rs+#s11:0)=Rt

    ICLASS       Amode           Type       U           x5           Parse u1              t5
                                            N
1   0   1    0   1   0   0   1    0     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   1   -   memb(Rx++I:circ(Mu))=Rt
1   0   1    0   1   0   0   1    0     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   i   i   i   i   -   0   -   memb(Rx++#s4:0:circ(Mu))=Rt

    ICLASS       Amode           Type       U           e5           Parse                 t5
                                            N
1   0   1    0   1   0   1   1    0     0   0   e   e   e    e   e   P   P 0     t     t   t    t   t   1   -   I   I   I   I   I   I   memb(Re=#U6)=Rt
                                            U
    ICLASS       Amode           Type                   x5           Parse                 t5
                                            N
1   0   1    0   1   0   1   1    0     0   0   x   x   x    x   x   P   P 0     t     t   t    t   t   0   i   i   i   i   -   0   -   memb(Rx++#s4:0)=Rt
                                            U
    ICLASS       Amode           Type                   u5           Parse                 t5
                                            N
1   0   1    0   1   1   0   1    0     0   0   u   u   u    u   u   P   P   i   t     t   t    t   t   1   i   I   I   I   I   I   I   memb(Ru<<#u2+#U6)=Rt
                                            U
    ICLASS       Amode           Type                   x5           Parse u1              t5
                                            N
1   0   1    0   1   1   0   1    0     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memb(Rx++Mu)=Rt
1   0   1    0   1   1   1   1    0     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memb(Rx++Mu:brev)=Rt




                           Field name                                                               Description
                         ICLASS                     Instruction Class
                         Type                       Type
                         Parse                      Packet/Loop parse bits
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         u5                         Field to encode register u
                         x5                         Field to encode register x
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    313

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Store byte conditionally
                Store the least-significant byte in a source register at the effective address.

                This instruction is conditional based on a predicate value. If the predicate is true, the
                instruction is performed, otherwise it is treated as a NOP.

                               Syntax                                         Behavior
                if ([!]Pv[.new])                       if ([!]Pv[.new][0]) {
                memb(#u6)=Rt                               apply_extension(#u);
                                                           EA=#u;
                                                           *EA = Rt&0xff;
                                                       } else {
                                                           NOP;
                                                       };
                if ([!]Pv[.new])                       if ([!]Pv[.new][0]){
                memb(Rs+#u6:0)=#S6                         EA=Rs+#u;
                                                           apply_extension(#S);
                                                           *EA = #S;
                                                       } else {
                                                           NOP;
                                                       };
                if ([!]Pv[.new])                       apply_extension(#u);
                memb(Rs+#u6:0)=Rt                      if ([!]Pv[.new][0]) {
                                                           EA=Rs+#u;
                                                           *EA = Rt&0xff;
                                                       } else {
                                                           NOP;
                                                       };
                if ([!]Pv[.new])                       if ([!]Pv[.new][0]) {
                memb(Rs+Ru<<#u2)=Rt                        EA=Rs+(Ru<<#u);
                                                           *EA = Rt&0xff;
                                                       } else {
                                                           NOP;
                                                       };
                if ([!]Pv[.new])                       if ([!]Pv[.new][0]){
                memb(Rx++#s4:0)=Rt                         EA=Rx;
                                                           Rx=Rx+#s;
                                                           *EA = Rt&0xff;
                                                       } else {
                                                           NOP;
                                                       };




80-N2040-36 B                                        314

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2    1   0
    ICLASS                                               s5           Parse                 u5                               t5
0   0   1    1   0   1   0   0    0     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (Pv) memb(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   0   1    0     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (!Pv) memb(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   1   0    0     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (Pv.new) memb(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   1   1    0     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (!Pv.new) memb(Rs+Ru<<#u2)=Rt
    ICLASS                                               s5           Parse
0   0   1    1   1   0   0   0    0     0    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (Pv) memb(Rs+#u6:0)=#S6
0   0   1    1   1   0   0   0    1     0    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (!Pv) memb(Rs+#u6:0)=#S6

0   0   1    1   1   0   0   1    0     0    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if  (Pv.new) memb(Rs+#u6:0)=#S6
0   0   1    1   1   0   0   1    1     0    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (!Pv.new) memb(Rs+#u6:0)=#S6
                        Pr
                     Se ed
    ICLASS           ns Ne            Type               s5           Parse                 t5
                     e w

0   1   0    0   0   0   0   0    0     0    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0    v   v  if (Pv) memb(Rs+#u6:0)=Rt
0   1   0    0   0   0   1   0    0     0    0   s   s   s    s   s   P   P   i   t     t   t    t  t   i   i   i   i   i   0    v   v   if (Pv.new) memb(Rs+#u6:0)=Rt
0   1   0    0   0   1   0   0    0     0    0   s   s   s    s   s   P   P   i   t     t   t    t  t   i   i   i   i   i   0    v   v   if (!Pv) memb(Rs+#u6:0)=Rt
0   1   0    0   0   1   1   0    0     0    0   s   s   s    s   s   P   P   i   t     t   t    t  t   i   i   i   i   i   0    v   v   if (!Pv.new) memb(Rs+#u6:0)=Rt
                                             U
    ICLASS       Amode           Type        N           x5           Parse                 t5

1   0   1    0   1   0   1   1    0     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   0    v   v   if (Pv) memb(Rx++#s4:0)=Rt
1   0   1    0   1   0   1   1    0     0    0   x   x   x    x   x   P   P 1     t     t   t    t  t   0   i   i   i   i   1    v   v    if (!Pv) memb(Rx++#s4:0)=Rt
1   0   1    0   1   0   1   1    0     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   0    v   v   if (Pv.new) memb(Rx++#s4:0)=Rt
1   0   1    0   1   0   1   1    0     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   1    v   v   if (!Pv.new) memb(Rx++#s4:0)=Rt
                                             U
    ICLASS       Amode           Type        N                        Parse                 t5

1   0   1    0   1   1   1   1    0     0    0   -   -   -    i   i   P   P 0     t     t   t    t   t   1   i   i   i   i   0    v   v if (Pv) memb(#u6)=Rt
1   0   1    0   1   1   1   1    0     0    0   -   -   -    i   i   P   P 0     t     t   t    t   t   1   i   i   i   i   1    v   v if (!Pv) memb(#u6)=Rt
1   0   1    0   1   1   1   1    0     0    0   -   -   -    i   i   P   P 1     t     t   t    t   t   1   i   i   i   i   0    v   v if (Pv.new) memb(#u6)=Rt
1   0   1    0   1   1   1   1    0     0    0   -   -   -    i   i   P   P 1     t     t   t    t   t   1   i   i   i   i   1    v   v if (!Pv.new) memb(#u6)=Rt




                           Field name                                                                Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         PredNew                     PredNew
                         Sense                       Sense
                         Parse                       Packet/Loop parse bits




80-N2040-36 B                                                                     315

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                s5             Field to encode register s
                t5             Field to encode register t
                u5             Field to encode register u
                v2             Field to encode register v
                x5             Field to encode register x
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                       316

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Store halfword
                Store the upper or lower 16-bits of a source register at the effective address.

                              Syntax                                         Behavior
                memh(Re=#U6)=Rt.H                     apply_extension(#U);
                                                      EA=#U;
                                                      *EA = Rt.h[1];
                                                      Re=#U;
                memh(Re=#U6)=Rt                       apply_extension(#U);
                                                      EA=#U;
                                                      *EA = Rt.h[0];
                                                      Re=#U;
                memh(Rs+#s11:1)=Rt.H                  apply_extension(#s);
                                                      EA=Rs+#s;
                                                      *EA = Rt.h[1];
                memh(Rs+#s11:1)=Rt                    apply_extension(#s);
                                                      EA=Rs+#s;
                                                      *EA = Rt.h[0];
                memh(Rs+#u6:1)=#S8                    EA=Rs+#u;
                                                      apply_extension(#S);
                                                      *EA = #S;
                memh(Rs+Ru<<#u2)=Rt.H                 EA=Rs+(Ru<<#u);
                                                      *EA = Rt.h[1];
                memh(Rs+Ru<<#u2)=Rt                   EA=Rs+(Ru<<#u);
                                                      *EA = Rt.h[0];
                memh(Ru<<#u2+#U6)=Rt.H                apply_extension(#U);
                                                      EA=#U+(Ru<<#u);
                                                      *EA = Rt.h[1];
                memh(Ru<<#u2+#U6)=Rt                  apply_extension(#U);
                                                      EA=#U+(Ru<<#u);
                                                      *EA = Rt.h[0];
                memh(Rx++#s4:1)=Rt.H                  EA=Rx;
                                                      Rx=Rx+#s;
                                                      *EA = Rt.h[1];
                memh(Rx++#s4:1)=Rt                    EA=Rx;
                                                      Rx=Rx+#s;
                                                      *EA = Rt.h[0];
                memh(Rx++#s4:1:circ(Mu))=Rt.H EA=Rx;
                                              Rx=Rx=circ_add(Rx,#s,MuV);
                                              *EA = Rt.h[1];
                memh(Rx++#s4:1:circ(Mu))=Rt           EA=Rx;
                                                      Rx=Rx=circ_add(Rx,#s,MuV);
                                                      *EA = Rt.h[0];
                memh(Rx++I:circ(Mu))=Rt.H             EA=Rx;
                                                      Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                      *EA = Rt.h[1];
                memh(Rx++I:circ(Mu))=Rt               EA=Rx;
                                                      Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                      *EA = Rt.h[0];




80-N2040-36 B                                       317

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                                                 Syntax                                                                  Behavior
                         memh(Rx++Mu)=Rt.H                                            EA=Rx;
                                                                                      Rx=Rx+MuV;
                                                                                      *EA = Rt.h[1];
                         memh(Rx++Mu)=Rt                                              EA=Rx;
                                                                                      Rx=Rx+MuV;
                                                                                      *EA = Rt.h[0];
                         memh(Rx++Mu:brev)=Rt.H                                       EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                      Rx=Rx+MuV;
                                                                                      *EA = Rt.h[1];
                         memh(Rx++Mu:brev)=Rt                                         EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                      Rx=Rx+MuV;
                                                                                      *EA = Rt.h[0];
                         memh(gp+#u16:1)=Rt.H                                         apply_extension(#u);
                                                                                      EA=(Constant_extended ? (0) : GP)+#u;
                                                                                      *EA = Rt.h[1];
                         memh(gp+#u16:1)=Rt                                           apply_extension(#u);
                                                                                      EA=(Constant_extended ? (0) : GP)+#u;
                                                                                      *EA = Rt.h[0];


                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3    2    1   0
    ICLASS                                               s5           Parse                 u5                                t5
0   0   1    1   1   0   1   1    0     1    0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   -   -   t    t   t    t   t   memh(Rs+Ru<<#u2)=Rt
0   0   1    1   1   0   1   1    0     1    1   s   s   s    s   s   P   P   i   u    u    u    u   u   i   -   -   t    t   t    t   t   memh(Rs+Ru<<#u2)=Rt.H
    ICLASS                                               s5           Parse
0   0   1    1   1   1   0   -    -     0    1   s   s   s    s   s   P   P   I   i     i   i    i   i   i   I   I   I    I   I    I   I   memh(Rs+#u6:1)=#S8
    ICLASS                            Type                            Parse                 t5
0   1   0    0   1   i   i   0    0     1    0   i   i   i    i   i   P   P   i   t     t   t    t   t   i   i   i   i    i   i    i   i   memh(gp+#u16:1)=Rt
0   1   0    0   1   i   i   0    0     1    1   i   i   i    i   i   P   P   i   t     t   t    t   t   i   i   i   i    i   i    i   i   memh(gp+#u16:1)=Rt.H
                                             U
    ICLASS       Amode           Type                    s5           Parse                 t5
                                             N
1   0   1    0   0   i   i   1    0     1    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i    i   i    i   i   memh(Rs+#s11:1)=Rt
1   0   1    0   0   i   i   1    0     1    1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i    i   i    i   i   memh(Rs+#s11:1)=Rt.H
                                             U
    ICLASS       Amode           Type        N           x5           Parse u1              t5

1   0   1    0   1   0   0   1    0     1    0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -    -   -    1   -   memh(Rx++I:circ(Mu))=Rt
1   0   1    0   1   0   0   1    0     1    0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   i   i   i    i   -    0   -   memh(Rx++#s4:1:circ(Mu))=Rt
1   0   1    0   1   0   0   1    0     1    1   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -    -   -    1   -   memh(Rx++I:circ(Mu))=Rt.H
1   0   1    0   1   0   0   1    0     1    1   x   x   x    x   x   P   P   u   t     t   t    t   t   0   i   i   i    i   -    0   -   memh(Rx++#s4:1:circ(Mu))=Rt.H
                                             U
    ICLASS       Amode           Type        N           e5           Parse                 t5

1   0   1    0   1   0   1   1    0     1    0   e   e   e    e   e   P   P 0     t     t   t    t   t   1   -   I   I    I   I    I   I   memh(Re=#U6)=Rt
                                             U
    ICLASS       Amode           Type        N           x5           Parse                 t5

1   0   1    0   1   0   1   1    0     1    0   x   x   x    x   x   P   P 0     t     t   t    t   t   0   i   i   i    i   -    0   -   memh(Rx++#s4:1)=Rt




80-N2040-36 B                                                                     318

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1   0
                                            U
    ICLASS       Amode           Type                   e5           Parse                 t5
                                            N
1   0   1    0   1   0   1   1    0     1   1   e   e   e    e   e   P   P 0     t     t   t    t   t   1   -   I   I   I   I   I   I   memh(Re=#U6)=Rt.H
                                            U
    ICLASS       Amode           Type                   x5           Parse                 t5
                                            N
1   0   1    0   1   0   1   1    0     1   1   x   x   x    x   x   P   P 0     t     t   t    t   t   0   i   i   i   i   -   0   -   memh(Rx++#s4:1)=Rt.H

    ICLASS       Amode           Type       U           u5           Parse                 t5
                                            N
1   0   1    0   1   1   0   1    0     1   0   u   u   u    u   u   P   P   i   t     t   t    t   t   1   i   I   I   I   I   I   I   memh(Ru<<#u2+#U6)=Rt
                                            U
    ICLASS       Amode           Type       N           x5           Parse u1              t5

1   0   1    0   1   1   0   1    0     1   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memh(Rx++Mu)=Rt
                                            U
    ICLASS       Amode           Type                   u5           Parse                 t5
                                            N
1   0   1    0   1   1   0   1    0     1   1   u   u   u    u   u   P   P   i   t     t   t    t   t   1   i   I   I   I   I   I   I   memh(Ru<<#u2+#U6)=Rt.H
                                            U
    ICLASS       Amode           Type                   x5           Parse u1              t5
                                            N
1   0   1    0   1   1   0   1    0     1   1   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memh(Rx++Mu)=Rt.H
1   0   1    0   1   1   1   1    0     1   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memh(Rx++Mu:brev)=Rt
1   0   1    0   1   1   1   1    0     1   1   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memh(Rx++Mu:brev)=Rt.H




                           Field name                                                               Description
                         ICLASS                     Instruction Class
                         Type                       Type
                         Parse                      Packet/Loop parse bits
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         u5                         Field to encode register u
                         x5                         Field to encode register x
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    319

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Store halfword conditionally
                Store the upper or lower 16-bits of a source register in memory at the effective address.

                This instruction is conditional based on a predicate value. If the predicate is true, the
                instruction is performed, otherwise it is treated as a NOP.

                               Syntax                                        Behavior
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memh(#u6)=Rt.H                            apply_extension(#u);
                                                          EA=#u;
                                                          *EA = Rt.h[1];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memh(#u6)=Rt                              apply_extension(#u);
                                                          EA=#u;
                                                          *EA = Rt.h[0];
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]){
                memh(Rs+#u6:1)=#S6                        EA=Rs+#u;
                                                          apply_extension(#S);
                                                          *EA = #S;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      apply_extension(#u);
                memh(Rs+#u6:1)=Rt.H                   if ([!]Pv[.new][0]) {
                                                          EA=Rs+#u;
                                                          *EA = Rt.h[1];
                                                      } else {
                                                          NOP;
                                                      };




80-N2040-36 B                                        320

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                                             Syntax                                                                 Behavior
                         if ([!]Pv[.new])                                         apply_extension(#u);
                         memh(Rs+#u6:1)=Rt                                        if ([!]Pv[.new][0]) {
                                                                                      EA=Rs+#u;
                                                                                      *EA = Rt.h[0];
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]) {
                         memh(Rs+Ru<<#u2)=Rt.H                                        EA=Rs+(Ru<<#u);
                                                                                      *EA = Rt.h[1];
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]) {
                         memh(Rs+Ru<<#u2)=Rt                                          EA=Rs+(Ru<<#u);
                                                                                      *EA = Rt.h[0];
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]){
                         memh(Rx++#s4:1)=Rt.H                                         EA=Rx;
                                                                                      Rx=Rx+#s;
                                                                                      *EA = Rt.h[1];
                                                                                  } else {
                                                                                      NOP;
                                                                                  };
                         if ([!]Pv[.new])                                         if ([!]Pv[.new][0]){
                         memh(Rx++#s4:1)=Rt                                           EA=Rx;
                                                                                      Rx=Rx+#s;
                                                                                      *EA = Rt.h[0];
                                                                                  } else {
                                                                                      NOP;
                                                                                  };


                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2    1   0
    ICLASS                                           s5           Parse                u5                                t5

0   0   1    1   0   1   0   0   0   1   0   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (Pv) memh(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   0   0   0   1   1   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (Pv) memh(Rs+Ru<<#u2)=Rt.H
0   0   1    1   0   1   0   1   0   1   0   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (!Pv) memh(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   0   1   0   1   1   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (!Pv) memh(Rs+Ru<<#u2)=Rt.H
0   0   1    1   0   1   1   0   0   1   0   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (Pv.new) memh(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   1   0   0   1   1   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (Pv.new) memh(Rs+Ru<<#u2)=Rt.H
0   0   1    1   0   1   1   1   0   1   0   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (!Pv.new) memh(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   1   1   0   1   1   s   s   s    s   s   P   P   i   u    u   u    u   u   i   v   v   t    t   t    t   t   if (!Pv.new) memh(Rs+Ru<<#u2)=Rt.H




80-N2040-36 B                                                                 321

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2   1   0
    ICLASS                                               s5           Parse
0   0   1    1   1   0   0   0    0     0    1   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I   I   I   if (Pv) memh(Rs+#u6:1)=#S6
0   0   1    1   1   0   0   0    1     0    1   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I   I   I   if (!Pv) memh(Rs+#u6:1)=#S6
0   0   1    1   1   0   0   1    0     0    1   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I   I   I   if (Pv.new) memh(Rs+#u6:1)=#S6
0   0   1    1   1   0   0   1    1     0    1   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I   I   I   if (!Pv.new) memh(Rs+#u6:1)=#S6
                        Pr
                     Se ed
    ICLASS           ns               Type               s5           Parse                 t5
                        Ne
                      e
                        w
0   1   0    0   0   0   0   0    0     1    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (Pv) memh(Rs+#u6:1)=Rt
0   1   0    0   0   0   0   0    0     1    1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (Pv) memh(Rs+#u6:1)=Rt.H
0   1   0    0   0   0   1   0    0     1    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (Pv.new) memh(Rs+#u6:1)=Rt
0   1   0    0   0   0   1   0    0     1    1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (Pv.new) memh(Rs+#u6:1)=Rt.H
0   1   0    0   0   1   0   0    0     1    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (!Pv) memh(Rs+#u6:1)=Rt
0   1   0    0   0   1   0   0    0     1    1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (!Pv) memh(Rs+#u6:1)=Rt.H
0   1   0    0   0   1   1   0    0     1    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (!Pv.new) memh(Rs+#u6:1)=Rt
0   1   0    0   0   1   1   0    0     1    1   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0   v   v   if (!Pv.new) memh(Rs+#u6:1)=Rt.H
                                             U
    ICLASS       Amode           Type        N
                                                         x5           Parse                 t5

1   0   1    0   1   0   1   1    0     1    0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   0   v   v   if (Pv) memh(Rx++#s4:1)=Rt
1   0   1    0   1   0   1   1    0     1    0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   1   v   v   if (!Pv) memh(Rx++#s4:1)=Rt
1   0   1    0   1   0   1   1    0     1    0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   0   v   v   if (Pv.new) memh(Rx++#s4:1)=Rt
1   0   1    0   1   0   1   1    0     1    0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   1   v   v   if (!Pv.new) memh(Rx++#s4:1)=Rt
1   0   1    0   1   0   1   1    0     1    1   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   0   v   v   if (Pv) memh(Rx++#s4:1)=Rt.H
1   0   1    0   1   0   1   1    0     1    1   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   1   v   v   if (!Pv) memh(Rx++#s4:1)=Rt.H
1   0   1    0   1   0   1   1    0     1    1   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   0   v   v   if (Pv.new) memh(Rx++#s4:1)=Rt.H
1   0   1    0   1   0   1   1    0     1    1   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   1   v   v   if (!Pv.new) memh(Rx++#s4:1)=Rt.H
                                             U
    ICLASS       Amode           Type                                 Parse                 t5
                                             N
1   0   1    0   1   1   1   1    0     1    0   -   -   -    i   i   P   P 0     t   t     t    t   t   1   i   i   i   i   0   v   v   if (Pv) memh(#u6)=Rt
1   0   1    0   1   1   1   1    0     1    0   -   -   -    i   i   P   P 0     t   t     t    t   t   1   i   i   i   i   1   v   v   if (!Pv) memh(#u6)=Rt
1   0   1    0   1   1   1   1    0     1    0   -   -   -    i   i   P   P 1     t   t     t    t   t   1   i   i   i   i   0   v   v   if (Pv.new) memh(#u6)=Rt
1   0   1    0   1   1   1   1    0     1    0   -   -   -    i   i   P   P 1     t   t     t    t   t   1   i   i   i   i   1   v   v   if (!Pv.new) memh(#u6)=Rt
1   0   1    0   1   1   1   1    0     1    1   -   -   -    i   i   P   P 0     t   t     t    t   t   1   i   i   i   i   0   v   v   if (Pv) memh(#u6)=Rt.H
1   0   1    0   1   1   1   1    0     1    1   -   -   -    i   i   P   P 0     t   t     t    t   t   1   i   i   i   i   1   v   v   if (!Pv) memh(#u6)=Rt.H
1   0   1    0   1   1   1   1    0     1    1   -   -   -    i   i   P   P 1     t   t     t    t   t   1   i   i   i   i   0   v   v   if (Pv.new) memh(#u6)=Rt.H
1   0   1    0   1   1   1   1    0     1    1   -   -   -    i   i   P   P 1     t   t     t    t   t   1   i   i   i   i   1   v   v   if (!Pv.new) memh(#u6)=Rt.H



80-N2040-36 B                                                                     322

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Type           Type
                PredNew        PredNew
                Sense          Sense
                Parse          Packet/Loop parse bits
                s5             Field to encode register s
                t5             Field to encode register t
                u5             Field to encode register u
                v2             Field to encode register v
                x5             Field to encode register x
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                       323

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Store word
                         Store a 32-bit register in memory at the effective address.

                                                Syntax                                                                  Behavior
                         memw(Re=#U6)=Rt                                             apply_extension(#U);
                                                                                     EA=#U;
                                                                                     *EA = Rt;
                                                                                     Re=#U;
                         memw(Rs+#s11:2)=Rt                                          apply_extension(#s);
                                                                                     EA=Rs+#s;
                                                                                     *EA = Rt;
                         memw(Rs+#u6:2)=#S8                                          EA=Rs+#u;
                                                                                     apply_extension(#S);
                                                                                     *EA = #S;
                         memw(Rs+Ru<<#u2)=Rt                                         EA=Rs+(Ru<<#u);
                                                                                     *EA = Rt;
                         memw(Ru<<#u2+#U6)=Rt                                        apply_extension(#U);
                                                                                     EA=#U+(Ru<<#u);
                                                                                     *EA = Rt;
                         memw(Rx++#s4:2)=Rt                                          EA=Rx;
                                                                                     Rx=Rx+#s;
                                                                                     *EA = Rt;
                         memw(Rx++#s4:2:circ(Mu))=Rt                                 EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,#s,MuV);
                                                                                     *EA = Rt;
                         memw(Rx++I:circ(Mu))=Rt                                     EA=Rx;
                                                                                     Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                                                     *EA = Rt;
                         memw(Rx++Mu)=Rt                                             EA=Rx;
                                                                                     Rx=Rx+MuV;
                                                                                     *EA = Rt;
                         memw(Rx++Mu:brev)=Rt                                        EA=Rx.h[1] | brev(Rx.h[0]);
                                                                                     Rx=Rx+MuV;
                                                                                     *EA = Rt;
                         memw(gp+#u16:2)=Rt                                          apply_extension(#u);
                                                                                     EA=(Constant_extended ? (0) : GP)+#u;
                                                                                     *EA = Rt;


                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3    2    1   0
    ICLASS                                              s5           Parse                 u5                                t5
0   0   1    1   1   0   1   1   1    0     0   s   s   s    s   s   P   P   i   u    u    u    u   u   i   -   -   t    t   t    t   t   memw(Rs+Ru<<#u2)=Rt
    ICLASS                                              s5           Parse
0   0   1    1   1   1   0   -   -    1     0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   I   I   I    I   I    I   I   memw(Rs+#u6:2)=#S8
    ICLASS                           Type                            Parse                 t5




80-N2040-36 B                                                                    324

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2   1   0
0   1   0    0   1   i   i   0    1     0   0   i   i   i    i   i   P   P   i   t     t   t    t   t   i   i   i   i   i   i   i   i   memw(gp+#u16:2)=Rt
                                            U
    ICLASS       Amode           Type                   s5           Parse                 t5
                                            N
1   0   1    0   0   i   i   1    1     0   0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   i   i   i   memw(Rs+#s11:2)=Rt

    ICLASS       Amode           Type       U           x5           Parse u1              t5
                                            N
1   0   1    0   1   0   0   1    1     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   1   -   memw(Rx++I:circ(Mu))=Rt
1   0   1    0   1   0   0   1    1     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   i   i   i   i   -   0   -   memw(Rx++#s4:2:circ(Mu))=Rt

    ICLASS       Amode           Type       U           e5           Parse                 t5
                                            N
1   0   1    0   1   0   1   1    1     0   0   e   e   e    e   e   P   P 0     t     t   t    t   t   1   -   I   I   I   I   I   I   memw(Re=#U6)=Rt
                                            U
    ICLASS       Amode           Type                   x5           Parse                 t5
                                            N
1   0   1    0   1   0   1   1    1     0   0   x   x   x    x   x   P   P 0     t     t   t    t   t   0   i   i   i   i   -   0   -   memw(Rx++#s4:2)=Rt
                                            U
    ICLASS       Amode           Type                   u5           Parse                 t5
                                            N
1   0   1    0   1   1   0   1    1     0   0   u   u   u    u   u   P   P   i   t     t   t    t   t   1   i   I   I   I   I   I   I   memw(Ru<<#u2+#U6)=Rt
                                            U
    ICLASS       Amode           Type                   x5           Parse u1              t5
                                            N
1   0   1    0   1   1   0   1    1     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memw(Rx++Mu)=Rt
1   0   1    0   1   1   1   1    1     0   0   x   x   x    x   x   P   P   u   t     t   t    t   t   0   -   -   -   -   -   -   -   memw(Rx++Mu:brev)=Rt




                           Field name                                                               Description
                         ICLASS                     Instruction Class
                         Type                       Type
                         Parse                      Packet/Loop parse bits
                         e5                         Field to encode register e
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         u1                         Field to encode register u
                         u5                         Field to encode register u
                         x5                         Field to encode register x
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    325

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Store word conditionally
                Store a 32-bit register in memory at the effective address.

                This instruction is conditional based on a predicate value. If the predicate is true, the
                instruction is performed, otherwise it is treated as a NOP.

                               Syntax                                         Behavior
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memw(#u6)=Rt                              apply_extension(#u);
                                                          EA=#u;
                                                          *EA = Rt;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]){
                memw(Rs+#u6:2)=#S6                        EA=Rs+#u;
                                                          apply_extension(#S);
                                                          *EA = #S;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      apply_extension(#u);
                memw(Rs+#u6:2)=Rt                     if ([!]Pv[.new][0]) {
                                                          EA=Rs+#u;
                                                          *EA = Rt;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]) {
                memw(Rs+Ru<<#u2)=Rt                       EA=Rs+(Ru<<#u);
                                                          *EA = Rt;
                                                      } else {
                                                          NOP;
                                                      };
                if ([!]Pv[.new])                      if ([!]Pv[.new][0]){
                memw(Rx++#s4:2)=Rt                        EA=Rx;
                                                          Rx=Rx+#s;
                                                          *EA = Rt;
                                                      } else {
                                                          NOP;
                                                      };




80-N2040-36 B                                        326

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Class: ST (slots 0,1)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2    1   0
    ICLASS                                               s5           Parse                 u5                               t5
0   0   1    1   0   1   0   0    1     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (Pv) memw(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   0   1    1     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (!Pv) memw(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   1   0    1     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (Pv.new) memw(Rs+Ru<<#u2)=Rt
0   0   1    1   0   1   1   1    1     0    0   s   s   s    s   s   P   P   i   u   u     u    u   u   i   v   v   t   t   t    t   t   if (!Pv.new) memw(Rs+Ru<<#u2)=Rt
    ICLASS                                               s5           Parse

0   0   1    1   1   0   0   0    0     1    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (Pv) memw(Rs+#u6:2)=#S6
0   0   1    1   1   0   0   0    1     1    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (!Pv) memw(Rs+#u6:2)=#S6
0   0   1    1   1   0   0   1    0     1    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (Pv.new) memw(Rs+#u6:2)=#S6
0   0   1    1   1   0   0   1    1     1    0   s   s   s    s   s   P   P   I   i     i   i    i   i   i   v   v   I   I   I    I   I   if (!Pv.new) memw(Rs+#u6:2)=#S6
                        Pr
                     Se ed
    ICLASS           ns Ne            Type               s5           Parse                 t5
                     e w

0   1   0    0   0   0   0   0    1     0    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0    v   v   if (Pv) memw(Rs+#u6:2)=Rt
0   1   0    0   0   0   1   0    1     0    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0    v   v   if (Pv.new) memw(Rs+#u6:2)=Rt
0   1   0    0   0   1   0   0    1     0    0   s   s   s    s   s   P   P   i   t     t   t    t   t   i   i   i   i   i   0    v   v if (!Pv) memw(Rs+#u6:2)=Rt
0   1   0    0   0   1   1   0    1     0    0   s   s   s    s   s   P   P   i   t     t   t    t  t   i   i   i   i   i   0    v   v if (!Pv.new) memw(Rs+#u6:2)=Rt

                                             U
    ICLASS       Amode           Type                    x5           Parse                 t5
                                             N

1   0   1    0   1   0   1   1    1     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   0    v   v if (Pv) memw(Rx++#s4:2)=Rt
1   0   1    0   1   0   1   1    1     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   0   i   i   i   i   1    v   v if (!Pv) memw(Rx++#s4:2)=Rt
1   0   1    0   1   0   1   1    1     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   0    v   v   if (Pv.new) memw(Rx++#s4:2)=Rt
1   0   1    0   1   0   1   1    1     0    0   x   x   x    x   x   P   P 1     t     t   t    t   t   1   i   i   i   i   1    v   v   if (!Pv.new) memw(Rx++#s4:2)=Rt
                                             U
    ICLASS       Amode           Type                                 Parse                 t5
                                             N
1   0   1    0   1   1   1   1    1     0    0   -   -   -    i   i   P   P 0     t     t   t    t   t   1   i   i   i   i   0    v   v if (Pv) memw(#u6)=Rt
1   0   1    0   1   1   1   1    1     0    0   -   -   -    i   i   P   P 0     t     t   t    t   t   1   i   i   i   i   1    v   v if (!Pv) memw(#u6)=Rt
1   0   1    0   1   1   1   1    1     0    0   -   -   -    i   i   P   P 1     t     t   t    t   t   1   i   i   i   i   0    v   v if (Pv.new) memw(#u6)=Rt
1   0   1    0   1   1   1   1    1     0    0   -   -   -    i   i   P   P 1     t     t   t    t   t   1   i   i   i   i   1    v   v if (!Pv.new) memw(#u6)=Rt




                           Field name                                                                Description
                         ICLASS                      Instruction Class
                         Type                        Type
                         PredNew                     PredNew
                         Sense                       Sense
                         Parse                       Packet/Loop parse bits



80-N2040-36 B                                                                     327

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                s5             Field to encode register s
                t5             Field to encode register t
                u5             Field to encode register u
                v2             Field to encode register v
                x5             Field to encode register x
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                       328

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Allocate stack frame
                Allocate a stack frame on the call stack. This instruction first pushes LR and FP to the top
                of stack. It then subtracts an unsigned immediate from SP to allocate room for local
                variables. FP is set to the address of the old frame pointer on the stack.

                The following figure shows the stack layout.


                                                Stack in Memory

                                                    Saved LR
                                                    Saved FP




                  Higher Address
                                                 Procedure Local
                                                 Data on Stack

                                                                                  Stack frame



                                                    Saved LR
                                                    Saved FP                           FP register



                                                 Procedure Local
                                                 Data on Stack

                                                                                       SP register
                 Lower Address




                                                Unallocated Stack




                               Syntax                                       Behavior
                allocframe(#u11:3)                   EA=SP+-8;
                                                     *EA = frame_scramble((LR << 32) | FP);
                                                     FP=EA;
                                                     frame_check_limit(EA-#u);
                                                     SP=EA-#u;




80-N2040-36 B                                       329

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



                         Class: ST (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3   2   1   0
                                            U
    ICLASS       Amode           Type                               Parse
                                            N
1   0   1    0   0   0   0   0    1     0   0   1   1   1   0   1   P   P 0   0   0   i   i   i   i   i   i   i   i   i   i   i   allocframe(#u11:3)




                           Field name                                                         Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                 330

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



       11.9 SYSTEM
                The SYSTEM instruction class includes instructions for managing system resources.


     11.9.1 SYSTEM/GUEST
                The SYSTEM/GUEST instruction subclass includes instructions for Guest Mode.

Guest control register transfer
                Move registers between the guest control and general register files. The figure shows the
                guest control registers and their register field encodings. Registers can be moved as
                singles or as aligned 64-bit pairs.


                 0          G0           16    ISDBMBXIN

                 1          G1           17    ISDBMBXOUT

                 2          G2
                 3          G3

                                               Reserved



                                          24   GPCYCLELO

                                          25   GPCYCLEHI
                          Reserved
                                          26   GPMUCNT0

                                          27   GPMUCNT1

                                          28   GPMUCNT2

                                          29   GPMUCNT3

                                          30    Reserved

                 15                       31    Reserved




                                     Syntax                                    Behavior
                Gd=Rs                                        Gd=Rs;
                Gdd=Rss                                      Gdd=Rss;
                Rd=Gs                                        Rd=Gs;
                Rdd=Gss                                      Rdd=Gss;


                Class: SYSTEM (slot 3)

                Notes

                      ï®    This is a guest-level feature. If performed in user mode, a privilege error
                           exception will occur.




80-N2040-36 B                                               331

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS           sm                               s5           Parse                                                 d5
0   1   1    0   0   0    1   0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   -   -   -   d   d   d    d   d Gd=Rs
0   1   1    0   0   0    1   1   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   -   -   -   d   d   d    d   d Gdd=Rss
0   1   1    0   1   0    0   0   0   0   1   s   s   s    s   s   P   P   -   -     -   -   -   -   -   -   -   d   d   d    d   d Rdd=Gss
0   1   1    0   1   0    1   0   0   0   1   s   s   s    s   s   P   P   -   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=Gs




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d5                      Field to encode register d
                          s5                      Field to encode register s




80-N2040-36 B                                                                  332

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



        11.9.2 SYSTEM/MONITOR
                          The SYSTEM/MONITOR instruction subclass includes instructions for Monitor Mode.

Clear interrupt auto disable
                          The register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                          interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31. For bits set in Rs,
                          the corresponding bit in IAD is cleared. This re-enables the interrupt. For bits clear in Rs,
                          the corresponding bit in IAD is unaffected.

                                              Syntax                                                                 Behavior
                          ciad(Rs)                                                 IAD &= ~Rs;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   0   1   1   -    -   -   -   -   ciad(Rs)




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  333

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Swap SGP control register
                          This instruction swaps the contents of a general register with one of the Supervisor
                          General Pointer registers, either SGP0 or SGP1. These registers can be used to hold, for
                          example, a supervisor and/or exception stack pointers, or other general pointers for fast
                          exception processing. A pair swap form exists to swap both SGP registers with an aligned
                          pair of general registers.

                                              Syntax                                                                 Behavior
                          crswap(Rx,sgp)                                           Assembler mapped to: "crswap(Rx,sgp0)"
                          crswap(Rx,sgp0)                                          tmp = Rx;
                                                                                   Rx = SGP0;
                                                                                   SGP0 = tmp;
                          crswap(Rx,sgp1)                                          tmp = Rx;
                                                                                   Rx = SGP1;
                                                                                   SGP1 = tmp;
                          crswap(Rxx,sgp1:0)                                       tmp = Rxx;
                                                                                   Rxx=SGP;
                                                                                   SGP = tmp;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
    ICLASS           sm                               x5           Parse
0   1   1    0   0   1    0   1   0   0   0   x   x   x    x   x   P   P   -   -     -   -   -   -   -   -   -   -    -   -   -   -   crswap(Rx,sgp0)
0   1   1    0   0   1    0   1   0   0   1   x   x   x    x   x   P   P   -   -     -   -   -   -   -   -   -   -    -   -   -   -   crswap(Rx,sgp1)
0   1   1    0   1   1    0   1   1   0   -   x   x   x    x   x   P   P   -   -     -   -   -   -   -   -   -   0   0    0   0   0   crswap(Rxx,sgp1:0)




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          x5                      Field to encode register x




80-N2040-36 B                                                                  334

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Cancel pending interrupts
                          The register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                          interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31. This instruction
                          cancels any pending interrupts indicated in the mask by clearing the interrupt from the
                          IPEND register.

                                              Syntax                                                                 Behavior
                          cswi(Rs)                                                 IPEND &= ~Rs;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   0   0   1   -    -   -   -   -   cswi(Rs)




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  335

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Data cache kill
                         The data cache kill (dckill) instruction invalidates the entire contents of the data cache. On
                         power-up, the caches are not guaranteed to contain valid data. This instruction should be
                         used to establish an initial clean cache state. All dirty data in the data cache which has not
                         yet been written back to memory is lost when dckill is executed. If data needs to be saved,
                         it should be cleaned out using dclean instructions prior to executing dckill. Because the
                         caches are shared between all threads, this instruction must be performed only while
                         ensuring that no other thread is using the caches. The best option is to use this instruction
                         when only one thread is powered on and others are powered off.

                                                Syntax                                                               Behavior
                         dckill                                                     dcache_inv_all();


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This is a solo instruction. It must not be grouped with other instructions in a
                                        packet.
                                 ï®      This is a monitor-level feature. If performed in user or guest mode, a privilege
                                        error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                               Parse
                                            N
1   0   1    0   0   0   1   0    0     0   0   -   -   -   -   -   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   dckill




                           Field name                                                            Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                   336

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Data cache maintenance monitor instructions
                These instructions perform maintenance operations on the data cache.

                dccleaninvidx looks at index Rs in the data cache. If this line has dirty data, then the data
                is written back out to memory. The line is invalidated. The set is provided in Rs[11:5] and
                the way in Rs[2:0]. This instruction can only be grouped with X-type or A-type
                instructions.

                dccleanidx looks at index Rs in the data cache. If this line has dirty data, then the data is
                written back out to memory. The set is provided in Rs[11:5] and the way in Rs[2:0]. This
                instruction can only be grouped with X-type or A-type instructions.

                dcinvidx invalidates the line at index Rs. The set is provided in Rs[11:5] and the way in
                Rs[2:0]. This instruction can only be grouped with X-type or A-type instructions.

                dctagr reads the tag at indicated by Rs and returns the data into Rd. The set is provided
                Rs[11:5], and the Way is provided in Rs[2:0]. The tag is returned in Rd[23:0], and the state
                is returned in Rd[30:29]. This instruction can only be grouped with X-type or A-type
                instructions.

                dctagw uses register Rs and Rt. Register Rs contains the set in [11:5] and way in [2:0]
                while the Rt value contains the Tag in [23:0] and the state in [30:29]. The dctagw
                instruction is Single-Thread only. All other threads must be in STOP or DEBUG mode
                with no outstanding transactions. This instruction is solo and must not appear in a packet
                with other instructions.

                The state bits are encoded as:

                00 : Invalid

                01 : Valid & Clean

                10 : Reserved

                11 : Valid & Clean

                                Syntax                                       Behavior
                Rd=dctagr(Rs)                         dcache_tag_read(Rs);
                dccleanidx(Rs)                        dcache_clean_idx(Rs);
                dccleaninvidx(Rs)                     dcache_clean_idx(Rs);
                                                      dcache_inv_idx(Rs);
                dcinvidx(Rs)                          dcache_inv_idx(Rs);
                dctagw(Rs,Rt)                         dcache_tag_write(Rs,Rt);




80-N2040-36 B                                       337

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                        instructions.
                                 ï®      This is a solo instruction. It must not be grouped with other instructions in a
                                        packet.
                                 ï®      This is a monitor-level feature. If performed in user or guest mode, a privilege
                                        error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse
                                            N
1   0   1    0   0   0   1   0    0     0   1   s   s   s    s   s   P   P   -   -     -   -    -   -   -   -   -   -   -   -    -   -   dccleanidx(Rs)
1   0   1    0   0   0   1   0    0     1   0   s   s   s    s   s   P   P   -   -     -   -    -   -   -   -   -   -   -   -    -   -   dcinvidx(Rs)
1   0   1    0   0   0   1   0    0     1   1   s   s   s    s   s   P   P   -   -     -   -    -   -   -   -   -   -   -   -    -   -   dccleaninvidx(Rs)
                                            U
    ICLASS       Amode           Type                   s5           Parse                 t5
                                            N
1   0   1    0   0   1   0   0    0     0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   -   -   -    -   -   dctagw(Rs,Rt)
                                            U
    ICLASS       Amode           Type       N           s5           Parse                                                  d5

1   0   1    0   0   1   0   0    0     0   1   s   s   s    s   s   P   P   -   -     -   -    -   -   -   -   -   d   d   d    d   d Rd=dctagr(Rs)




                           Field name                                                               Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    338

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Read the interrupt mask for a thread
                          Each thread contains an IMASK register that holds the interrupt enable/disable for
                          individual interrupts 0-31. This instruction reads the IMASK for the thread indicated by
                          the low bits of Rs. The result is returned in Rd. For Rs values outside of [0-
                          NUM_THREADS-1], the results are undefined.

                                              Syntax                                                                 Behavior
                          Rd=getimask(Rs)                                          Rd=IMASK[Rs&0x7];


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS           sm                               s5           Parse                                                 d5
0   1   1    0   0   1    1   0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   -   -   -   d   d   d    d   d Rd=getimask(Rs)




                            Field name                                                           Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d5                      Field to encode register d
                          s5                      Field to encode register s




80-N2040-36 B                                                                  339

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Acquire hardware lock
                          These instructions acquire a hardware lock.

                          If the lock bit is set, sleep until the lock bit is clear. The packet with the lock instruction
                          will only complete once the lock is set and acquired by this thread. In the case that
                          multiple threads are waiting for the lock, the hardware guarantees round-robin fairness
                          such that no thread will be starved.

                          The tlblock is acquired automatically whenever a thread raises a TLB miss-RW or TLB-
                          miss-X exception.

                          The TLB lock can also be released by the rteunlock instruction.

                                              Syntax                                                               Behavior
                          k0lock                                                  if (can_aquire_k0_lock) {
                                                                                      SYSCFG.K0LOCK = 1;
                                                                                  } else {
                                                                                      sleep_until_available;
                                                                                  };
                          tlblock                                                 if (can_aquire_tlb_lock) {
                                                                                      SYSCFG.TLBLOCK = 1;
                                                                                  } else {
                                                                                      sleep_until_available;
                                                                                  };


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2   1   0
    ICLASS           sm                                           Parse
0   1   1    0   1   1    0   0   0   0   1   -   -   -   -   -   P   P   -   -    -   -   -   -   0   0   1   -    -   -   -   -   tlblock
0   1   1    0   1   1    0   0   0   0   1   -   -   -   -   -   P   P   -   -    -   -   -   -   0   1   1   -    -   -   -   -   k0lock




                            Field name                                                         Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits




80-N2040-36 B                                                                 340

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Release hardware lock
                          These instructions release a hardware lock.

                                              Syntax                                                               Behavior
                          k0unlock                                                SYSCFG.K0LOCK = 0;
                          tlbunlock                                               SYSCFG.TLBLOCK = 0;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2   1   0
    ICLASS           sm                                           Parse
0   1   1    0   1   1    0   0   0   0   1   -   -   -   -   -   P   P   -   -    -   -   -   -   0   1   0   -    -   -   -   -   tlbunlock
0   1   1    0   1   1    0   0   0   0   1   -   -   -   -   -   P   P   -   -    -   -   -   -   1   0   0   -    -   -   -   -   k0unlock




                            Field name                                                         Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits




80-N2040-36 B                                                                 341

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Interrupt to thread assignment read
                Each thread contains an IMASK register that holds the interrupt enable/disable for
                individual interrupts 0-31. For a given interrupt, the iassignr instruction reads the
                corresponding bit in every thread's IMASK register. The upper halfword of source register
                Rs contains the interrupt number from 0-31 (0 is the highest priority interrupt, 31 the
                lowest). The low bits of the destination register Rd contain a bit mask where bit 0 contains
                the corresponding IMASK value for thread 0, bit 1 the value for thread 1, etc. The number
                of defined bits depends on the number of HW threads provided in the core. All bits beyond
                the number of threads provided will be cleared. For example, if the interrupt number is set
                to 0, then Rd[0] will be the value of IMASK[0] for thread 0, Rd[1] will be the value of
                IMASK[0] for thread 1, etc.


                  31                               16 15                         0

                                            Int#                                        Rs



                                     Interrupt number [0-31]
                                     0=highest priority
                                     interrupt
                                     31=lowest priority


                  31                                                             0

                                                                                        Rd


                                                                                     Thread 0:
                                                                                     Value of IMASK[int#]




                                                               Thread 5 assignment


                                 Syntax                                        Behavior
                Rd=iassignr(Rs)                            Rd=IASSIGNR(Rs);


                Class: SYSTEM (slot 3)

                Notes

                       ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                           instructions.
                       ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                           error exception will occur.



80-N2040-36 B                                          342

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3   2    1   0
    ICLASS           sm                               s5           Parse                                               d5
0   1   1    0   0   1    1   0   0   1   1   s   s   s    s   s   P   P   -   -   -   -   -   -   -   -   -   d   d   d    d   d Rd=iassignr(Rs)




                            Field name                                                         Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d5                      Field to encode register d
                          s5                      Field to encode register s




80-N2040-36 B                                                                  343

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



Interrupt to thread assignment write
                          Each thread contains an IMASK register that holds the interrupt enable/disable for
                          individual interrupts 0-31. For a given interrupt, the iassignw instruction sets or clears the
                          corresponding bit in every thread's IMASK register. This allows for easy re-assignment of
                          interrupts to selected threads. The source register Rs contains two fields. The upper
                          halfword should contain the interrupt number from 0-31 (0 is the highest priority interrupt,
                          31 the lowest). The low bits contain a bit mask where bit 0 contains the corresponding
                          IMASK value for thread 0, bit 1 the value for thread 1, etc. For example, if the interrupt
                          number is set to 0, and the bitmask is set to 0x03, then the IMASK[0] for threads 0 and 1
                          will be set and the IMASK[0] for all other threads will be cleared. This means that threads
                          0,1 will not accept this interrupt, whereas other threads will accept it.


    31                                         16 15                                              0

                                       Int#                                                                   Rs

                                                                                                      Thread 0 assignment:
                                                                                                      1=Set Thread0:IMASK[Int#]
                              Interrupt number [0-31]                                                 (interrupt disabled)
                              0=highest priority
                              interrupt                                                               0=Clear Thread0:IMASK[Int#]
                              31=lowest priority                                                      (interrupt enabled for T0)

                                                                    Thread 5 assignment


                                               Syntax                                                                      Behavior
                          iassignw(Rs)                                               IASSIGNW(Rs);


                          Class: SYSTEM (slot 3)

                          Notes

                                   ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                       instructions.
                                   ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                       error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7    6   5   4   3    2   1   0
    ICLASS           sm                                s5           Parse
0    1   1   0   0   1    0    0   0   0   0   s   s   s    s   s    P   P   -   -    -   -   -       -   0    1   0   -    -   -   -   -   iassignw(Rs)




80-N2040-36 B                                                                    344

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                sm             Supervisor mode only
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                s5             Field to encode register s




80-N2040-36 B                                       345

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Instruction cache maintenance supervisor operations
                         These instructions perform maintenance operations on the instruction cache.

                         ictagr reads the tag entry at set Rs[13:5] and way Rs[0]. The tag information is returned in
                         Rd[31:4] (with the G bit in bit 31, the ASID value in bits 30:24, and the Tag value in bits
                         23:4). The Valid bit is returned in Rd[1], and the Reserved bit in Rd[0].

                         icdatar reads the data word at set Rs[13:5], word Rs[4:2], and way Rs[0]. The data value is
                         returned in Rd[31:0].

                         icinvidx invalidates the instruction cache index indicated by Rs.

                                             Syntax                                                                Behavior
                         Rd=icdatar(Rs)                                           icache_data_read(Rs);
                         Rd=ictagr(Rs)                                            icache_tag_read(Rs);
                         icinvidx(Rs)                                             icache_inv_idx(Rs);


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                     packet.
                                 ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                     error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2    1   0
    ICLASS                                           s5           Parse                                                 d5
0   1   0    1   0   1   0   1   1   0   1   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   d   d    d    d   d Rd=icdatar(Rs)
0   1   0    1   0   1   0   1   1   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   d   d    d    d   d Rd=ictagr(Rs)
    ICLASS                                           s5           Parse
0   1   0    1   0   1   1   0   1   1   0   s   s   s    s   s   P   P 0     0    1   -   -   -   -   -   -   -    -   -    -   -   icinvidx(Rs)




                           Field name                                                          Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         d5                      Field to encode register d
                         s5                      Field to encode register s




80-N2040-36 B                                                                 346

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Instruction cache maintenance operations (single-thread)
                         These instructions perform maintenance operations on the instruction cache.

                         ickill invalidates the instruction cache.

                         ictagw updates specified tag entry with contents of Rt. Rs[13:5] selects index and Rs[0] is
                         used to select cache way. Rt must have the Tag information in bits 27:0 (G bit is bit 27,
                         ASID is bits 26:20 and Tag is 19:0), the Valid bit in Rt[30] and the Reserved bit in Rt[31].

                         These instructions are Single-Thread only. All other threads must be in STOP or DEBUG
                         mode with no outstanding transactions.

                                             Syntax                                                                 Behavior
                         ickill                                                   icache_inv_all();
                         ictagw(Rs,Rt)                                            icache_tag_write(Rs,Rt);


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                     packet.
                                 ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                     error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS                                           s5           Parse                t5
0   1   0    1   0   1   0   1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   -   -   -    -   -   -   -   ictagw(Rs,Rt)
    ICLASS                                                        Parse
0   1   0    1   0   1   1   0   1   1   0   -   -   -    -   -   P   P 0     1    0   -    -   -   -   -   -   -    -   -   -   -   ickill




                           Field name                                                           Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s
                         t5                      Field to encode register t




80-N2040-36 B                                                                 347

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



L2 cache operations by index
                         L2 cacheops by index work on a specified line in L2 cache. The clean operation pushed
                         dirty data out to the system. The invalidate operations marks the line as invalidate, and the
                         cleaninv operation first cleans the line and then invalidates it. The index is provided in
                         Rs[S:8] and the way in Rs[2:0], where S is determined by the number of sets in the L2
                         cache. For segmented L2 caches, the granule bit provided in Rs[3]. This bit is ignored if
                         the cache is not segmented.

                         Different versions of Hexagon may have different L2 cache sizes. Please see the section
                         on Core Versions for more information.

                                                Syntax                                                                Behavior
                         l2cleanidx(Rs)                                              l2cache_clean_idx(Rs);
                         l2cleaninvidx(Rs)                                           l2cache_clean_invalidate_idx(Rs);
                         l2invidx(Rs)                                                l2cache_inv_idx(Rs);


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                        instructions.
                                 ï®      This is a monitor-level feature. If performed in user or guest mode, a privilege
                                        error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse
                                            N
1   0   1    0   0   1   1   0    0     0   1   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   l2cleanidx(Rs)
1   0   1    0   0   1   1   0    0     1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   l2invidx(Rs)
1   0   1    0   1   0   0   0    0     1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   l2cleaninvidx(Rs)




                           Field name                                                             Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         s5                         Field to encode register s
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    348

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



L2 cache global operations
                These instructions perform maintenance operations over the entire L2 cache. The
                instructions will commit and set the SYSCFG:L2GCA bit to indicate that the Global
                Cache state machine is Active. Once the state machine is started it will process every L2
                cacheline in the background. After all cachelines have been processed, the
                SYSCFG:L2GCA status bit is cleared. The instructions are:

                l2kill will invalidate every line. It is required to execute this instruction prior to using L2
                after a poweron reset, as the cache will start in an unknown state.

                l2gclean will force a clean (write back) operation for all L2 cachelines that are dirty.

                l2gcleaninv will force a clean (write back) for dirty L2 lines and then invalidate them.

                l2gunlock will clear the lock bit for all L2 cachelines.

                The l2gclean and l2gcleaninv instructions are available with PA range and mask option. In
                this form, the Rtt register contains a mask in the lower word and match value in the upper
                word. If the Physical Page Number of the cache line anded with the mask is equal to the
                match value, then the cacheop is performed. Otherwise, the cacheline is left unchanged.
                The semantics are:

                for every cacheline in L2:

                if (Rtt[23:0] & PA[35:12]) == Rtt[55:32]) do clean/cleaninv on the cacheline

                               Syntax                                         Behavior
                l2gclean                               l2cache_global_clean();
                l2gclean(Rtt)                          l2cache_global_clean_range(Rtt);
                l2gcleaninv                            l2cache_global_clean_inv();
                l2gcleaninv(Rtt)                       l2cache_global_clean_inv_range(Rtt);
                l2gunlock                              l2cache_global_unlock();
                l2kill                                 l2cache_inv_all();


                Class: SYSTEM (slots 0)

                Notes

                     ï®   This is a solo instruction. It must not be grouped with other instructions in a
                         packet.
                     ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                         error exception will occur.




80-N2040-36 B                                        349

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2   1   0
                                            U
    ICLASS       Amode           Type                               Parse               t5
                                            N
1   0   1    0   0   1   1   0    1     0   1   -   -   -   -   -   P   P   -   t   t   t    t   t   -   -   -   -   -   -   -   -   l2gclean(Rtt)
1   0   1    0   0   1   1   0    1     1   0   -   -   -   -   -   P   P   -   t   t   t    t   t   -   -   -   -   -   -   -   -   l2gcleaninv(Rtt)
                                            U
    ICLASS       Amode           Type       N                       Parse

1   0   1    0   1   0   0   0    0     0   1   -   -   -   -   -   P   P   -   0   0   0    -   -   -   -   -   -   -   -   -   -   l2kill
1   0   1    0   1   0   0   0    0     0   1   -   -   -   -   -   P   P   -   0   1   0    -   -   -   -   -   -   -   -   -   -   l2gunlock
1   0   1    0   1   0   0   0    0     0   1   -   -   -   -   -   P   P   -   1   0   0    -   -   -   -   -   -   -   -   -   -   l2gclean
1   0   1    0   1   0   0   0    0     0   1   -   -   -   -   -   P   P   -   1   1   0    -   -   -   -   -   -   -   -   -   -   l2gcleaninv




                           Field name                                                            Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         t5                         Field to encode register t
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                   350

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



L2 cache operations by address
                         The L2 lock instruction will first allocate a line in L2 based on the address provided in Rs.
                         It will then set the lock bit so the line will not be replaced in the future, unless explicitly
                         unlocked. A fetch will be initiated for the data. Finally, the instruction will return a status
                         result to the destination predicate. The predicate is set to 0xff if the operation was
                         successful, or 0x00 if the operation did not succeed. The failure state can be returned
                         either because all the L2 cache ways are already locked, or because of some internal
                         transient conditions. The software should resolve transient conditions by re-trying the
                         l2locka instruction with a large number of attempts (1000 recommended).

                         The l2unlocka instruction will clear the lock bit on an L2 cacheline which holds the
                         provided address.

                                                Syntax                                                                Behavior
                         Pd=l2locka(Rs)                                              EA=Rs;
                                                                                     Pd=l2locka(EA);
                         l2unlocka(Rs)                                               EA=Rs;
                                                                                     l2unlocka(EA);


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                        instructions.
                                 ï®      The predicate generated by this instruction can not be used as a .new predicate,
                                        nor can it be automatically ANDed with another predicate.
                                 ï®      This is a monitor-level feature. If performed in user or guest mode, a privilege
                                        error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1    0
                                            U
    ICLASS       Amode           Type       N           s5           Parse                                                         d2

1   0   1    0   0   0   0   0    1     1   1   s   s   s    s   s   P   P 1     -    -   -   -   -   -   -   -   -    -   -   d    d Pd=l2locka(Rs)
                                            U
    ICLASS       Amode           Type                   s5           Parse
                                            N
1   0   1    0   0   1   1   0    0     1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -        -   l2unlocka(Rs)




                           Field name                                                             Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         d2                         Field to encode register d
                         s5                         Field to encode register s




80-N2040-36 B                                                                    351

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                 352

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



L2 tag read/write
                L2tagr reads the tag at indicated by Rs and returns the data into Rd. The L2tagr instruction
                can be grouped with A-type and X-type instructions. The L2tagw instruction should not be
                grouped in a packet. Register Rs is formatted as

                Rs[17:8] = Set

                Rs[2:0] = Way

                The return register Rd is formatted as

                Rd[31] = A1

                Rd[30] = A0

                Rd[28:8] = Tag address bits 35:15

                Rd[4] = Lock bit

                Rd[3] = Reserve bit

                Rd[2:0] = State[2:0]

                The state bits are defined as follows:

                0 = Invalid

                1,3 = Reserved

                4 = Valid & Clean

                6 = Valid & Dirty

                                 Syntax                                      Behavior
                Rd=l2tagr(Rs)                            l2cache_tag_read(Rs);
                l2tagw(Rs,Rt)                            l2cache_tag_write(Rs,Rt);


                Class: SYSTEM (slots 0)

                Notes

                     ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                         instructions.
                     ï®   This is a solo instruction. It must not be grouped with other instructions in a
                         packet.
                     ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                         error exception will occur.




80-N2040-36 B                                        353

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse               t5
                                            N
1   0   1    0   0   1   0   0    0     1   0   s   s   s    s   s   P   P 0     t   t   t    t   t   -   -   -   -   -   -    -   -   l2tagw(Rs,Rt)
                                            U
    ICLASS       Amode           Type                   s5           Parse                                                d5
                                            N
1   0   1    0   0   1   0   0    0     1   1   s   s   s    s   s   P   P   -   -   -   -    -   -   -   -   -   d   d   d    d   d Rd=l2tagr(Rs)




                           Field name                                                             Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t5                         Field to encode register t
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                    354

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Load from physical address
                         Perform a word load using the 36-bit physical address held in source registers Rt:Rs. Rs
                         holds PA[10:0] and Rt holds PA[35:11] in the least-significant bits. This instruction will
                         first look in the L1 and L2 caches for the data. If found, the data will be returned. If the
                         access misses in cache, it will be treated as a non-allocating (uncached) load. The
                         hardware will force the two least-significant bits to zero, so will never result in an
                         alignment violation.

                         This instruction is used for the monitor software to walk guest mode page tables, and for
                         easier debugging.

                                                Syntax                                                               Behavior
                         Rd=memw_phys(Rs,Rt)                                       Rd = *((Rs&0x7ff) | (Rt<<11));


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This is a solo instruction. It must not be grouped with other instructions in a
                                        packet.
                                 ï®      This is a monitor-level feature. If performed in user or guest mode, a privilege
                                        error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse              t5                               d5
                                            N
1   0   0    1   0   0   1   0    0     0   0   s   s   s    s   s   P   P 1   t    t   t    t   t   -   -   0   d   d   d    d   d Rd=memw_phys(Rs,Rt)




                           Field name                                                            Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s
                         t5                         Field to encode register t




80-N2040-36 B                                                                  355

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Raise NMI on threads
                          The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
                          of defined bits depends on the how many HW threads are supported. The NMI instruction
                          raises a non-maskable NMI interrupt for all threads specified in the mask. This interrupt
                          will cause the thread jump to the NMI vector at the address specified in EVB.

                                              Syntax                                                                Behavior
                          nmi(Rs)                                                  Raise NMI on threads;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0   1   0   -    -   -   -   -   nmi(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  356

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Resume from wait mode
                          The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
                          of defined bits depends on the how many HW threads are supported. The resume
                          instruction causes all threads specified in the mask which are in wait mode to exit wait
                          mode back to either supervisor or user mode (whichever was active when the thread
                          entered wait mode). If the thread to be resumed is off (stop mode), or already running
                          (user or supervisor mode), then the resume instruction has no affect.

                                              Syntax                                                                Behavior
                          resume(Rs)                                               for (i = 0; i < THREADS_MAX; i++) {
                                                                                       if (Rs.i) {
                                                                                           modectl[(i+16)] = 0;
                                                                                       };
                                                                                   };


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   0   0   1   -    -   -   -   -   resume(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  357

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                              Instruction Set



Return from exception
                         This instruction is used to return from an interrupt or exception handler. It clears the EX
                         bit in SSR and jumps to the location specified in the ELR register. rte clears the
                         SYSCFG.TLBLOCK bit, thus releasing the TLB lock and allowing other threads to
                         acquire the lock if needed. rte must not be grouped with another exception-causing
                         instruction. If it is grouped with any other instruction that causes an exception, the
                         behavior is undefined.

                                             Syntax                                                             Behavior
                         rte                                                   SSR.SSR_EX = 0;
                                                                               PC=ELR;


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                     error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                         8   7   6   5   4   3    2   1   0
    ICLASS                                                       Parse
0   1   0    1   0   1   1   1   1   1   1   -   -   -   -   -   P   P 0   0    -   -   -   -   0   0   0   -    -   -   -   -   rte




                           Field name                                                       Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits




80-N2040-36 B                                                              358

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Return from exception and unlock TLB
                         This instruction is used to return from an interrupt or exception handler. It clears the EX
                         bit in SSR and jumps to the location specified in the ELR register.

                                             Syntax                                                             Behavior
                         rteunlock                                             SSR.SSR_EX = 0;
                                                                               SYSCFG.TLBLOCK = 0;
                                                                               PC=ELR;


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                     error exception will occur.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                         8   7   6   5   4   3    2   1   0
    ICLASS                                                       Parse
0   1   0    1   0   1   1   1   1   1   1   -   -   -   -   -   P   P 0   1    -   -   -   -   0   0   0   -    -   -   -   -   rteunlock




                           Field name                                                       Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits




80-N2040-36 B                                                              359

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



Set the interrupt mask for a thread
                          Each thread contains an IMASK register that holds the interrupt enable/disable for
                          individual interrupts 0-31. This instruction writes the IMASK for the thread indicated by
                          the low bits of predicate Pt. The register Rs contains the 32-bit mask value to be written.
                          For Pt values outside of [0-NUM_THREADS-1], the results are undefined.

                                              Syntax                                                                     Behavior
                          setimask(Pt,Rs)                                          IMASK[Pt&0x7]=Rs;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse                        t2
0   1   1    0   0   1    0   0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   t        t   0   0   0   -    -   -   -   -   setimask(Pt,Rs)




                            Field name                                                               Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s
                          t2                      Field to encode register t




80-N2040-36 B                                                                  360

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Set interrupt auto disable
                          The register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                          interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31. For bits set in Rs,
                          the corresponding bit in IAD is set. This disables the interrupt. For bits clear in Rs, the
                          corresponding bit in IAD is unaffected.

                                              Syntax                                                                Behavior
                          siad(Rs)                                                 IAD |= Rs;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   0   1   1   -    -   -   -   -   siad(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  361

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Start threads
                          The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
                          of defined bits depends on the how many HW threads are supported. The start instruction
                          raises a non-maskable software reset interrupt for all threads specified in the mask. This
                          interrupt will cause the thread to clear all writable bits in the supervisor status register and
                          then jump to the start vector at the address specified in EVB. Typically, start should be
                          used to power up threads after they have been disabled by the stop instruction.

                                              Syntax                                                                Behavior
                          start(Rs)                                                for (i = 0; i < THREADS_MAX; i++) {
                                                                                       if (Rs.i && (modectl[i] == 0)) {
                                                                                           modectl[i] = 1;
                                                                                           reset_thread(i);
                                                                                       };
                                                                                   };


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0   0   1   -    -   -   -   -   start(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  362

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Stop threads
                          The stop instruction causes the calling thread to enter stop mode. Stop mode is a power off
                          mode where all register contents for that thread should be assumed lost. The only way out
                          of stop mode is through a reset interrupt. The reset interrupt can be from another thread
                          executing the start instruction, or from an external hardware reset signal.

                          Note that the source register Rs is not used in the instruction. It exists for backwards
                          compatibility.

                                              Syntax                                                                Behavior
                          stop(Rs)                                                 if (!in_debug_mode) modectl[TNUM] = 0;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0   0   0   -    -   -   -   -   stop(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  363

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Software interrupt
                          Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                          interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31. This instruction
                          causes the interrupts indicated in the mask to be raised. Interrupt processing will be
                          initiated as described in the System Architecture Specification.

                          This instruction is provided so that threads can very quickly interrupt one another.

                                              Syntax                                                                Behavior
                          swi(Rs)                                                  IPEND |= Rs;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   0   0   0   -    -   -   -   -   swi(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  364

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



TLB read/write/probe operations
                These instructions manage the software-programmable Translation Lookaside Buffer.

                The TLB Read (tlbr) instruction returns the 64-bit TLB entry at the location specified in
                register Rs. The result is written into the 64-bit destination register pair.

                The TLB Write (tlbw) instruction writes the 64-bit TLB entry specified by register Rt with
                the contents of register pair Rss.

                The TLB Probe (tlbp) instruction looks up the TLB based on the virtual page number
                contained in register Rs[19:0] together with the 7-bit ASID provided in Rs[26:20]. If the
                entry is found and marked valid, its index is placed in Rd, otherwise Rd is set to
                0x8000_0000.

                The TLB Invalidate ASID (tlbinvasid) instruction invalidates all TLB entries with the
                Global bit NOT set and with the ASID matching the Rs[26:20] operand.

                The Conditional TLB Write (ctlbw) instruction first checks if the new entry would overlap
                the virtual address range of any other entry in the TLB. The overlap check considers page
                size and ASID. In the overlap check, the Global bit of the incoming Rss entry is forced to
                zero and the Valid bit is forced to 1. If there is no overlap, the entry is written and the
                destination register is set to 0x8000_0000. Otherwise, if an overlap occurs, no TLB entry
                is written and the index on the overlapping entry is placed in Rd. If multiple entries
                overlap, the value 0xffff_ffff is returned.

                The TLB Overlap Check (tlboc) instruction looks up the TLB based on the VPN, page
                size, and ASID contained in register Rss (in the same format as TLBW). The overlap
                check considers page size and ASID. In the overlap check, the Global bit of the incoming
                Rss entry is forced to zero and the Valid bit is forced to 1. If the Rss entry overlaps virtual
                address range of any another entry in the TLB, the index of the overlapping entry is placed
                in Rd, otherwise Rd is set to 0x8000_0000. If multiple entries overlap, the value
                0xffff_ffff is returned.

                For both tlboc and ctlbw, if the PPN[5:0] are all zero, then the behavior is undefined.




80-N2040-36 B                                        365

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set




                                              Syntax                                                                 Behavior
                          Rd=ctlbw(Rss,Rt)                                         if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {
                                                                                       Rd=GET_OVERLAPPING_IDX((1LL<<63) |
                                                                                   Rss);
                                                                                   } else {
                                                                                       TLB[Rt] = Rss;
                                                                                       Rd=0x80000000;
                                                                                   };
                          Rd=tlboc(Rss)                                            if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {
                                                                                       Rd=GET_OVERLAPPING_IDX((1LL<<63) |
                                                                                   Rss);
                                                                                   } else {
                                                                                       Rd=0x80000000;
                                                                                   };
                          Rd=tlbp(Rs)                                              Rd=search_TLB(Rs);
                          Rdd=tlbr(Rs)                                             Rdd = TLB[Rs];
                          tlbinvasid(Rs)                                           for (i = 0; i < NUM_TLB_ENTRIES; i++) {
                                                                                       if ((TLB[i].PTE_G == 0) &&
                                                                                   (TLB[i].PTE_ASID == Rs[26:20])) {
                                                                                           TLB[i] = TLB[i] & ~(1ULL << 63);
                                                                                       };
                                                                                   };
                          tlbw(Rss,Rt)                                             TLB[Rt] = Rss;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2    1   0
    ICLASS           sm                               s5           Parse                t5
0   1   1    0   1   1    0   0   0   0   0   s   s   s    s   s   P   P 0     t    t   t    t   t   -   -   -   -    -   -    -   -   tlbw(Rss,Rt)
    ICLASS           sm                               s5           Parse                                                  d5
0   1   1    0   1   1    0   0   0   1   0   s   s   s    s   s   P   P   -   -    -   -    -   -   -   -   -   d   d    d    d   d Rdd=tlbr(Rs)
0   1   1    0   1   1    0   0   1   0   0   s   s   s    s   s   P   P   -   -    -   -    -   -   -   -   -   d   d    d    d   d Rd=tlbp(Rs)
    ICLASS           sm                               s5           Parse
0   1   1    0   1   1    0   0   1   0   1   s   s   s    s   s   P   P   -   -    -   -    -   -   -   -   -   -    -   -    -   -   tlbinvasid(Rs)
    ICLASS           sm                               s5           Parse                t5                                d5
0   1   1    0   1   1    0   0   1   1   0   s   s   s    s   s   P   P 0     t    t   t    t   t   -   -   -   d   d    d    d   d Rd=ctlbw(Rss,Rt)
    ICLASS           sm                               s5           Parse                                                  d5
0   1   1    0   1   1    0   0   1   1   1   s   s   s    s   s   P   P   -   -    -   -    -   -   -   -   -   d   d    d    d   d Rd=tlboc(Rss)




80-N2040-36 B                                                                  366

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                sm             Supervisor mode only
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       367

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



System control register transfer
                These instructions move data between supervisor control registers and general registers.
                Registers can be moved as 32-bit singles or as 64-bit aligned pairs. The figure shows the
                system control registers and their register field encodings.


                  0         SGP0               16     EVB             32     ISDBST          48    PMUCNT0

                  1         SGP1               17   MODECTL           33    ISDBCFG0         49    PMUCNT1

                  2         STID               18   SYSCFG            34    ISDBCFG1         50    PMUCNT2

                  3          ELR               19      -              35        -            51    PMUCNT3

                  4        BADVA0              20    IPEND            36    BRKPTPC0         52   PMUEVTCFG


                  5        BADVA1              21     VID             37    BRKPTCFG0        53     PMUCFG

                  6          SSR               22     IAD             38    BRKPTPC1         54

                  7          CCR               23      -              39    BRKPTCFG1
                                                                                                    Reserved
                  8         HTID               24     IEL             40    ISDBMBXIN

                  9         BADVA              25      -              41   ISDBMBXOUT

                 10         IMASK              26     IAHL                   ISDBEN
                                                                      42

                 11                            27   CFGBASE           43     ISDBGPR

                                               28     DIAG


                           Reserved            29     REV                    Reserved

                                               30   PCYCLELO

                                               31   PCYCLEHI
                  15                                                  47                     63




                                      Syntax                                  Behavior
                Rd=Ss                                      Rd=Ss;
                Rdd=Sss                                    Rdd=Sss;
                Sd=Rs                                      Sd=Rs;
                Sdd=Rss                                    Sdd=Rss;


                Class: SYSTEM (slot 3)

                Notes

                       ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                           error exception will occur.




80-N2040-36 B                                          368

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS           sm                                s5              Parse                                           d6
0   1   1    0   0   1    1   1   0   0   -   s   s        s   s   s   P   P   -   -   -   -   -   -   -   -   d   d   d   d    d   d Sd=Rs
0   1   1    0   1   1    0   1   0   0   -   s   s        s   s   s   P   P   -   -   -   -   -   -   -   -   d   d   d   d    d   d Sdd=Rss
    ICLASS           sm                               s6               Parse                                               d5
0   1   1    0   1   1    1   0   1   -   s   s   s        s   s   s   P   P   -   -   -   -   -   -   -   -   -   d   d   d    d   d Rd=Ss
0   1   1    0   1   1    1   1   0   -   s   s   s        s   s   s   P   P   -   -   -   -   -   -   -   -   -   d   d   d    d   d Rdd=Sss




                            Field name                                                             Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          d5                      Field to encode register d
                          d6                      Field to encode register d
                          s5                      Field to encode register s
                          s6                      Field to encode register s




80-N2040-36 B                                                                      369

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Transition threads to wait mode
                          The wait instruction causes the calling thread to enter wait mode. Wait mode is a low-
                          power mode where the thread idles. The thread will not fetch or execute instructions in
                          wait mode.

                          When a thread executes wait, the PC is set to the packet after the wait instruction.

                          To exit wait mode, a waiting thread can either receive an interrupt, or another thread can
                          execute the resume instruction for the waiting thread. In the case that a thread is woken up
                          by an interrupt, at the time the interrupt service routine completes and executes an rte
                          instruction, the thread will remain running.

                          Note that the source register Rs is not used in the instruction. It exists for backwards
                          compatibility.

                                              Syntax                                                                Behavior
                          wait(Rs)                                                 if (!in_debug_mode) modectl[(TNUM+16)] = 1;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.
                                  ï®   This is a monitor-level feature. If performed in user or guest mode, a privilege
                                      error exception will occur.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   1    0   0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   0   0   0   -    -   -   -   -   wait(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  370

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



        11.9.3 SYSTEM/USER
                         The SYSTEM/USER instruction subclass includes instructions which allow user access to
                         system resources.

Load locked
                         Perform a word or double-word locked load. This returns the contents of the memory at
                         address Rs and also reserves a lock reservation at that address. See the section on Atomic
                         Operations for more information.

                                                Syntax                                                              Behavior
                         Rd=memw_locked(Rs)                                        EA=Rs;
                                                                                   Rd = *EA;
                         Rdd=memd_locked(Rs)                                       EA=Rs;
                                                                                   Rdd = *EA;


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                        instructions.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse                                              d5
                                            N
1   0   0    1   0   0   1   0    0     0   0   s   s   s    s   s   P   P 0   0    -   -   -   -   -   -   0   d   d   d    d   d Rd=memw_locked(Rs)
1   0   0    1   0   0   1   0    0     0   0   s   s   s    s   s   P   P 0   1    -   -   -   -   -   -   0   d   d   d    d   d Rdd=memd_locked(Rs)




                           Field name                                                           Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         d5                         Field to encode register d
                         s5                         Field to encode register s




80-N2040-36 B                                                                  371

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Store conditional
                         Perform a word or double-word conditional store operation. If the address reservation is
                         held by this thread and there have been no intervening accesses to the memory location,
                         then the store is performed and the predicate is set to true. Otherwise, the store is not
                         performed and the predicate returns false. See the section on Atomic Operations for more
                         information.

                                                Syntax                                                                 Behavior
                         memd_locked(Rs,Pd)=Rtt                                      EA=Rs;
                                                                                     if (lock_valid) {
                                                                                         *EA = Rtt;
                                                                                         Pd = 0xff;
                                                                                         lock_valid = 0;
                                                                                     } else {
                                                                                         Pd = 0;
                                                                                     };
                         memw_locked(Rs,Pd)=Rt                                       EA=Rs;
                                                                                     if (lock_valid) {
                                                                                         *EA = Rt;
                                                                                         Pd = 0xff;
                                                                                         lock_valid = 0;
                                                                                     } else {
                                                                                         Pd = 0;
                                                                                     };


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                        instructions.
                                 ï®      The predicate generated by this instruction can not be used as a .new predicate,
                                        nor can it be automatically ANDed with another predicate.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1    0
                                            U
    ICLASS       Amode           Type                   s5           Parse                t5                                        d2
                                            N
1   0   1    0   0   0   0   0    1     0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   -   -   -    -   -   d    d memw_locked(Rs,Pd)=Rt
1   0   1    0   0   0   0   0    1     1   1   s   s   s    s   s   P   P 0     t    t   t    t   t   -   -   -   -    -   -   d    d memd_locked(Rs,Pd)=Rtt




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         d2                         Field to encode register d
                         s5                         Field to encode register s
                         t5                         Field to encode register t




80-N2040-36 B                                                                    372

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                 373

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Zero a cache line
                         Clear a 32-byte line in memory.

                         If the memory is marked write-back cacheable, the line is allocated in the data cache and
                         cleared.

                         If it is write-through or write-back, then the zero line is sent to memory.

                         This instruction is useful for efficiently handling write-only data by pre-allocating lines in
                         the cache.

                         The address should be 32-byte aligned. If not, an unaligned error exception is raised.

                         If these instruction appears in a packet, then slot 1 must be A-type or empty.

                                                Syntax                                                              Behavior
                         dczeroa(Rs)                                               EA=Rs;
                                                                                   dcache_zero_addr(EA);


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      A packet containing this instruction must have slot 1 either empty or executing an
                                        ALU32 instruction.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse
                                            N
1   0   1    0   0   0   0   0    1     1   0   s   s   s    s   s   P   P 0   -    -   -   -   -   -   -   -   -    -   -   -   -   dczeroa(Rs)




                           Field name                                                           Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         s5                         Field to encode register s
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                  374

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Memory barrier
                         Establish a memory barrier to ensure proper ordering between accesses before the barrier
                         instruction and accesses after the barrier instruction. All accesses before the barrier will be
                         globally observable before any access after the barrier can be observed.

                         The use of this instruction is system-dependent.

                                                Syntax                                                               Behavior
                         barrier                                                    memory_barrier;


                         Class: SYSTEM (slots 0)

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                               Parse
                                            N
1   0   1    0   1   0   0   0    0     0   0   -   -   -   -   -   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   barrier




                           Field name                                                            Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                   375

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Breakpoint
                          Cause the program to enter debug mode if enabled by ISDB. Execution control is handed
                          to ISDB and the program will not proceed until directed by the debugger.

                          If ISDB is disabled, this instruction is treated as a NOP.

                                              Syntax                                                               Behavior
                          brkpt                                                   Enter debug mode;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                      packet.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2   1   0
    ICLASS           sm                                           Parse
0   1   1    0   1   1    0   0   0   0   1   -   -   -   -   -   P   P   -   -    -   -   -   -   0   0   0   -    -   -   -   -   brkpt




                            Field name                                                         Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits




80-N2040-36 B                                                                 376

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Data cache prefetch
                         Prefetch the data at address Rs + unsigned immediate.

                         This instruction is a hint to the memory system, and is handled in an implementation-
                         dependent manner.

                                                Syntax                                                              Behavior
                         dcfetch(Rs)                                               Assembler mapped to: "dcfetch(Rs+#0)"
                         dcfetch(Rs+#u11:3)                                        EA=Rs+#u;
                                                                                   dcache_fetch(EA);


                         Class: SYSTEM (slots 0)

                         Intrinsics


                         dcfetch(Rs)                                               void Q6_dcfetch_A(Address a)


                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse
                                            N
1   0   0    1   0   1   0   0    0     0   0   s   s   s    s   s   P   P 0   -    -   i   i   i   i   i   i   i    i   i   i   i   dcfetch(Rs+#u11:3)




                           Field name                                                           Description
                         ICLASS                     Instruction Class
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned
                         Parse                      Packet/Loop parse bits
                         s5                         Field to encode register s




80-N2040-36 B                                                                  377

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Data cache maintenance user operations
                         Perform maintenance operations on the data cache.

                         dccleaninva looks up the data cache at address Rs. If this address is in the cache and has
                         dirty data, then the data is written back out to memory and the line is then invalidated.

                         dccleana looks up the data cache at address Rs. If this address is in the cache and has dirty
                         data, then the data is written back out to memory.

                         dcinva looks up the data cache at address Rs. If this address is in the cache, then the line
                         containing the data is invalidated.

                         If these instruction appears in a packet, then slot 1 must be A-type or empty.

                         In implementations that support L2 cache, these instructions operate on both L1 data and
                         L2 caches.

                                                Syntax                                                                Behavior
                         dccleana(Rs)                                                EA=Rs;
                                                                                     dcache_clean_addr(EA);
                         dccleaninva(Rs)                                             EA=Rs;
                                                                                     dcache_cleaninv_addr(EA);
                         dcinva(Rs)                                                  EA=Rs;
                                                                                     dcache_cleaninv_addr(EA);


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      A packet containing this instruction must have slot 1 either empty or executing an
                                        ALU32 instruction.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse
                                            N
1   0   1    0   0   0   0   0    0     0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   dccleana(Rs)
1   0   1    0   0   0   0   0    0     0   1   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   dcinva(Rs)
1   0   1    0   0   0   0   0    0     1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   dccleaninva(Rs)




                           Field name                                                             Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         s5                         Field to encode register s
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned



80-N2040-36 B                                                                    378

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



Instruction cache maintenance user operations
                         Look up the address in Rs in the instruction cache. If the address is found, invalidate the
                         corresponding cache line. If the user does not have proper permissions to the page which
                         is to be invalidated, the instruction is converted to a NOP.

                                             Syntax                                                              Behavior
                         icinva(Rs)                                             EA=Rs;
                                                                                icache_inv_addr(EA);


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                     packet.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                          8   7   6   5   4   3    2   1   0
    ICLASS                                           s5           Parse
0   1   0    1   0   1   1   0   1   1   0   s   s   s    s   s   P   P 0   0    0   -   -   -   -   -   -   -    -   -   -   -   icinva(Rs)




                           Field name                                                        Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits
                         s5                      Field to encode register s




80-N2040-36 B                                                               379

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                               Instruction Set



Instruction synchronization
                         Ensure that all prior instructions have committed before continuing to the next instruction.

                         This instruction should be executed after the following events (when subsequent
                         instructions need to observe the results of the event):
                                 ï®   After modifying the TLB with a tlbw instruction
                                 ï®   After modifying the SSR register
                                 ï®   After modifying the SYSCFG register
                                 ï®   After any instruction cache maintenance operation
                                 ï®   After modifying the TID register

                                             Syntax                                                             Behavior
                         isync                                                 instruction_sync;


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                     packet.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                         8   7   6   5   4   3   2   1   0
    ICLASS                                                       Parse
0   1   0    1   0   1   1   1   1   1   0   0   0   0   0   0   P   P 0   -    -   -   0   0   0   0   0   0   0   0   1   0   isync




                           Field name                                                       Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits




80-N2040-36 B                                                              380

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                           Instruction Set



L2 cache prefetch
                This instruction initiates background prefetching into the L2 cache.

                Rs specifies the 32-bit virtual start address.

                There are two forms of this instruction. In the first form, the dimensions of the area to
                prefetch are encoded in source register Rt as follows:

                Rt[15:8] = Width of a fetch block in bytes.

                Rt[7:0] = Height: the number of Width-sized blocks to fetch.

                Rt[31:16] = Stride: an unsigned byte offset which is used to increment the pointer after
                each Width-sized block is fetched.

                In the second form, the operands are encoded in register pair Rtt as follows:

                Rtt[31:16] = Width of a fetch block in bytes.

                Rtt[15:0] = Height: the number of Width-sized blocks to fetch.

                Rtt[47:32] = Stride: an unsigned byte offset which is used to increment the pointer after
                each Width-sized block is fetched.

                Rtt[48] = Direction: if clear, the prefetches should be performed in row major form
                meaning all cache lines in a row should be fetched before proceeding to the next row. If
                the bit is set, prefetch should be done in column major form, meaning all cache lines in a
                column are fetched before proceeding to the next column.

                The following figure shows two examples of using the l2fetch instruction. In the box
                prefetch, a 2-D range of memory is defined within a larger frame. The second example
                shows prefetch for a large linear area of memory, which has size Lines * 128.
                          L2FETCH for box prefetch                             L2FETCH for large linear prefetch

                     31                                                         31              16 15         8 7           0
                                    16 15       8 7           0

                Rt         Stride       Width        Height             Rt                128           128         Lines



                Rs             Start Address                            Rs                  Start Address



                                            Stride



                                     Width


                                    Prefetch
                      Height                                                 128* Lines
                                     Area




80-N2040-36 B                                                     381

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set




                                                Syntax                                                                 Behavior
                         l2fetch(Rs,Rt)                                              l2fetch(Rs,INFO);
                         l2fetch(Rs,Rtt)                                             l2fetch(Rs,INFO);

                         l2fetch is non-blocking. After the instruction is initiated, the program will continue on to
                         the next instruction while the prefetching is performed in the background. l2fetch can be
                         used to bring in either code or data to the L2 cache. If the lines of interest are already in the
                         L2, no action is performed. If the lines are missing from the L2$, the hardware attempts to
                         fetch them from the system memory.

                         The hardware prefetch engine continues to request all lines in the programmed memory
                         range. The prefetching hardware makes a best-effort to prefetch the requested data, and
                         attempts to perform prefetching at a lower priority than demand fetches. This prevents
                         prefetch from adding traffic while the system is under heavy load.

                         If a program initiates a new l2fetch while an older l2fetch operation is still pending, the
                         new request is queued, up to 3 deep. If 3 l2fetch operations are already pending, the oldest
                         request is dropped. During the time an L2 prefetch is active for a thread, the USR:PFA
                         status bit is set to indicate that prefetches are in-progress. This bit can be used by the
                         programmer to decide whether or not to start a new l2fetch before the previous one
                         completes. Note that because L2FETCH is uses low priority, it is not guaranteed to
                         complete in all cases.

                         Executing an l2fetch instruction with any subfield programmed as zero cancels all pending
                         prefetches by the calling thread.

                         The implementation is free to drop prefetches when needed.


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                        instructions.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                   s5           Parse                t5
                                            N
1   0   1    0   0   1   1   0    0     0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   -   -   -    -   -   -   -   l2fetch(Rs,Rt)
1   0   1    0   0   1   1   0    1     0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   -   -   -    -   -   -   -   l2fetch(Rs,Rtt)




                           Field name                                                              Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         s5                         Field to encode register s
                         t5                         Field to encode register t



80-N2040-36 B                                                                    382

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Amode          Amode
                Type           Type
                UN             Unsigned




80-N2040-36 B                                 383

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Pause
                         Pause execution for a specified period of time.

                         During the pause duration, the program enters a low-power state and will not fetch and
                         execute instructions. The instruction provides a short immediate which indicates the pause
                         duration. The program will pause for at most the number of cycles specified in the
                         immediate plus 8. The minimum pause is 0 cycles, and the maximum pause is
                         implementation-defined.

                         An interrupt to the program exits the paused state.

                         System events, such as HW or DMA completion, can trigger exits from pause mode.

                         An implementation is free to pause for durations shorter than (immediate+8), but not
                         longer.

                         This instruction is useful for implementing user-level low-power synchronization
                         operations, such as spin locks or wait-for-event signaling.

                                             Syntax                                                                Behavior
                         pause(#u8)                                              Pause for #u cycles;


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                     packet.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2   1   0
    ICLASS                                                       Parse
0   1   0    1   0   1   0   0   0   1   -   -   -   -   -   -   P   P   -   i     i   i   i   i   -   -   -   i    i   i   -   -   pause(#u8)




                           Field name                                                          Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits




80-N2040-36 B                                                                384

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Memory thread synchronization
                         Synchronizes memory.

                         All outstanding memory operations, including cached and uncached loads and stores, are
                         completed before the processor continues to the next instruction. This ensures that certain
                         memory operations are performed in the desired order (for example, when accessing I/O
                         devices).

                         After performing a syncht operation, the processor ceases fetching and executing
                         instructions from the program until all outstanding memory operations of that program are
                         completed.

                         In multithreaded or multicore environments, syncht is not concerned with other execution
                         contexts.

                         The use of this instruction is system-dependent.

                                                Syntax                                                               Behavior
                         syncht                                                     memory_synch;


                         Class: SYSTEM (slots 0)

                         Notes

                                 ï®      This is a solo instruction. It must not be grouped with other instructions in a
                                        packet.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3    2   1   0
                                            U
    ICLASS       Amode           Type                               Parse
                                            N
1   0   1    0   1   0   0   0    0     1   0   -   -   -   -   -   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   syncht




                           Field name                                                            Description
                         ICLASS                     Instruction Class
                         Parse                      Packet/Loop parse bits
                         Amode                      Amode
                         Type                       Type
                         UN                         Unsigned




80-N2040-36 B                                                                   385

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Send value to ETM trace
                          Take the value of register Rs and emit it to the ETM trace.

                          The ETM block must be enabled, and the thread must have permissions to perform
                          tracing. The contents of Rs are user-defined.

                                              Syntax                                                                Behavior
                          trace(Rs)                                                Send value to ETM trace;


                          Class: SYSTEM (slot 3)

                          Notes

                                  ï®   This instruction may only be grouped with ALU32 or non floating-point XTYPE
                                      instructions.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3    2   1   0
    ICLASS           sm                               s5           Parse
0   1   1    0   0   0    1   0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   -   -   -   -    -   -   -   -   trace(Rs)




                            Field name                                                          Description
                          sm                      Supervisor mode only
                          ICLASS                  Instruction Class
                          Parse                   Packet/Loop parse bits
                          s5                      Field to encode register s




80-N2040-36 B                                                                  386

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Trap
                         Cause a precise exception.

                         Executing a trap instruction sets the EX bit in SSR to 1, which disables interrupts and
                         enables supervisor mode. The program then jumps to the vector location (either trap0
                         location or trap1 location). The instruction specifies an 8-bit immediate field. This field is
                         copied into the system status register cause field.

                         Upon returning from the service routine with an rte instruction, execution resumes at the
                         packet after the trap instruction.

                         These instructions are generally intended for user code to request services from the
                         operating system. Two trap instructions are provided so the OS can optimize for fast
                         service routines and slower service routines.

                                             Syntax                                                                Behavior
                         trap0(#u8)                                              SSR.CAUSE = #u;
                                                                                 TRAP "0";
                         trap1(#u8)                                              SSR.CAUSE = #u;
                                                                                 TRAP "1";


                         Class: SYSTEM (slot 2)

                         Notes

                                 ï®   This is a solo instruction. It must not be grouped with other instructions in a
                                     packet.

                         Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3    2   1   0
    ICLASS                                                       Parse
0   1   0    1   0   1   0   0   0   0   -   -   -   -   -   -   P   P   -   i     i   i   i   i   -   -   -   i    i   i   -   -   trap0(#u8)
0   1   0    1   0   1   0   0   1   0   -   -   -   -   -   -   P   P   -   i     i   i   i   i   -   -   -   i    i   i   -   -   trap1(#u8)




                           Field name                                                          Description
                         ICLASS                  Instruction Class
                         Parse                   Packet/Loop parse bits




80-N2040-36 B                                                                387

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



        11.10 XTYPE
                          The XTYPE instruction class includes instructions which perform most of the data
                          processing done by the Hexagon processor.

                          XTYPE instructions are executable on slot 2 or slot 3.


    11.10.1 XTYPE/ALU
                          The XTYPE/ALU instruction subclass includes instructions which perform arithmetic and
                          logical operations.

Absolute value doubleword
                          Take the absolute value of the 64-bit source register and place it in the destination register.

                                               Syntax                                                                 Behavior
                          Rdd=abs(Rss)                                              Rdd = ABS(Rss);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=abs(Rss)                                              Word64 Q6_P_abs_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   0   d   d   d    d   d Rdd=abs(Rss)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   388

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Absolute value word
                          Take the absolute value of the source register and place it in the destination register.

                          The 32-bit absolute value is available with optional saturation. The single case of
                          saturation is if the source register is equal to 0x8000_0000, the destination saturates to
                          0x7fff_ffff.

                                               Syntax                                                                 Behavior
                          Rd=abs(Rs)[:sat]                                          Rd = [sat32](ABS(sxt32->64(Rs)));


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=abs(Rs)                                                Word32 Q6_R_abs_R(Word32 Rs)
                          Rd=abs(Rs):sat                                            Word32 Q6_R_abs_R_sat(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   1    1   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   0   d   d   d    d   d Rd=abs(Rs)
1   0   0    0   1    1   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   1   d   d   d    d   d Rd=abs(Rs):sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   389

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                              Instruction Set



Add and accumulate
                          Add Rs and Rt or a signed immediate, then add or subtract the resulting value. The result
                          is saved in Rx.

                                                   Syntax                                                                      Behavior
                          Rd=add(Rs,add(Ru,#s6))                                        Rd = Rs + Ru + apply_extension(#s);
                          Rd=add(Rs,sub(#s6,Ru))                                        Rd = Rs - Ru + apply_extension(#s);
                          Rx+=add(Rs,#s8)                                               apply_extension(#s);
                                                                                        Rx=Rx + Rs + #s;
                          Rx+=add(Rs,Rt)                                                Rx=Rx + Rs + Rt;
                          Rx-=add(Rs,#s8)                                               apply_extension(#s);
                                                                                        Rx=Rx - (Rs + #s);
                          Rx-=add(Rs,Rt)                                                Rx=Rx - (Rs + Rt);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=add(Rs,add(Ru,#s6))                                        Word32 Q6_R_add_add_RRI(Word32 Rs, Word32
                                                                                        Ru, Word32 Is6)
                          Rd=add(Rs,sub(#s6,Ru))                                        Word32 Q6_R_add_sub_RIR(Word32 Rs, Word32
                                                                                        Is6, Word32 Ru)
                          Rx+=add(Rs,#s8)                                               Word32 Q6_R_addacc_RI(Word32 Rx, Word32 Rs,
                                                                                        Word32 Is8)
                          Rx+=add(Rs,Rt)                                                Word32 Q6_R_addacc_RR(Word32 Rx, Word32 Rs,
                                                                                        Word32 Rt)
                          Rx-=add(Rs,#s8)                                               Word32 Q6_R_addnac_RI(Word32 Rx, Word32 Rs,
                                                                                        Word32 Is8)
                          Rx-=add(Rs,Rt)                                                Word32 Q6_R_addnac_RR(Word32 Rx, Word32 Rs,
                                                                                        Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7    6    5     4   3   2    1   0
    ICLASS           RegType                               s5           Parse                 d5                                   u5
1   1   0    1   1    0   1    1   0     i     i   s   s   s    s   s   P   P   i   d    d    d    d   d   i     i     i   u   u   u    u   u Rd=add(Rs,add(Ru,#s6))
1   1   0    1   1    0   1    1   1     i     i   s   s   s    s   s   P   P   i   d    d    d    d   d   i     i     i   u   u   u    u   u Rd=add(Rs,sub(#s6,Ru))
    ICLASS           RegType           MajOp               s5           Parse                                  MinOp               x5
1   1   1    0   0    0   1    0   0     -     -   s   s   s    s   s   P   P 0     i     i   i    i   i   i     i     i   x   x   x    x   x Rx+=add(Rs,#s8)
1   1   1    0   0    0   1    0   1     -     -   s   s   s    s   s   P   P 0     i     i   i    i   i   i     i     i   x   x   x    x   x Rx-=add(Rs,#s8)
    ICLASS           RegType           MajOp               s5           Parse                 t5               MinOp               x5
1   1   1    0   1    1   1    1   0    0    0     s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    1     x   x   x    x   x Rx+=add(Rs,Rt)
1   1   1    0   1    1   1    1   1    0    0     s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    1     x   x   x    x   x Rx-=add(Rs,Rt)




80-N2040-36 B                                                                       390

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                ICLASS         Instruction Class
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                u5             Field to encode register u
                x5             Field to encode register x




80-N2040-36 B                                       391

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Add doublewords
                The first form of this instruction adds two 32-bit registers. If the result overflows 32 bits,
                the result is saturated to 0x7FFF_FFFF for a positive result, or 0x8000_0000 for a
                negative result. Note that 32-bit non-saturating register add is a ALU32-class instruction
                and can be executed on any slot.

                The second instruction form sign-extends a 32-bit register Rt to 64-bits and performs a 64-
                bit add with Rss. The result is stored in Rdd.

                The third instruction form adds 64-bit registers Rss and Rtt and places the result in Rdd.

                The final instruction form adds two 64-bit registers Rss and Rtt. If the result overflows 64
                bits, it is saturated to 0x7fff_ffff_ffff_ffff for a positive result, or
                0x8000_0000_0000_0000 for a negative result.

                               Syntax                                         Behavior
                Rd=add(Rs,Rt):sat:deprecated Rd=sat32(Rs+Rt);
                Rdd=add(Rs,Rtt)                       if ("Rs & 1") {
                                                          Assembler mapped to:
                                                      "Rdd=add(Rss,Rtt):raw:hi";
                                                      } else {
                                                          Assembler mapped to:
                                                      "Rdd=add(Rss,Rtt):raw:lo";
                                                      };
                Rdd=add(Rss,Rtt)                      Rdd=Rss+Rtt;
                Rdd=add(Rss,Rtt):raw:hi               Rdd=Rtt+sxt32->64(Rss.w[1]);
                Rdd=add(Rss,Rtt):raw:lo               Rdd=Rtt+sxt32->64(Rss.w[0]);
                Rdd=add(Rss,Rtt):sat                  Rdd=sat64(Rss+Rtt);


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), the OVF bit in the Status Register is set.
                         OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rdd=add(Rs,Rtt)                       Word64 Q6_P_add_RP(Word32 Rs, Word64 Rtt)
                Rdd=add(Rss,Rtt)                      Word64 Q6_P_add_PP(Word64 Rss, Word64 Rtt)
                Rdd=add(Rss,Rtt):sat                  Word64 Q6_P_add_PP_sat(Word64 Rss, Word64
                                                      Rtt)




80-N2040-36 B                                        392

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6    5     4   3   2    1   0
    ICLASS           RegType                           s5           Parse               t5               MinOp               d5
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1    1    1     d   d   d    d   d Rdd=add(Rss,Rtt)
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1    0    1     d   d   d    d   d Rdd=add(Rss,Rtt):sat
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1    1    0     d   d   d    d   d Rdd=add(Rss,Rtt):raw:lo
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1    1    1     d   d   d    d   d Rdd=add(Rss,Rtt):raw:hi
1   1   0    1   0    1   0    1   1   0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0     -     -   d   d   d    d   d Rd=add(Rs,Rt):sat:deprecated




                            Field name                                                           Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   393

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Add halfword
                Perform a 16-bit add with optional saturation, and place the result in either the upper or
                lower half of a register. If the result goes in the upper half, the sources can be any high or
                low halfword of Rs and Rt. The lower 16 bits of the result are zeroed.

                If the result is to be placed in the lower 16 bits of Rd, the Rs source can be either high or
                low, but the other source must be the low halfword of Rt. In this case, the upper halfword
                of Rd is the sign-extension of the low halfword.


                                         Rd=add(Rs.[hl],Rt.[hl])[:sat]

                         Rs.H            Rs.L          Rs              Rt.H           Rt.L         Rt


                                 Mux                                           Mux



                                                            16-bit Add
                                                     0x7FFF           0x8000

                                                            Saturate



                                       Sign-extend           Result            Rd


                            Syntax                                              Behavior
          Rd=add(Rt.L,Rs.[HL])[:sat]                   Rd=[sat16](Rt.h[0]+Rs.h[01]);
          Rd=add(Rt.[HL],Rs.[HL])[:sat]:<<16 Rd=([sat16](Rt.h[01]+Rs.h[01]))<<16;


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), the OVF bit in the Status Register is set.
                         OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                         394

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Intrinsics

                          Rd=add(Rt.H,Rs.H):<<16                                    Word32 Q6_R_add_RhRh_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=add(Rt.H,Rs.H):sat:<<16                                Word32 Q6_R_add_RhRh_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)
                          Rd=add(Rt.H,Rs.L):<<16                                    Word32 Q6_R_add_RhRl_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=add(Rt.H,Rs.L):sat:<<16                                Word32 Q6_R_add_RhRl_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)
                          Rd=add(Rt.L,Rs.H)                                         Word32 Q6_R_add_RlRh(Word32 Rt, Word32 Rs)
                          Rd=add(Rt.L,Rs.H):<<16                                    Word32 Q6_R_add_RlRh_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=add(Rt.L,Rs.H):sat                                     Word32 Q6_R_add_RlRh_sat(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=add(Rt.L,Rs.H):sat:<<16                                Word32 Q6_R_add_RlRh_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)
                          Rd=add(Rt.L,Rs.L)                                         Word32 Q6_R_add_RlRl(Word32 Rt, Word32 Rs)
                          Rd=add(Rt.L,Rs.L):<<16                                    Word32 Q6_R_add_RlRl_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=add(Rt.L,Rs.L):sat                                     Word32 Q6_R_add_RlRl_sat(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=add(Rt.L,Rs.L):sat:<<16                                Word32 Q6_R_add_RlRl_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5      4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp               d5
1   1   0    1   0    1   0    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0      -   d   d   d    d   d Rd=add(Rt.L,Rs.L)
1   1   0    1   0    1   0    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1      -   d   d   d    d   d Rd=add(Rt.L,Rs.H)
1   1   0    1   0    1   0    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0      -   d   d   d    d   d Rd=add(Rt.L,Rs.L):sat
1   1   0    1   0    1   0    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1      -   d   d   d    d   d Rd=add(Rt.L,Rs.H):sat
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0      d   d   d    d   d Rd=add(Rt.L,Rs.L):<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1      d   d   d    d   d Rd=add(Rt.L,Rs.H):<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0      d   d   d    d   d Rd=add(Rt.H,Rs.L):<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   1      d   d   d    d   d Rd=add(Rt.H,Rs.H):<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0      d   d   d    d   d Rd=add(Rt.L,Rs.L):sat:<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   1      d   d   d    d   d Rd=add(Rt.L,Rs.H):sat:<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   0      d   d   d    d   d Rd=add(Rt.H,Rs.L):sat:<<16
1   1   0    1   0    1   0    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   1      d   d   d    d   d Rd=add(Rt.H,Rs.H):sat:<<16



80-N2040-36 B                                                                   395

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                MinOp          Minor Opcode
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       396

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                            Instruction Set



Add or subtract doublewords with carry
                          Add or subtract with carry. Predicate register Px is used as an extra input and output.

                          For adds, the LSB of the predicate is added to the sum of the two input pairs.

                          For subtracts, the predicate is considered a not-borrow. The LSB of the predicate is added
                          to the first source register and the logical complement of the second argument.

                          The carry-out from the sum is saved in predicate Px.

                          These instructions allow efficient addition or subtraction of numbers larger than 64 bits.

                                                 Syntax                                                                      Behavior
                          Rdd=add(Rss,Rtt,Px):carry                                   Rdd = Rss + Rtt + Px[0];
                                                                                      Px = carry_from_add(Rss,Rtt,Px[0]) ? 0xff :
                                                                                      0x00;
                          Rdd=sub(Rss,Rtt,Px):carry                                   Rdd = Rss + ~Rtt + Px[0];
                                                                                      Px = carry_from_add(Rss,~Rtt,Px[0]) ? 0xff
                                                                                      : 0x00;


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®     The predicate generated by this instruction can not be used as a .new predicate,
                                         nor can it be automatically ANDed with another predicate.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6        5   4   3   2    1   0
    ICLASS           RegType           Maj               s5           Parse                t5                   x2               d5
1   1   0    0   0    0   1    0   1     1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   x        x   d   d   d    d   d Rdd=add(Rss,Rtt,Px):carry
1   1   0    0   0    0   1    0   1     1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   x        x   d   d   d    d   d Rdd=sub(Rss,Rtt,Px):carry




                            Field name                                                              Description
                          ICLASS                     Instruction Class
                          Parse                      Packet/Loop parse bits
                          d5                         Field to encode register d
                          s5                         Field to encode register s
                          t5                         Field to encode register t
                          x2                         Field to encode register x
                          Maj                        Major Opcode
                          Min                        Minor Opcode
                          RegType                    Register Type




80-N2040-36 B                                                                     397

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Logical doublewords
                          Perform bitwise logical AND, OR, XOR, and NOT operations.

                          The source and destination registers are 64-bit.

                          For 32-bit logical operations, see the ALU32 logical instructions.

                                               Syntax                                                                  Behavior
                          Rdd=and(Rss,Rtt)                                          Rdd=Rss&Rtt;
                          Rdd=and(Rtt,~Rss)                                         Rdd = (Rtt & ~Rss);
                          Rdd=not(Rss)                                              Rdd=~Rss;
                          Rdd=or(Rss,Rtt)                                           Rdd=Rss|Rtt;
                          Rdd=or(Rtt,~Rss)                                          Rdd = (Rtt | ~Rss);
                          Rdd=xor(Rss,Rtt)                                          Rdd=Rss^Rtt;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=and(Rss,Rtt)                                          Word64 Q6_P_and_PP(Word64 Rss, Word64 Rtt)
                          Rdd=and(Rtt,~Rss)                                         Word64 Q6_P_and_PnP(Word64 Rtt, Word64 Rss)
                          Rdd=not(Rss)                                              Word64 Q6_P_not_P(Word64 Rss)
                          Rdd=or(Rss,Rtt)                                           Word64 Q6_P_or_PP(Word64 Rss, Word64 Rtt)
                          Rdd=or(Rtt,~Rss)                                          Word64 Q6_P_or_PnP(Word64 Rtt, Word64 Rss)
                          Rdd=xor(Rss,Rtt)                                          Word64 Q6_P_xor_PP(Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   0    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -    -   -   1    0   0   d   d   d    d   d Rdd=not(Rss)
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=and(Rss,Rtt)
1   1   0    1   0    0   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=and(Rtt,~Rss)
1   1   0    1   0    0   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0   d   d   d    d   d Rdd=or(Rss,Rtt)
1   1   0    1   0    0   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   1   d   d   d    d   d Rdd=or(Rtt,~Rss)
1   1   0    1   0    0   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0   d   d   d    d   d Rdd=xor(Rss,Rtt)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits



80-N2040-36 B                                                                   398

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       399

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Logical-logical doublewords
                          Perform a logical operation of the two source operands, then perform a second logical
                          operation of the result with the destination register Rxx.

                          The source and destination registers are 64-bit.

                                               Syntax                                                               Behavior
                          Rxx^=xor(Rss,Rtt)                                       Rxx^=Rss^Rtt;


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rxx^=xor(Rss,Rtt)                                       Word64 Q6_P_xorxacc_PP(Word64 Rxx, Word64
                                                                                  Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse              t5           Min                 x5
1   1   0    0   1    0   1    0   1   0   -   s   s   s    s   s   P   P 0   t    t   t    t   t   0   0   0   x   x   x    x   x Rxx^=xor(Rss,Rtt)




                            Field name                                                          Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          x5                       Field to encode register x
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                 400

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



Logical-logical words
                Perform a logical operation of the two source operands, then perform a second logical
                operation of the result with the destination register Rx.

                The source and destination registers are 32-bit.

                               Syntax                                     Behavior
                Rx=or(Ru,and(Rx,#s10))               Rx = Ru | (Rx & apply_extension(#s));
                Rx[&|^]=and(Rs,Rt)                   Rx [|&^]= (Rs [|&^] Rt);
                Rx[&|^]=and(Rs,~Rt)                  Rx [|&^]= (Rs [|&^] ~Rt);
                Rx[&|^]=or(Rs,Rt)                    Rx [|&^]= (Rs [|&^] Rt);
                Rx[&|^]=xor(Rs,Rt)                   Rx[|&^]=Rs[|&^]Rt;
                Rx|=and(Rs,#s10)                     Rx = Rx | (Rs & apply_extension(#s));
                Rx|=or(Rs,#s10)                      Rx = Rx | (Rs | apply_extension(#s));


                Class: XTYPE (slots 2,3)

                Intrinsics


                Rx&=and(Rs,Rt)                       Word32 Q6_R_andand_RR(Word32 Rx, Word32 Rs,
                                                     Word32 Rt)
                Rx&=and(Rs,~Rt)                      Word32 Q6_R_andand_RnR(Word32 Rx, Word32
                                                     Rs, Word32 Rt)
                Rx&=or(Rs,Rt)                        Word32 Q6_R_orand_RR(Word32 Rx, Word32 Rs,
                                                     Word32 Rt)
                Rx&=xor(Rs,Rt)                       Word32 Q6_R_xorand_RR(Word32 Rx, Word32 Rs,
                                                     Word32 Rt)
                Rx=or(Ru,and(Rx,#s10))               Word32 Q6_R_or_and_RRI(Word32 Ru, Word32
                                                     Rx, Word32 Is10)
                Rx^=and(Rs,Rt)                       Word32 Q6_R_andxacc_RR(Word32 Rx, Word32
                                                     Rs, Word32 Rt)
                Rx^=and(Rs,~Rt)                      Word32 Q6_R_andxacc_RnR(Word32 Rx, Word32
                                                     Rs, Word32 Rt)
                Rx^=or(Rs,Rt)                        Word32 Q6_R_orxacc_RR(Word32 Rx, Word32 Rs,
                                                     Word32 Rt)
                Rx^=xor(Rs,Rt)                       Word32 Q6_R_xorxacc_RR(Word32 Rx, Word32
                                                     Rs, Word32 Rt)
                Rx|=and(Rs,#s10)                     Word32 Q6_R_andor_RI(Word32 Rx, Word32 Rs,
                                                     Word32 Is10)




80-N2040-36 B                                       401

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                              Instruction Set



                          Rx|=and(Rs,Rt)                                                Word32 Q6_R_andor_RR(Word32 Rx, Word32 Rs,
                                                                                        Word32 Rt)
                          Rx|=and(Rs,~Rt)                                               Word32 Q6_R_andor_RnR(Word32 Rx, Word32 Rs,
                                                                                        Word32 Rt)
                          Rx|=or(Rs,#s10)                                               Word32 Q6_R_oror_RI(Word32 Rx, Word32 Rs,
                                                                                        Word32 Is10)
                          Rx|=or(Rs,Rt)                                                 Word32 Q6_R_oror_RR(Word32 Rx, Word32 Rs,
                                                                                        Word32 Rt)
                          Rx|=xor(Rs,Rt)                                                Word32 Q6_R_xoror_RR(Word32 Rx, Word32 Rs,
                                                                                        Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7    6    5     4   3   2    1   0
    ICLASS           RegType                               s5           Parse                                                      x5
1   1   0    1   1    0   1    0   0    0      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i     i     i   x   x   x    x   x Rx|=and(Rs,#s10)
    ICLASS           RegType                               x5           Parse                                                      u5
1   1   0    1   1    0   1    0   0    1      i   x   x   x    x   x   P   P   i   i     i   i    i   i   i     i     i   u   u   u    u   u Rx=or(Ru,and(Rx,#s10))
    ICLASS           RegType                               s5           Parse                                                      x5
1   1   0    1   1    0   1    0   1    0      i   s   s   s    s   s   P   P   i   i     i   i    i   i   i     i     i   x   x   x    x   x Rx|=or(Rs,#s10)
    ICLASS           RegType           MajOp               s5           Parse                 t5               MinOp               x5
1   1   1    0   1    1   1    1   0    0   1      s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    0     x   x   x    x   x Rx|=and(Rs,~Rt)
1   1   1    0   1    1   1    1   0    0   1      s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    1     x   x   x    x   x Rx&=and(Rs,~Rt)
1   1   1    0   1    1   1    1   0    0   1      s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    0     x   x   x    x   x Rx^=and(Rs,~Rt)
1   1   1    0   1    1   1    1   0    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    0     x   x   x    x   x Rx&=and(Rs,Rt)
1   1   1    0   1    1   1    1   0    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    1     x   x   x    x   x Rx&=or(Rs,Rt)
1   1   1    0   1    1   1    1   0    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    0     x   x   x    x   x Rx&=xor(Rs,Rt)
1   1   1    0   1    1   1    1   0    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    1     x   x   x    x   x Rx|=and(Rs,Rt)
1   1   1    0   1    1   1    1   1    0   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    1     x   x   x    x   x Rx^=xor(Rs,Rt)
1   1   1    0   1    1   1    1   1    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    0     x   x   x    x   x Rx|=or(Rs,Rt)
1   1   1    0   1    1   1    1   1    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    1     x   x   x    x   x Rx|=xor(Rs,Rt)
1   1   1    0   1    1   1    1   1    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    0     x   x   x    x   x Rx^=and(Rs,Rt)
1   1   1    0   1    1   1    1   1    1   0      s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    1     x   x   x    x   x Rx^=or(Rs,Rt)




                            Field name                                                                 Description
                          RegType                      Register Type
                          ICLASS                       Instruction Class
                          MajOp                        Major Opcode
                          MinOp                        Minor Opcode
                          RegType                      Register Type
                          Parse                        Packet/Loop parse bits
                          s5                           Field to encode register s
                          t5                           Field to encode register t
                          u5                           Field to encode register u
                          x5                           Field to encode register x




80-N2040-36 B                                                                       402

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Maximum words
                          Select either the signed or unsigned maximum of two source registers and place in a
                          destination register Rdd.

                                               Syntax                                                                     Behavior
                          Rd=max(Rs,Rt)                                             Rd = max(Rs,Rt);
                          Rd=maxu(Rs,Rt)                                            Rd = max(Rs.uw[0],Rt.uw[0]);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=max(Rs,Rt)                                             Word32 Q6_R_max_RR(Word32 Rs, Word32 Rt)
                          Rd=maxu(Rs,Rt)                                            UWord32 Q6_R_maxu_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6    5     4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp               d5
1   1   0    1   0    1   0    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0     -     -   d   d   d    d   d Rd=max(Rs,Rt)
1   1   0    1   0    1   0    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1     -     -   d   d   d    d   d Rd=maxu(Rs,Rt)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   403

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Maximum doublewords
                          Select either the signed or unsigned maximum of two 64-bit source registers and place in a
                          destination register.

                                               Syntax                                                                  Behavior
                          Rdd=max(Rss,Rtt)                                          Rdd = max(Rss,Rtt);
                          Rdd=maxu(Rss,Rtt)                                         Rdd = max(Rss.u64,Rtt.u64);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=max(Rss,Rtt)                                          Word64 Q6_P_max_PP(Word64 Rss, Word64 Rtt)
                          Rdd=maxu(Rss,Rtt)                                         UWord64 Q6_P_maxu_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0   d   d   d    d   d Rdd=max(Rss,Rtt)
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=maxu(Rss,Rtt)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   404

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Minimum words
                          Select either the signed or unsigned minimum of two source registers and place in
                          destination register Rd.

                                               Syntax                                                                     Behavior
                          Rd=min(Rt,Rs)                                             Rd = min(Rt,Rs);
                          Rd=minu(Rt,Rs)                                            Rd = min(Rt.uw[0],Rs.uw[0]);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=min(Rt,Rs)                                             Word32 Q6_R_min_RR(Word32 Rt, Word32 Rs)
                          Rd=minu(Rt,Rs)                                            UWord32 Q6_R_minu_RR(Word32 Rt, Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6    5     4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp               d5
1   1   0    1   0    1   0    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0     -     -   d   d   d    d   d Rd=min(Rt,Rs)
1   1   0    1   0    1   0    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1     -     -   d   d   d    d   d Rd=minu(Rt,Rs)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   405

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Minimum doublewords
                          Select either the signed or unsigned minimum of two 64-bit source registers and place in
                          the destination register Rdd.

                                               Syntax                                                                  Behavior
                          Rdd=min(Rtt,Rss)                                          Rdd = min(Rtt,Rss);
                          Rdd=minu(Rtt,Rss)                                         Rdd = min(Rtt.u64,Rss.u64);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=min(Rtt,Rss)                                          Word64 Q6_P_min_PP(Word64 Rtt, Word64 Rss)
                          Rdd=minu(Rtt,Rss)                                         UWord64 Q6_P_minu_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   0   d   d   d    d   d Rdd=min(Rtt,Rss)
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   1   d   d   d    d   d Rdd=minu(Rtt,Rss)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   406

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Modulo wrap
                          Wrap the Rs value into the modulo range from 0 to Rt.

                          If Rs is greater than or equal to Rt, wrap it to the bottom of the range by subtracting Rt.

                          If Rs is less than zero, wrap it to the top of the range by adding Rt.

                          Otherwise, when Rs fits within the range, no adjustment is necessary. The result is
                          returned in register Rd.

                                               Syntax                                                                  Behavior
                          Rd=modwrap(Rs,Rt)                                         if (Rs        < 0) {
                                                                                        Rd        = Rs + Rt.uw[0];
                                                                                    } else        if (Rs.uw[0] >= Rt.uw[0]) {
                                                                                        Rd        = Rs - Rt.uw[0];
                                                                                    } else        {
                                                                                        Rd        = Rs;
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=modwrap(Rs,Rt)                                         Word32 Q6_R_modwrap_RR(Word32 Rs, Word32
                                                                                    Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   1   d   d   d    d   d Rd=modwrap(Rs,Rt)




                            Field name                                                             Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   407

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Negate
                          The first form of this instruction performs a negate on a 32-bit register with saturation. If
                          the input is 0x80000000, the result is saturated to 0x7fffffff. Note that the non-saturating
                          32-bit register negate is a ALU32-class instruction and can be executed on any slot.

                          The second form of this instruction negates a 64-bit source register and place the result in
                          destination Rdd.

                                               Syntax                                                                 Behavior
                          Rd=neg(Rs):sat                                            Rd = sat32(-Rs.s64);
                          Rdd=neg(Rss)                                              Rdd = -Rss;


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=neg(Rs):sat                                            Word32 Q6_R_neg_R_sat(Word32 Rs)
                          Rdd=neg(Rss)                                              Word64 Q6_P_neg_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   1   d   d   d    d   d Rdd=neg(Rss)
1   0   0    0   1    1   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   0   d   d   d    d   d Rd=neg(Rs):sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   408

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Round
                Perform either arithmetic (.5 is rounded up) or convergent (.5 is rounded towards even)
                rounding to any bit location.

                Arithmetic rounding has optional saturation. In this version, the result is saturated to a 32-
                bit number after adding the rounding constant. After the rounding and saturation have
                been performed, the final result is right shifted using a sign-extending shift.

                               Syntax                                        Behavior
                Rd=cround(Rs,#u5)                     Rd = (#u==0)?Rs:convround(Rs,2**(#u-
                                                      1))>>#u;
                Rd=cround(Rs,Rt)                      Rd = (zxt5-
                                                      >32(Rt)==0)?Rs:convround(Rs,2**(zxt5-
                                                      >32(Rt)-1))>>zxt5->32(Rt);

                Rd=round(Rs,#u5)[:sat]                Rd = ([sat32]((#u==0)?(Rs):round(Rs,2**(#u-
                                                      1))))>>#u;
                Rd=round(Rs,Rt)[:sat]                 Rd = ([sat32]((zxt5-
                                                      >32(Rt)==0)?(Rs):round(Rs,2**(zxt5->32(Rt)-
                                                      1))))>>zxt5->32(Rt);
                Rd=round(Rss):sat                     tmp=sat64(Rss+0x080000000ULL);
                                                      Rd = tmp.w[1];


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), the OVF bit in the Status Register is set.
                         OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rd=cround(Rs,#u5)                     Word32 Q6_R_cround_RI(Word32 Rs, Word32
                                                      Iu5)
                Rd=cround(Rs,Rt)                      Word32 Q6_R_cround_RR(Word32 Rs, Word32 Rt)
                Rd=round(Rs,#u5)                      Word32 Q6_R_round_RI(Word32 Rs, Word32 Iu5)
                Rd=round(Rs,#u5):sat                  Word32 Q6_R_round_RI_sat(Word32 Rs, Word32
                                                      Iu5)
                Rd=round(Rs,Rt)                       Word32 Q6_R_round_RR(Word32 Rs, Word32 Rt)
                Rd=round(Rs,Rt):sat                   Word32 Q6_R_round_RR_sat(Word32 Rs, Word32
                                                      Rt)
                Rd=round(Rss):sat                     Word32 Q6_R_round_P_sat(Word64 Rss)




80-N2040-36 B                                       409

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5      4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                  MinOp               d5
1   0   0    0   1    0   0    0   1   1   0   s   s   s    s   s   P   P   -   -   -     -    -   -   0    0   1      d   d   d    d   d Rd=round(Rss):sat
1   0   0    0   1    1   0    0   1   1   1   s   s   s    s   s   P   P 0     i     i   i    i   i   0    0      -   d   d   d    d   d Rd=cround(Rs,#u5)
1   0   0    0   1    1   0    0   1   1   1   s   s   s    s   s   P   P 0     i     i   i    i   i   1    0      -   d   d   d    d   d Rd=round(Rs,#u5)
1   0   0    0   1    1   0    0   1   1   1   s   s   s    s   s   P   P 0     i     i   i    i   i   1    1      -   d   d   d    d   d Rd=round(Rs,#u5):sat
    ICLASS           RegType        Maj                s5           Parse                 t5           Min                     d5
1   1   0    0   0    1   1    0   1   1   -   s   s   s    s   s   P   P   -   t   t     t    t   t   0    0      -   d   d   d    d   d Rd=cround(Rs,Rt)
1   1   0    0   0    1   1    0   1   1   -   s   s   s    s   s   P   P   -   t   t     t    t   t   1    0      -   d   d   d    d   d Rd=round(Rs,Rt)
1   1   0    0   0    1   1    0   1   1   -   s   s   s    s   s   P   P   -   t   t     t    t   t   1    1      -   d   d   d    d   d Rd=round(Rs,Rt):sat




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type
                          RegType                  Register Type




80-N2040-36 B                                                                   410

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



Subtract doublewords
                          Subtract the 64-bit register Rss from register Rtt.

                                               Syntax                                                                     Behavior
                          Rd=sub(Rt,Rs):sat:deprecated Rd=sat32(Rt - Rs);
                          Rdd=sub(Rtt,Rss)                                          Rdd=Rtt-Rss;


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=sub(Rtt,Rss)                                          Word64 Q6_P_sub_PP(Word64 Rtt, Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6    5     4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp               d5
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1    1     d   d   d    d   d Rdd=sub(Rtt,Rss)

1   1   0    1   0    1   0    1   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1     -     -   d   d   d    d   d Rd=sub(Rt,Rs):sat:deprecated




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   411

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Subtract and accumulate words
                          Subtract Rs from Rt, then add the resulting value with Rx. The result is saved in Rx.

                                                Syntax                                                                Behavior
                          Rx+=sub(Rt,Rs)                                           Rx=Rx + Rt - Rs;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rx+=sub(Rt,Rs)                                           Word32 Q6_R_subacc_RR(Word32 Rx, Word32 Rt,
                                                                                   Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            x5
1   1   1    0   1    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    1   1   x   x   x    x   x Rx+=sub(Rt,Rs)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  412

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                              Instruction Set



Subtract halfword
                  Perform a 16-bit subtract with optional saturation and place the result in either the upper or
                  lower half of a register. If the result goes in the upper half, then the sources can be any
                  high or low halfword of Rs and Rt. The lower 16 bits of the result are zeroed.

                  If the result is to be placed in the lower 16 bits of Rd, then the Rs source can be either high
                  or low, but the other source must be the low halfword of Rt. In this case, the upper
                  halfword of Rd is the sign-extension of the low halfword.


                Rd=sub(Rt.[hl],Rs.l)[:sat]                                     Rd=sub(Rt.[hl],Rs.[hl])[:sat]:<<16

        Rt.H                Rt.L             Rt                            Rt.H               Rt.L             Rt


                   Mux                                 Rs                             Mux                                   Rs

                                    Rs.H           Rs.L                                               Rs.H               Rs.L


                                                                                                                Mux



                      16-bit Sub                                                         16-bit Sub
                 0x7FFF             0x8000                                          0x7FFF            0x8000

                       Saturate                                                          Saturate



    Sign-extend            Result            Rd                                              Result            0x0000           Rd


                               Syntax                                             Behavior
          Rd=sub(Rt.L,Rs.[HL])[:sat]                      Rd=[sat16](Rt.h[0]-Rs.h[01]);
          Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<<16 Rd=([sat16](Rt.h[01]-Rs.h[01]))<<16;


                  Class: XTYPE (slots 2,3)

                  Notes

                       ï®    If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                          413

                   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Intrinsics

                          Rd=sub(Rt.H,Rs.H):<<16                                    Word32 Q6_R_sub_RhRh_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=sub(Rt.H,Rs.H):sat:<<16                                Word32 Q6_R_sub_RhRh_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)
                          Rd=sub(Rt.H,Rs.L):<<16                                    Word32 Q6_R_sub_RhRl_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=sub(Rt.H,Rs.L):sat:<<16                                Word32 Q6_R_sub_RhRl_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)
                          Rd=sub(Rt.L,Rs.H)                                         Word32 Q6_R_sub_RlRh(Word32 Rt, Word32 Rs)
                          Rd=sub(Rt.L,Rs.H):<<16                                    Word32 Q6_R_sub_RlRh_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=sub(Rt.L,Rs.H):sat                                     Word32 Q6_R_sub_RlRh_sat(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=sub(Rt.L,Rs.H):sat:<<16                                Word32 Q6_R_sub_RlRh_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)
                          Rd=sub(Rt.L,Rs.L)                                         Word32 Q6_R_sub_RlRl(Word32 Rt, Word32 Rs)
                          Rd=sub(Rt.L,Rs.L):<<16                                    Word32 Q6_R_sub_RlRl_s16(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=sub(Rt.L,Rs.L):sat                                     Word32 Q6_R_sub_RlRl_sat(Word32 Rt, Word32
                                                                                    Rs)
                          Rd=sub(Rt.L,Rs.L):sat:<<16                                Word32 Q6_R_sub_RlRl_sat_s16(Word32 Rt,
                                                                                    Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5      4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp               d5
1   1   0    1   0    1   0    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0      -   d   d   d    d   d Rd=sub(Rt.L,Rs.L)
1   1   0    1   0    1   0    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1      -   d   d   d    d   d Rd=sub(Rt.L,Rs.H)
1   1   0    1   0    1   0    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0      -   d   d   d    d   d Rd=sub(Rt.L,Rs.L):sat
1   1   0    1   0    1   0    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1      -   d   d   d    d   d Rd=sub(Rt.L,Rs.H):sat
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0      d   d   d    d   d Rd=sub(Rt.L,Rs.L):<<16
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1      d   d   d    d   d Rd=sub(Rt.L,Rs.H):<<16
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0      d   d   d    d   d Rd=sub(Rt.H,Rs.L):<<16
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   1      d   d   d    d   d Rd=sub(Rt.H,Rs.H):<<16
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0      d   d   d    d   d Rd=sub(Rt.L,Rs.L):sat:<<16
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   1      d   d   d    d   d Rd=sub(Rt.L,Rs.H):sat:<<16
1   1   0    1   0    1   0    1   0   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   0      d   d   d    d   d Rd=sub(Rt.H,Rs.L):sat:<<16
1   1   0    1   0    1   0    1   0   1   1  s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   1      d   d   d    d   d Rd=sub(Rt.H,Rs.H):sat:<<16



80-N2040-36 B                                                                   414

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                MinOp          Minor Opcode
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       415

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Sign extend word to doubleword
                          Sign-extend a 32-bit word to a 64-bit doubleword.

                                               Syntax                                                                    Behavior
                          Rdd=sxtw(Rs)                                              Rdd = sxt32->64(Rs);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=sxtw(Rs)                                              Word64 Q6_P_sxtw_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5      4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp               d5
1   0   0    0   0    1   0    0   0   1   -   s   s   s    s   s   P   P   -   -    -   -   -   -   0    0      -   d   d   d    d   d Rdd=sxtw(Rs)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   416

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector absolute value halfwords
                          Take the absolute value of each of the four halfwords in the 64-bit source vector Rss. Place
                          the result in Rdd.

                          Saturation is optionally available.

                                               Syntax                                                                 Behavior
                          Rdd=vabsh(Rss)                                            for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=ABS(Rss.h[i]);
                                                                                    };
                          Rdd=vabsh(Rss):sat                                        for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=sat16(ABS(Rss.h[i]));
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vabsh(Rss)                                            Word64 Q6_P_vabsh_P(Word64 Rss)
                          Rdd=vabsh(Rss):sat                                        Word64 Q6_P_vabsh_P_sat(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   0   d   d   d    d   d Rdd=vabsh(Rss)
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   1   d   d   d    d   d Rdd=vabsh(Rss):sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   417

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Vector absolute value words
                          Take the absolute value of each of the two words in the 64-bit source vector Rss. Place the
                          result in Rdd.

                          Saturation is optionally available.

                                               Syntax                                                                 Behavior
                          Rdd=vabsw(Rss)                                            for (i=0;i<2;i++) {
                                                                                        Rdd.w[i]=ABS(Rss.w[i]);
                                                                                    };
                          Rdd=vabsw(Rss):sat                                        for (i=0;i<2;i++) {
                                                                                        Rdd.w[i]=sat32(ABS(Rss.w[i]));
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vabsw(Rss)                                            Word64 Q6_P_vabsw_P(Word64 Rss)
                          Rdd=vabsw(Rss):sat                                        Word64 Q6_P_vabsw_P_sat(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   0   d   d   d    d   d Rdd=vabsw(Rss)
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   1   d   d   d    d   d Rdd=vabsw(Rss):sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   418

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector absolute difference bytes
                          For each element in the source vector Rss, subtract the corresponding element in source
                          vector Rtt. Take the absolute value of the results, and store into Rdd.

                                                Syntax                                                                Behavior
                          Rdd=vabsdiffb(Rtt,Rss)                                   for (i=0;i<8;i++) {
                                                                                       Rdd.b[i]=ABS(Rtt.b[i] - Rss.b[i]);
                                                                                   };
                          Rdd=vabsdiffub(Rtt,Rss)                                  for (i=0;i<8;i++) {
                                                                                       Rdd.b[i]=ABS(Rtt.ub[i] - Rss.ub[i]);
                                                                                   };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vabsdiffb(Rtt,Rss)                                   Word64 Q6_P_vabsdiffb_PP(Word64 Rtt, Word64
                                                                                   Rss)
                          Rdd=vabsdiffub(Rtt,Rss)                                  Word64 Q6_P_vabsdiffub_PP(Word64 Rtt,
                                                                                   Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   0    0   1    0   1   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vabsdiffub(Rtt,Rss)
1   1   1    0   1    0   0    0   1    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vabsdiffb(Rtt,Rss)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  419

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector absolute difference halfwords
                          For each element in the source vector Rss, subtract the corresponding element in source
                          vector Rtt. Take the absolute value of the results, and store into Rdd.

                                                Syntax                                                                Behavior
                          Rdd=vabsdiffh(Rtt,Rss)                                   for (i=0;i<4;i++) {
                                                                                       Rdd.h[i]=ABS(Rtt.h[i] - Rss.h[i]);
                                                                                   };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vabsdiffh(Rtt,Rss)                                   Word64 Q6_P_vabsdiffh_PP(Word64 Rtt, Word64
                                                                                   Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   0    0   0    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vabsdiffh(Rtt,Rss)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  420

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector absolute difference words
                          For each element in the source vector Rss, subtract the corresponding element in source
                          vector Rtt. Take the absolute value of the results, and store into Rdd.

                                                Syntax                                                                Behavior
                          Rdd=vabsdiffw(Rtt,Rss)                                   for (i=0;i<2;i++) {
                                                                                       Rdd.w[i]=ABS(Rtt.w[i] - Rss.w[i]);
                                                                                   };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vabsdiffw(Rtt,Rss)                                   Word64 Q6_P_vabsdiffw_PP(Word64 Rtt, Word64
                                                                                   Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   0    0   0    0   1   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vabsdiffw(Rtt,Rss)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  421

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                   Instruction Set



Vector add compare and select maximum bytes
                        Add each byte element in Rxx and Rtt, and compare the resulting sums with the
                        corresponding differences between Rss and Rtt. Store the maximum value of each
                        compare in Rxx, and set the corresponding bits in a predicate destination to '1' if the
                        compare result is greater, '0' if not. Each sum and difference is saturated to 8 bits before
                        the compare, and the compare operation is a signed byte compare.


       Rxx.H3                    Rxx.H2                   Rxx.H1                     Rxx.H0                   Rxx

                        Rss.H3                   Rss.H2                   Rss.H1                     Rss.H0    Rss

           Rtt.H3                   Rtt.H2                   Rtt.H1                     Rtt.H0                 Rtt


            +            -           +            -           +            -             +            -
                                                                                                              Rxx,Pd=vacsh(Rss,Rtt)
           sat16        sat16       sat16        sat16       sat16        sat16         sat16        sat16




                                                                                                 >
                                                                      >

                                             >
                                                                                             1        0
                    >                                                                                           1bit

       16bits                                                     1        0


                                         1        0



                1        0




                Rxx.H3                 Rxx.H2                   Rxx.H1                    Rxx.H0                       Pd




80-N2040-36 B                                                                  422

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                     Instruction Set



Vector add compare and select maximum halfwords
                        Add each halfword element in Rxx and Rtt, and compare the resulting sums with the
                        corresponding differences between Rss and Rtt. Store the maximum value of each
                        compare in Rxx, and set the corresponding bits in a predicate destination to '11' if the
                        compare result is greater, '00' if not. Each sum and difference is saturated to 16 bits before
                        the compare, and the compare operation is a signed halfword compare.


       Rxx.H3                    Rxx.H2                   Rxx.H1                     Rxx.H0                     Rxx

                        Rss.H3                   Rss.H2                   Rss.H1                     Rss.H0      Rss

           Rtt.H3                   Rtt.H2                   Rtt.H1                     Rtt.H0                   Rtt


            +            -           +            -           +            -             +            -
                                                                                                               Rxx,Pd=vacsh(Rss,Rtt)
           sat16        sat16       sat16        sat16       sat16        sat16         sat16        sat16




                                                                                                 >
                                                                      >

                                             >
                                                                                             1        0
                    >                                                                                             1bit

       16bits                                                     1        0


                                         1        0



                1        0




                Rxx.H3                 Rxx.H2                   Rxx.H1                    Rxx.H0                         Pd


                                             Syntax                                                           Behavior
                         Rxx,Pe=vacsh(Rss,Rtt)                                    for (i = 0; i < 4; i++) {
                                                                                      xv = (int) Rxx.h[i];
                                                                                      sv = (int) Rss.h[i];
                                                                                      tv = (int) Rtt.h[i];
                                                                                      xv = xv + tv;
                                                                                      sv = sv - tv;
                                                                                      Pe.i*2 = (xv > sv);
                                                                                      Pe.i*2+1 = (xv > sv);
                                                                                      Rxx.h[i]=sat16(max(xv,sv));
                                                                                  };




80-N2040-36 B                                                                  423

                         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    The predicate generated by this instruction can not be used as a .new predicate,
                                        nor can it be automatically ANDed with another predicate.
                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), the OVF bit in the Status Register is set.
                                        OVF will remain set until explicitly cleared by a transfer to SR.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6    5       4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse             t5                   e2               x5
1   1   1    0   1    0   1    0   1    0   1   s   s   s    s   s   P   P 0   t   t   t    t   t   0   e        e   x   x   x    x   x Rxx,Pe=vacsh(Rss,Rtt)




                            Field name                                                          Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          e2                        Field to encode register e
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  424

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector add halfwords
                          Add each of the four halfwords in 64-bit vector Rss to the corresponding halfword in
                          vector Rtt.

                          Optionally saturate each 16-bit addition to either a signed or unsigned 16-bit value.
                          Applying saturation to the vaddh instruction clamps the result to the signed range 0x8000
                          to 0x7fff, whereas applying saturation to the vadduh instruction ensures that the unsigned
                          result falls within the range 0 to 0xffff. When saturation is not needed, the vaddh form
                          should be used.

                          For the 32-bit version of this vector operation, see the ALU32 instructions.

                                               Syntax                                                                  Behavior
                          Rdd=vaddh(Rss,Rtt)[:sat]                                  for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=[sat16](Rss.h[i]+Rtt.h[i]);
                                                                                    };
                          Rdd=vadduh(Rss,Rtt):sat                                   for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=usat16(Rss.uh[i]+Rtt.uh[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vaddh(Rss,Rtt)                                        Word64 Q6_P_vaddh_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vaddh(Rss,Rtt):sat                                    Word64 Q6_P_vaddh_PP_sat(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vadduh(Rss,Rtt):sat                                   Word64 Q6_P_vadduh_PP_sat(Word64 Rss,
                                                                                    Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0   d   d   d    d   d Rdd=vaddh(Rss,Rtt)
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   1   d   d   d    d   d Rdd=vaddh(Rss,Rtt):sat
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0   d   d   d    d   d Rdd=vadduh(Rss,Rtt):sat




80-N2040-36 B                                                                   425

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                MinOp          Minor Opcode
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       426

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Vector add halfwords with saturate and pack to unsigned
bytes
                          Add the four 16-bit halfwords of Rss to the four 16-bit halfwords of Rtt. The results are
                          saturated to unsigned 8-bits and packed in destination register Rd.

                                                 Syntax                                                                 Behavior
                          Rd=vaddhub(Rss,Rtt):sat                                     for (i=0;i<4;i++) {
                                                                                          Rd.b[i]=usat8(Rss.h[i]+Rtt.h[i]);
                                                                                      };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®     If saturation occurs during execution of this instruction (a result is clamped to
                                         either maximum or minimum values), the OVF bit in the Status Register is set.
                                         OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=vaddhub(Rss,Rtt):sat                                     Word32 Q6_R_vaddhub_PP_sat(Word64 Rss,
                                                                                      Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS           RegType           Maj               s5           Parse                t5           Min                 d5
1   1   0    0   0    0   0    1   0     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   d   d   d    d   d Rd=vaddhub(Rss,Rtt):sat




                            Field name                                                              Description
                          ICLASS                     Instruction Class
                          Parse                      Packet/Loop parse bits
                          d5                         Field to encode register d
                          s5                         Field to encode register s
                          t5                         Field to encode register t
                          Maj                        Major Opcode
                          Min                        Minor Opcode
                          RegType                    Register Type




80-N2040-36 B                                                                     427

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Vector reduce add unsigned bytes
                For each byte in the source vector Rss, add the corresponding byte in the source vector Rtt.
                Add the four upper intermediate results and optionally the upper word of the destination.
                Add the four lower results and optionally the lower word of the destination.


                                                                                           Rss


                                                                                           Rtt


                      +        +         +      +         +     +         +         +




                                   32bit Add                        32bit Add

                                                                                           Rdd




                               Syntax                                           Behavior
                Rdd=vraddub(Rss,Rtt)                 Rdd = 0;
                                                     for (i=0;i<4;i++) {
                                                         Rdd.w[0]=(Rdd.w[0] +
                                                     (Rss.ub[i]+Rtt.ub[i]));
                                                     };
                                                     for (i=4;i<8;i++) {
                                                         Rdd.w[1]=(Rdd.w[1] +
                                                     (Rss.ub[i]+Rtt.ub[i]));
                                                     };
                Rxx+=vraddub(Rss,Rtt)                for (i = 0; i < 4; i++) {
                                                         Rxx.w[0]=(Rxx.w[0] +
                                                     (Rss.ub[i]+Rtt.ub[i]));
                                                     };
                                                     for (i = 4; i < 8; i++) {
                                                         Rxx.w[1]=(Rxx.w[1] +
                                                     (Rss.ub[i]+Rtt.ub[i]));
                                                     };


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rdd=vraddub(Rss,Rtt)                 Word64 Q6_P_vraddub_PP(Word64 Rss, Word64
                                                     Rtt)
                Rxx+=vraddub(Rss,Rtt)                Word64 Q6_P_vraddubacc_PP(Word64 Rxx,
                                                     Word64 Rss, Word64 Rtt)




80-N2040-36 B                                       428

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            d5
1   1   1    0   1    0   0    0   0    1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   1   d   d   d    d   d Rdd=vraddub(Rss,Rtt)
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            x5
1   1   1    0   1    0   1    0   0    1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vraddub(Rss,Rtt)




                            Field name                                                          Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  429

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Vector reduce add unsigned halfwords
                For each halfword in the source vector Rss, add the corresponding halfword in the source
                vector Rtt. Add these intermediate results together, and place the result in Rd.


                                                                                      Rss


                                                                                       Rtt




                          +                 +             +                +


                                                +


                                                                 Rd


                              Syntax                                     Behavior
                Rd=vraddh(Rss,Rtt)                   Rd = 0;
                                                     for (i=0;i<4;i++) {
                                                         Rd += (Rss.h[i]+Rtt.h[i]);
                                                     };
                Rd=vradduh(Rss,Rtt)                  Rd = 0;
                                                     for (i=0;i<4;i++) {
                                                         Rd += (Rss.uh[i]+Rtt.uh[i]);
                                                     };


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rd=vraddh(Rss,Rtt)                   Word32 Q6_R_vraddh_PP(Word64 Rss, Word64
                                                     Rtt)
                Rd=vradduh(Rss,Rtt)                  Word32 Q6_R_vradduh_PP(Word64 Rss, Word64
                                                     Rtt)




80-N2040-36 B                                       430

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp               s5           Parse             t5               MinOp            d5
1   1   1    0   1    0   0    1   0     -     -   s   s   s    s   s   P   P 0   t   t   t    t   t   -    0   1   d   d   d    d   d Rd=vradduh(Rss,Rtt)
1   1   1    0   1    0   0    1   0     -   1     s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   1   d   d   d    d   d Rd=vraddh(Rss,Rtt)




                            Field name                                                             Description
                          ICLASS                       Instruction Class
                          MajOp                        Major Opcode
                          MinOp                        Minor Opcode
                          RegType                      Register Type
                          Parse                        Packet/Loop parse bits
                          d5                           Field to encode register d
                          s5                           Field to encode register s
                          t5                           Field to encode register t




80-N2040-36 B                                                                     431

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector add bytes
                          Add each of the eight bytes in 64-bit vector Rss to the corresponding byte in vector Rtt.
                          Optionally, saturate each 8-bit addition to an unsigned value between 0 and 255. The eight
                          results are stored in destination register Rdd.

                                               Syntax                                                                  Behavior
                          Rdd=vaddb(Rss,Rtt)                                        Assembler mapped to: "Rdd=vaddub(Rss,Rtt)"
                          Rdd=vaddub(Rss,Rtt)[:sat]                                 for (i = 0; i < 8; i++) {
                                                                                        Rdd.b[i]=[usat8](Rss.ub[i]+Rtt.ub[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vaddb(Rss,Rtt)                                        Word64 Q6_P_vaddb_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vaddub(Rss,Rtt)                                       Word64 Q6_P_vaddub_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vaddub(Rss,Rtt):sat                                   Word64 Q6_P_vaddub_PP_sat(Word64 Rss,
                                                                                    Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vaddub(Rss,Rtt)
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vaddub(Rss,Rtt):sat




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   432

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector add words
                          Add each of the two words in 64-bit vector Rss to the corresponding word in vector Rtt.
                          Optionally, saturate each 32-bit addition to a signed value between 0x80000000 and
                          0x7fffffff. The two word results are stored in destination register Rdd.

                                               Syntax                                                                  Behavior
                          Rdd=vaddw(Rss,Rtt)[:sat]                                  for (i=0;i<2;i++) {
                                                                                        Rdd.w[i]=[sat32](Rss.w[i]+Rtt.w[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vaddw(Rss,Rtt)                                        Word64 Q6_P_vaddw_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vaddw(Rss,Rtt):sat                                    Word64 Q6_P_vaddw_PP_sat(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vaddw(Rss,Rtt)
1   1   0    1   0    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   0   d   d   d    d   d Rdd=vaddw(Rss,Rtt):sat




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   433

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Vector average halfwords
                Average each of the four halfwords in the 64-bit source vector Rss with the corresponding
                halfword in Rtt. The average operation performed on each halfword adds the two
                halfwords and shifts the result right by 1 bit. Unsigned average uses a logical right shift
                (shift in 0), whereas signed average uses an arithmetic right shift (shift in the sign bit). If
                the round option is used, a 0x0001 is also added to each result before shifting. This
                operation does not overflow. In the case that a summation (before right shift by 1) causes
                an overflow of 32 bits, the value shifted in is the most-significant carry out.

                The signed average and negative average halfwords is available with optional convergent
                rounding. In convergent rounding, if the two LSBs after the addition/subtraction are 11, a
                rounding constant of 1 is added, otherwise a 0 is added. This result is then shifted right by
                one bit. Convergent rounding accumulates less error than arithmetic rounding.

                               Syntax                                         Behavior
                Rdd=vavgh(Rss,Rtt)                    for (i=0;i<4;i++) {
                                                          Rdd.h[i]=(Rss.h[i]+Rtt.h[i])>>1;
                                                      };
                Rdd=vavgh(Rss,Rtt):crnd               for (i=0;i<4;i++) {
                                                          Rdd.h[i]=convround(Rss.h[i]+Rtt.h[i])>
                                                      >1;
                                                      };
                Rdd=vavgh(Rss,Rtt):rnd                for (i=0;i<4;i++) {
                                                          Rdd.h[i]=(Rss.h[i]+Rtt.h[i]+1)>>1;
                                                      };
                Rdd=vavguh(Rss,Rtt)                   for (i=0;i<4;i++) {
                                                          Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i])>>1;
                                                      };
                Rdd=vavguh(Rss,Rtt):rnd               for (i=0;i<4;i++) {
                                                          Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i]+1)>>1;
                                                      };
                Rdd=vnavgh(Rtt,Rss)                   for (i=0;i<4;i++) {
                                                          Rdd.h[i]=(Rtt.h[i]-Rss.h[i])>>1;
                                                      };
                Rdd=vnavgh(Rtt,Rss):crnd:sat for (i=0;i<4;i++) {
                                                 Rdd.h[i]=sat16(convround(Rtt.h[i]-
                                             Rss.h[i])>>1);
                                             };
                Rdd=vnavgh(Rtt,Rss):rnd:sat           for (i=0;i<4;i++) {
                                                          Rdd.h[i]=sat16((Rtt.h[i]-
                                                      Rss.h[i]+1)>>1);
                                                      };


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), the OVF bit in the Status Register is set.
                         OVF will remain set until explicitly cleared by a transfer to SR.


80-N2040-36 B                                        434

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Intrinsics

                          Rdd=vavgh(Rss,Rtt)                                        Word64 Q6_P_vavgh_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vavgh(Rss,Rtt):crnd                                   Word64 Q6_P_vavgh_PP_crnd(Word64 Rss,
                                                                                    Word64 Rtt)
                          Rdd=vavgh(Rss,Rtt):rnd                                    Word64 Q6_P_vavgh_PP_rnd(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vavguh(Rss,Rtt)                                       Word64 Q6_P_vavguh_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vavguh(Rss,Rtt):rnd                                   Word64 Q6_P_vavguh_PP_rnd(Word64 Rss,
                                                                                    Word64 Rtt)
                          Rdd=vnavgh(Rtt,Rss)                                       Word64 Q6_P_vnavgh_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vnavgh(Rtt,Rss):crnd:sat Word64 Q6_P_vnavgh_PP_crnd_sat(Word64 Rtt,
                                                       Word64 Rss)
                          Rdd=vnavgh(Rtt,Rss):rnd:sat                               Word64 Q6_P_vnavgh_PP_rnd_sat(Word64 Rtt,
                                                                                    Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5      4   3   2    1   0
    ICLASS           RegType                           s5           Parse                 t5               MinOp               d5
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   0    1   0      d   d   d    d   d Rdd=vavgh(Rss,Rtt)
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   0    1   1      d   d   d    d   d Rdd=vavgh(Rss,Rtt):rnd
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0   0      d   d   d    d   d Rdd=vavgh(Rss,Rtt):crnd
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0   1      d   d   d    d   d Rdd=vavguh(Rss,Rtt)
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t     t   t    t   t   1    1      -   d   d   d    d   d Rdd=vavguh(Rss,Rtt):rnd
1   1   0    1   0    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   0    0   0      d   d   d    d   d Rdd=vnavgh(Rtt,Rss)
1   1   0    1   0    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   0    0   1      d   d   d    d   d Rdd=vnavgh(Rtt,Rss):rnd:sat
1   1   0    1   0    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   0    1   0      d   d   d    d   d Rdd=vnavgh(Rtt,Rss):crnd:sat




                            Field name                                                             Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   435

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector average unsigned bytes
                          Average each of the eight unsigned bytes in the 64-bit source vector Rss with the
                          corresponding byte in Rtt. The average operation performed on each byte is the sum of the
                          two bytes shifted right by 1 bit. If the round option is used, then a 0x01 is also added to
                          each result before shifting. This operation does not overflow. In the case that a summation
                          (before right shift by 1) causes an overflow of 8 bits, the value shifted in is the most-
                          significant carry out.

                                               Syntax                                                                  Behavior
                          Rdd=vavgub(Rss,Rtt)                                       for (i = 0; i < 8; i++) {
                                                                                        Rdd.b[i]=((Rss.ub[i] + Rtt.ub[i])>>1);
                                                                                    };
                          Rdd=vavgub(Rss,Rtt):rnd                                   for (i = 0; i < 8; i++) {
                                                                                        Rdd.b[i]=((Rss.ub[i]+Rtt.ub[i]+1)>>1);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=vavgub(Rss,Rtt)                                       Word64 Q6_P_vavgub_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vavgub(Rss,Rtt):rnd                                   Word64 Q6_P_vavgub_PP_rnd(Word64 Rss,
                                                                                    Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vavgub(Rss,Rtt)
1   1   0    1   0    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vavgub(Rss,Rtt):rnd




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   436

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Vector average words
                Average each of the two words in the 64-bit source vector Rss with the corresponding
                word in Rtt. The average operation performed on each halfword adds the two words and
                shifts the result right by 1 bit. Unsigned average uses a logical right shift (shift in 0),
                whereas signed average uses an arithmetic right shift (shift in the sign bit). If the round
                option is used, a 0x1 is also added to each result before shifting. This operation does not
                overflow. In the case that a summation (before right shift by 1) causes an overflow of 32
                bits, the value shifted in is the most-significant carry out.

                The signed average and negative average words is available with optional convergent
                rounding. In convergent rounding, if the two LSBs after the addition/subtraction are 11,
                then a rounding constant of 1 is added, otherwise a 0 is added. This result is then shifted
                right by one bit. Convergent rounding accumulates less error than arithmetic rounding.

                               Syntax                                       Behavior
                Rdd=vavguw(Rss,Rtt)[:rnd]             for (i=0;i<2;i++) {
                                                           Rdd.w[i]=(zxt32->33(Rss.uw[i])+zxt32-
                                                      >33(Rtt.uw[i])+1)>>1;
                                                      };
                Rdd=vavgw(Rss,Rtt):crnd               for (i=0;i<2;i++) {
                                                           Rdd.w[i]=(convround(sxt32-
                                                      >33(Rss.w[i])+sxt32->33(Rtt.w[i]))>>1);
                                                      };
                Rdd=vavgw(Rss,Rtt)[:rnd]              for (i=0;i<2;i++) {
                                                           Rdd.w[i]=(sxt32->33(Rss.w[i])+sxt32-
                                                      >33(Rtt.w[i])+1)>>1;
                                                      };
                Rdd=vnavgw(Rtt,Rss)                   for (i=0;i<2;i++) {
                                                           Rdd.w[i]=(sxt32->33(Rtt.w[i])-sxt32-
                                                      >33(Rss.w[i]))>>1;
                                                      };
                Rdd=vnavgw(Rtt,Rss):crnd:sat for (i=0;i<2;i++) {
                                                   Rdd.w[i]=sat32(convround(sxt32-
                                             >33 (Rtt.w[i])-sxt 32->33(Rss.w[i]))>>1);
                                             };
                Rdd=vnavgw(Rtt,Rss):rnd:sat           for (i=0;i<2;i++) {
                                                          Rdd.w[i]=sat32((sxt32->33(Rtt.w[i])-
                                                      sxt32->33(Rss.w[i])+1)>>1);
                                                      };


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), the OVF bit in the Status Register is set.
                         OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                       437

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Intrinsics

                          Rdd=vavguw(Rss,Rtt)                                       Word64 Q6_P_vavguw_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vavguw(Rss,Rtt):rnd                                   Word64 Q6_P_vavguw_PP_rnd(Word64 Rss,
                                                                                    Word64 Rtt)
                          Rdd=vavgw(Rss,Rtt)                                        Word64 Q6_P_vavgw_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vavgw(Rss,Rtt):crnd                                   Word64 Q6_P_vavgw_PP_crnd(Word64 Rss,
                                                                                    Word64 Rtt)
                          Rdd=vavgw(Rss,Rtt):rnd                                    Word64 Q6_P_vavgw_PP_rnd(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vnavgw(Rtt,Rss)                                       Word64 Q6_P_vnavgw_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vnavgw(Rtt,Rss):crnd:sat Word64 Q6_P_vnavgw_PP_crnd_sat(Word64 Rtt,
                                                       Word64 Rss)
                          Rdd=vnavgw(Rtt,Rss):rnd:sat                               Word64 Q6_P_vnavgw_PP_rnd_sat(Word64 Rtt,
                                                                                    Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5      4   3   2    1   0
    ICLASS           RegType                           s5           Parse                 t5               MinOp               d5
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t    t    t    t   t   0    0   0      d   d   d    d   d Rdd=vavgw(Rss,Rtt)
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t    t    t    t   t   0    0   1      d   d   d    d   d Rdd=vavgw(Rss,Rtt):rnd
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   0    1   0      d   d   d    d   d Rdd=vavgw(Rss,Rtt):crnd
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   0    1   1      d   d   d    d   d Rdd=vavguw(Rss,Rtt)
1   1   0    1   0    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0   0      d   d   d    d   d Rdd=vavguw(Rss,Rtt):rnd
1   1   0    1   0    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   0    1   1      d   d   d    d   d Rdd=vnavgw(Rtt,Rss)
1   1   0    1   0    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0      -   d   d   d    d   d Rdd=vnavgw(Rtt,Rss):rnd:sat
1   1   0    1   0    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t     t   t    t   t   1    1      -   d   d   d    d   d Rdd=vnavgw(Rtt,Rss):crnd:sat




                            Field name                                                             Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   438

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Vector conditional negate
                          Based on bits in Rt, conditionally negate halves in Rss.

                                                 Syntax                                                                 Behavior
                          Rdd=vcnegh(Rss,Rt)                                          for (i = 0; i < 4; i++) {
                                                                                          if (Rt.i) {
                                                                                              Rdd.h[i]=sat16(-Rss.h[i]);
                                                                                          } else {
                                                                                              Rdd.h[i]=Rss.h[i];
                                                                                          };
                                                                                      };
                          Rxx+=vrcnegh(Rss,Rt)                                        for (i = 0; i < 4; i++) {
                                                                                          if (Rt.i) {
                                                                                              Rxx += -Rss.h[i];
                                                                                          } else {
                                                                                              Rxx += Rss.h[i];
                                                                                          };
                                                                                      };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®     If saturation occurs during execution of this instruction (a result is clamped to
                                         either maximum or minimum values), the OVF bit in the Status Register is set.
                                         OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vcnegh(Rss,Rt)                                          Word64 Q6_P_vcnegh_PR(Word64 Rss, Word32
                                                                                      Rt)
                          Rxx+=vrcnegh(Rss,Rt)                                        Word64 Q6_P_vrcneghacc_PR(Word64 Rxx,
                                                                                      Word64 Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS           RegType           Maj               s5           Parse                t5           Min                 d5
1   1   0    0   0    0   1    1   1     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   d   d   d    d   d Rdd=vcnegh(Rss,Rt)
    ICLASS           RegType           Maj               s5           Parse                t5           Min                 x5
1   1   0    0   1    0   1    1   0     0   1   s   s   s    s   s   P   P 1     t    t   t    t   t   1   1   1   x   x   x    x   x Rxx+=vrcnegh(Rss,Rt)




                            Field name                                                              Description
                          ICLASS                     Instruction Class
                          Parse                      Packet/Loop parse bits
                          d5                         Field to encode register d
                          s5                         Field to encode register s
                          t5                         Field to encode register t



80-N2040-36 B                                                                     439

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                x5             Field to encode register x
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       440

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector maximum bytes
                          Compare each of the eight unsigned bytes in the 64-bit source vector Rss to the
                          corresponding byte in Rtt. For each comparison, select the maximum of the two bytes and
                          place that byte in the corresponding location in Rdd.

                                               Syntax                                                                  Behavior
                          Rdd=vmaxb(Rtt,Rss)                                        for (i = 0; i < 8; i++) {
                                                                                        Rdd.b[i]=max(Rtt.b[i],Rss.b[i]);
                                                                                    };
                          Rdd=vmaxub(Rtt,Rss)                                       for (i = 0; i < 8; i++) {
                                                                                        Rdd.b[i]=max(Rtt.ub[i],Rss.ub[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=vmaxb(Rtt,Rss)                                        Word64 Q6_P_vmaxb_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vmaxub(Rtt,Rss)                                       Word64 Q6_P_vmaxub_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vmaxub(Rtt,Rss)
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   0   d   d   d    d   d Rdd=vmaxb(Rtt,Rss)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   441

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector maximum halfwords
                          Compare each of the four halfwords in the 64-bit source vector Rss to the corresponding
                          halfword in Rtt. For each comparison, select the maximum of the two halfwords and place
                          that halfword in the corresponding location in Rdd. Comparisons are available in both
                          signed and unsigned form.

                                               Syntax                                                                  Behavior
                          Rdd=vmaxh(Rtt,Rss)                                        for (i = 0; i < 4; i++) {
                                                                                        Rdd.h[i]=max(Rtt.h[i],Rss.h[i]);
                                                                                    };
                          Rdd=vmaxuh(Rtt,Rss)                                       for (i = 0; i < 4; i++) {
                                                                                        Rdd.h[i]=max(Rtt.uh[i],Rss.uh[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vmaxh(Rtt,Rss)                                        Word64 Q6_P_vmaxh_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vmaxuh(Rtt,Rss)                                       Word64 Q6_P_vmaxuh_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vmaxh(Rtt,Rss)
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0   d   d   d    d   d Rdd=vmaxuh(Rtt,Rss)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   442

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



Vector reduce maximum halfwords
                          Register Rxx contains a maximum value in the low word and the address of that maximum
                          value in the high word. Register Rss contains a vector of four halfword values, and register
                          Ru contains the address of this data. The instruction finds the maximum halfword between
                          the previous maximum in Rxx[0] and the four values in Rss. The address of the new
                          maximum is stored in Rxx[1].

                                               Syntax                                                               Behavior
                          Rxx=vrmaxh(Rss,Ru)                                      max = Rxx.h[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 4; i++) {
                                                                                      if (max < Rss.h[i]) {
                                                                                          max = Rss.h[i];
                                                                                          addr = Ru | i<<1;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=max;
                                                                                  Rxx.w[1]=addr;
                          Rxx=vrmaxuh(Rss,Ru)                                     max = Rxx.uh[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 4; i++) {
                                                                                      if (max < Rss.uh[i]) {
                                                                                          max = Rss.uh[i];
                                                                                          addr = Ru | i<<1;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=max;
                                                                                  Rxx.w[1]=addr;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rxx=vrmaxh(Rss,Ru)                                      Word64 Q6_P_vrmaxh_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)
                          Rxx=vrmaxuh(Rss,Ru)                                     Word64 Q6_P_vrmaxuh_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse              x5           Min                 u5
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 0   x    x   x    x   x 0     0   1   u   u   u    u   u Rxx=vrmaxh(Rss,Ru)
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 1   x    x   x    x   x 0     0   1   u   u   u    u   u Rxx=vrmaxuh(Rss,Ru)




                            Field name                                                          Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s



80-N2040-36 B                                                                 443

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                u5             Field to encode register u
                x5             Field to encode register x
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       444

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



Vector reduce maximum words
                          Find the maximum word between the previous maximum in Rxx[0] and the two values in
                          Rss. The address of the new maximum is stored in Rxx[1].

                          Register Rxx contains a maximum value in the low word and the address of that maximum
                          value in the high word. Register Rss contains a vector of two word values, and register Ru
                          contains the address of this data.

                                               Syntax                                                               Behavior
                          Rxx=vrmaxuw(Rss,Ru)                                     max = Rxx.uw[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 2; i++) {
                                                                                      if (max < Rss.uw[i]) {
                                                                                          max = Rss.uw[i];
                                                                                          addr = Ru | i<<2;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=max;
                                                                                  Rxx.w[1]=addr;
                          Rxx=vrmaxw(Rss,Ru)                                      max = Rxx.w[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 2; i++) {
                                                                                      if (max < Rss.w[i]) {
                                                                                          max = Rss.w[i];
                                                                                          addr = Ru | i<<2;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=max;
                                                                                  Rxx.w[1]=addr;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rxx=vrmaxuw(Rss,Ru)                                     Word64 Q6_P_vrmaxuw_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)
                          Rxx=vrmaxw(Rss,Ru)                                      Word64 Q6_P_vrmaxw_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse              x5           Min                 u5
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 0   x    x   x    x   x 0     1   0   u   u   u    u   u Rxx=vrmaxw(Rss,Ru)
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 1   x    x   x    x   x 0     1   0   u   u   u    u   u Rxx=vrmaxuw(Rss,Ru)




80-N2040-36 B                                                                 445

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                s5             Field to encode register s
                u5             Field to encode register u
                x5             Field to encode register x
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       446

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector maximum words
                          Compare each of the two words in the 64-bit source vector Rss to the corresponding word
                          in Rtt. For each comparison, select the maximum of the two words and place that word in
                          the corresponding location in Rdd.

                          Comparisons are available in both signed and unsigned form.

                                               Syntax                                                                  Behavior
                          Rdd=vmaxuw(Rtt,Rss)                                       for (i = 0; i < 2; i++) {
                                                                                        Rdd.w[i]=max(Rtt.uw[i],Rss.uw[i]);
                                                                                    };
                          Rdd=vmaxw(Rtt,Rss)                                        for (i = 0; i < 2; i++) {
                                                                                        Rdd.w[i]=max(Rtt.w[i],Rss.w[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vmaxuw(Rtt,Rss)                                       Word64 Q6_P_vmaxuw_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vmaxw(Rtt,Rss)                                        Word64 Q6_P_vmaxw_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vmaxuw(Rtt,Rss)
1   1   0    1   0    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   1   d   d   d    d   d Rdd=vmaxw(Rtt,Rss)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   447

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                             Instruction Set



Vector minimum bytes
                          Compare each of the eight unsigned bytes in the 64-bit source vector Rss to the
                          corresponding byte in Rtt. For each comparison, select the minimum of the two bytes and
                          place that byte in the corresponding location in Rdd.

                                                Syntax                                                                        Behavior
                          Rdd,Pe=vminub(Rtt,Rss)                                     for (i = 0; i < 8; i++) {
                                                                                         Pe.i = (Rtt.ub[i] > Rss.ub[i]);
                                                                                         Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);
                                                                                     };
                          Rdd=vminb(Rtt,Rss)                                         for (i = 0; i < 8; i++) {
                                                                                         Rdd.b[i]=min(Rtt.b[i],Rss.b[i]);
                                                                                     };
                          Rdd=vminub(Rtt,Rss)                                        for (i = 0; i < 8; i++) {
                                                                                         Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);
                                                                                     };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    The predicate generated by this instruction can not be used as a .new predicate,
                                        nor can it be automatically ANDed with another predicate.

                          Intrinsics

                          Rdd=vminb(Rtt,Rss)                                         Word64 Q6_P_vminb_PP(Word64 Rtt, Word64
                                                                                     Rss)
                          Rdd=vminub(Rtt,Rss)                                        Word64 Q6_P_vminub_PP(Word64 Rtt, Word64
                                                                                     Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6     5       4   3   2    1   0
    ICLASS           RegType                            s5           Parse                t5               MinOp                  d5
1   1   0    1   0    0   1    1   1    0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0     0       d   d   d    d   d Rdd=vminub(Rtt,Rss)
1   1   0    1   0    0   1    1   1    1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1     1       d   d   d    d   d Rdd=vminb(Rtt,Rss)
    ICLASS           RegType           MajOp            s5           Parse                t5                     e2               d5
1   1   1    0   1    0   1    0   1    1   1   s   s   s    s   s   P   P 0     t    t   t    t   t   0     e        e   d   d   d    d   d Rdd,Pe=vminub(Rtt,Rss)




                            Field name                                                             Description
                          RegType                   Register Type
                          MinOp                     Minor Opcode
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode




80-N2040-36 B                                                                    448

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                RegType        Register Type
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                e2             Field to encode register e
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       449

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector minimum halfwords
                          Compare each of the four halfwords in the 64-bit source vector Rss to the corresponding
                          halfword in Rtt. For each comparison, select the minimum of the two halfwords and place
                          that halfword in the corresponding location in Rdd.

                          Comparisons are available in both signed and unsigned form.

                                               Syntax                                                                  Behavior
                          Rdd=vminh(Rtt,Rss)                                        for (i = 0; i < 4; i++) {
                                                                                        Rdd.h[i]=min(Rtt.h[i],Rss.h[i]);
                                                                                    };
                          Rdd=vminuh(Rtt,Rss)                                       for (i = 0; i < 4; i++) {
                                                                                        Rdd.h[i]=min(Rtt.uh[i],Rss.uh[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vminh(Rtt,Rss)                                        Word64 Q6_P_vminh_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vminuh(Rtt,Rss)                                       Word64 Q6_P_vminuh_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vminh(Rtt,Rss)
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0   d   d   d    d   d Rdd=vminuh(Rtt,Rss)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   450

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



Vector reduce minimum halfwords
                          Find the minimum halfword between the previous minimum in Rxx[0] and the four values
                          in Rss. The address of the new minimum is stored in Rxx[1].

                          Register Rxx contains a minimum value in the low word and the address of that minimum
                          value in the high word. Register Rss contains a vector of four halfword values, and register
                          Ru contains the address of this data.

                                               Syntax                                                               Behavior
                          Rxx=vrminh(Rss,Ru)                                      min = Rxx.h[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 4; i++) {
                                                                                      if (min > Rss.h[i]) {
                                                                                          min = Rss.h[i];
                                                                                          addr = Ru | i<<1;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=min;
                                                                                  Rxx.w[1]=addr;
                          Rxx=vrminuh(Rss,Ru)                                     min = Rxx.uh[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 4; i++) {
                                                                                      if (min > Rss.uh[i]) {
                                                                                          min = Rss.uh[i];
                                                                                          addr = Ru | i<<1;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=min;
                                                                                  Rxx.w[1]=addr;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rxx=vrminh(Rss,Ru)                                      Word64 Q6_P_vrminh_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)
                          Rxx=vrminuh(Rss,Ru)                                     Word64 Q6_P_vrminuh_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse              x5           Min                 u5
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 0   x    x   x    x   x 1     0   1   u   u   u    u   u Rxx=vrminh(Rss,Ru)
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 1   x    x   x    x   x 1     0   1   u   u   u    u   u Rxx=vrminuh(Rss,Ru)




80-N2040-36 B                                                                 451

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                s5             Field to encode register s
                u5             Field to encode register u
                x5             Field to encode register x
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       452

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



Vector reduce minimum words
                          Find the minimum word between the previous minimum in Rxx[0] and the two values in
                          Rss. The address of the new minimum is stored in Rxx[1].

                          Register Rxx contains a minimum value in the low word and the address of that minimum
                          value in the high word. Register Rss contains a vector of two word values, and register Ru
                          contains the address of this data.

                                               Syntax                                                               Behavior
                          Rxx=vrminuw(Rss,Ru)                                     min = Rxx.uw[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 2; i++) {
                                                                                      if (min > Rss.uw[i]) {
                                                                                          min = Rss.uw[i];
                                                                                          addr = Ru | i<<2;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=min;
                                                                                  Rxx.w[1]=addr;
                          Rxx=vrminw(Rss,Ru)                                      min = Rxx.w[0];
                                                                                  addr = Rxx.w[1];
                                                                                  for (i = 0; i < 2; i++) {
                                                                                      if (min > Rss.w[i]) {
                                                                                          min = Rss.w[i];
                                                                                          addr = Ru | i<<2;
                                                                                      };
                                                                                  };
                                                                                  Rxx.w[0]=min;
                                                                                  Rxx.w[1]=addr;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rxx=vrminuw(Rss,Ru)                                     Word64 Q6_P_vrminuw_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)
                          Rxx=vrminw(Rss,Ru)                                      Word64 Q6_P_vrminw_PR(Word64 Rxx, Word64
                                                                                  Rss, Word32 Ru)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse              x5           Min                 u5
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 0   x    x   x    x   x 1     1   0   u   u   u    u   u Rxx=vrminw(Rss,Ru)
1   1   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P 1   x    x   x    x   x 1     1   0   u   u   u    u   u Rxx=vrminuw(Rss,Ru)




80-N2040-36 B                                                                 453

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                s5             Field to encode register s
                u5             Field to encode register u
                x5             Field to encode register x
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       454

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector minimum words
                          Compare each of the two words in the 64-bit source vector Rss to the corresponding word
                          in Rtt. For each comparison, select the minimum of the two words and place that word in
                          the corresponding location in Rdd.

                          Comparisons are available in both signed and unsigned form.

                                               Syntax                                                                  Behavior
                          Rdd=vminuw(Rtt,Rss)                                       for (i = 0; i < 2; i++) {
                                                                                        Rdd.w[i]=min(Rtt.uw[i],Rss.uw[i]);
                                                                                    };
                          Rdd=vminw(Rtt,Rss)                                        for (i = 0; i < 2; i++) {
                                                                                        Rdd.w[i]=min(Rtt.w[i],Rss.w[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vminuw(Rtt,Rss)                                       Word64 Q6_P_vminuw_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vminw(Rtt,Rss)                                        Word64 Q6_P_vminw_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   1   d   d   d    d   d Rdd=vminw(Rtt,Rss)
1   1   0    1   0    0   1    1   1   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0   d   d   d    d   d Rdd=vminuw(Rtt,Rss)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   455

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                         Instruction Set



Vector sum of absolute differences unsigned bytes
                For each byte in the source vector Rss, subtract the corresponding byte in source vector
                Rtt. Take the absolute value of the intermediate results, and the upper four together and
                add the lower four together. Optionally, add the destination upper and lower words to these
                results.

                This instruction is useful in determining distance between two vectors, in applications
                such as motion estimation.


                                                                                            Rss


                                                                                            Rtt


                     sad     sad       sad     sad     sad     sad       sad        sad




                                   32bit Add                         32bit Add

                                                                                            Rdd




                              Syntax                                             Behavior
                Rdd=vrsadub(Rss,Rtt)                  Rdd = 0;
                                                      for (i = 0; i < 4; i++) {
                                                          Rdd.w[0]=(Rdd.w[0] + ABS((Rss.ub[i] -
                                                      Rtt.ub[i])));
                                                      };
                                                      for (i = 4; i < 8; i++) {
                                                          Rdd.w[1]=(Rdd.w[1] + ABS((Rss.ub[i] -
                                                      Rtt.ub[i])));
                                                      };
                Rxx+=vrsadub(Rss,Rtt)                 for (i = 0; i < 4; i++) {
                                                          Rxx.w[0]=(Rxx.w[0] + ABS((Rss.ub[i] -
                                                      Rtt.ub[i])));
                                                      };
                                                      for (i = 4; i < 8; i++) {
                                                          Rxx.w[1]=(Rxx.w[1] + ABS((Rss.ub[i] -
                                                      Rtt.ub[i])));
                                                      };




80-N2040-36 B                                        456

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=vrsadub(Rss,Rtt)                                     Word64 Q6_P_vrsadub_PP(Word64 Rss, Word64
                                                                                   Rtt)
                          Rxx+=vrsadub(Rss,Rtt)                                    Word64 Q6_P_vrsadubacc_PP(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   0    0   0    1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    1   0   d   d   d    d   d Rdd=vrsadub(Rss,Rtt)
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            x5
1   1   1    0   1    0   1    0   0    1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    1   0   x   x   x    x   x Rxx+=vrsadub(Rss,Rtt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  457

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Vector subtract halfwords
                          Subtract each of the four halfwords in 64-bit vector Rss from the corresponding halfword
                          in vector Rtt.

                          Optionally, saturate each 16-bit addition to either a signed or unsigned 16-bit value.
                          Applying saturation to the vsubh instruction clamps the result to the signed range 0x8000
                          to 0x7fff, whereas applying saturation to the vsubuh instruction ensures that the unsigned
                          result falls within the range 0 to 0xffff.

                          When saturation is not needed, vsubh should be used.

                                               Syntax                                                                   Behavior
                          Rdd=vsubh(Rtt,Rss)[:sat]                                  for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=[sat16](Rtt.h[i]-Rss.h[i]);
                                                                                    };
                          Rdd=vsubuh(Rtt,Rss):sat                                   for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=usat16(Rtt.uh[i]-Rss.uh[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vsubh(Rtt,Rss)                                        Word64 Q6_P_vsubh_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vsubh(Rtt,Rss):sat                                    Word64 Q6_P_vsubh_PP_sat(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vsubuh(Rtt,Rss):sat                                   Word64 Q6_P_vsubuh_PP_sat(Word64 Rtt,
                                                                                    Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                 t5               MinOp            d5
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t    t    t   t   0    1   0   d   d   d    d   d Rdd=vsubh(Rtt,Rss)
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t    t    t   t   0    1   1   d   d   d    d   d Rdd=vsubh(Rtt,Rss):sat
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0   0   d   d   d    d   d Rdd=vsubuh(Rtt,Rss):sat




80-N2040-36 B                                                                   458

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                MinOp          Minor Opcode
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       459

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector subtract bytes
                          Subtract each of the eight bytes in 64-bit vector Rss from the corresponding byte in vector
                          Rtt.

                          Optionally, saturate each 8-bit subtraction to an unsigned value between 0 and 255. The
                          eight results are stored in destination register Rdd.

                                               Syntax                                                                  Behavior
                          Rdd=vsubb(Rss,Rtt)                                        Assembler mapped to: "Rdd=vsubub(Rss,Rtt)"
                          Rdd=vsubub(Rtt,Rss)[:sat]                                 for (i = 0; i < 8; i++) {
                                                                                        Rdd.b[i]=[usat8](Rtt.ub[i]-Rss.ub[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vsubb(Rss,Rtt)                                        Word64 Q6_P_vsubb_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vsubub(Rtt,Rss)                                       Word64 Q6_P_vsubub_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vsubub(Rtt,Rss):sat                                   Word64 Q6_P_vsubub_PP_sat(Word64 Rtt,
                                                                                    Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vsubub(Rtt,Rss)
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vsubub(Rtt,Rss):sat




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   460

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector subtract words
                          Subtract each of the two words in 64-bit vector Rss from the corresponding word in vector
                          Rtt.

                          Optionally, saturate each 32-bit subtraction to a signed value between 0x8000_0000 and
                          0x7fff_ffff. The two word results are stored in destination register Rdd.

                                               Syntax                                                                  Behavior
                          Rdd=vsubw(Rtt,Rss)[:sat]                                  for (i=0;i<2;i++) {
                                                                                        Rdd.w[i]=[sat32](Rtt.w[i]-Rss.w[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vsubw(Rtt,Rss)                                        Word64 Q6_P_vsubw_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=vsubw(Rtt,Rss):sat                                    Word64 Q6_P_vsubw_PP_sat(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5               MinOp            d5
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vsubw(Rtt,Rss)
1   1   0    1   0    0   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1    1   0   d   d   d    d   d Rdd=vsubw(Rtt,Rss):sat




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   461

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



   11.10.2 XTYPE/BIT
                The XTYPE/BIT instruction subclass includes instructions for bit manipulation.

Count leading
                Count leading zeros (cl0) counts the number of consecutive zeros starting with the most
                significant bit.

                Count leading ones (cl1) counts the number of consecutive ones starting with the most
                significant bit.

                Count leading bits (clb) counts both leading ones and leading zeros and then selects the
                maximum.

                The NORMAMT instruction returns the number of leading bits minus one.

                For a two's-complement number, the number of leading zeros is zero for negative
                numbers. The number of leading ones is zero for positive numbers.

                The number of leading bits can be used to judge the magnitude of the value.

                              Syntax                                       Behavior
                Rd=add(clb(Rs),#s6)                  Rd =
                                                     (max(count_leading_ones(Rs),count_leading_
                                                     ones(~Rs)))+#s;
                Rd=add(clb(Rss),#s6)                 Rd =
                                                     (max(count_leading_ones(Rss),count_leading
                                                     _ones(~Rss)))+#s;
                Rd=cl0(Rs)                           Rd = count_leading_ones(~Rs);
                Rd=cl0(Rss)                          Rd = count_leading_ones(~Rss);
                Rd=cl1(Rs)                           Rd = count_leading_ones(Rs);




80-N2040-36 B                                      462

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                              Syntax                               Behavior
                Rd=cl1(Rss)                    Rd = count_leading_ones(Rss);
                Rd=clb(Rs)                     Rd =
                                               max(count_leading_ones(Rs),count_leading_o
                                               nes(~Rs));
                Rd=clb(Rss)                    Rd =
                                               max(count_leading_ones(Rss),count_leading_
                                               ones(~Rss));
                Rd=normamt(Rs)                 if (Rs == 0) {
                                                   Rd = 0;
                                               } else {
                                                   Rd =
                                               (max(count_leading_ones(Rs),count_leading_
                                               ones(~Rs)))-1;
                                               };
                Rd=normamt(Rss)                if (Rss == 0) {
                                                   Rd = 0;
                                               } else {
                                                   Rd =
                                               (max(count_leading_ones(Rss),count_leading
                                               _ones(~Rss)))-1;
                                               };


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rd=add(clb(Rs),#s6)            Word32 Q6_R_add_clb_RI(Word32 Rs, Word32
                                               Is6)
                Rd=add(clb(Rss),#s6)           Word32 Q6_R_add_clb_PI(Word64 Rss, Word32
                                               Is6)
                Rd=cl0(Rs)                     Word32 Q6_R_cl0_R(Word32 Rs)
                Rd=cl0(Rss)                    Word32 Q6_R_cl0_P(Word64 Rss)
                Rd=cl1(Rs)                     Word32 Q6_R_cl1_R(Word32 Rs)
                Rd=cl1(Rss)                    Word32 Q6_R_cl1_P(Word64 Rss)
                Rd=clb(Rs)                     Word32 Q6_R_clb_R(Word32 Rs)
                Rd=clb(Rss)                    Word32 Q6_R_clb_P(Word64 Rss)
                Rd=normamt(Rs)                 Word32 Q6_R_normamt_R(Word32 Rs)
                Rd=normamt(Rss)                Word32 Q6_R_normamt_P(Word64 Rss)




80-N2040-36 B                                 463

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   1    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -   -     -   -   -   0    0   0   d   d   d    d   d Rd=clb(Rss)
1   0   0    0   1    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -   -     -   -   -   0    1   0   d   d   d    d   d Rd=cl0(Rss)
1   0   0    0   1    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   0   d   d   d    d   d Rd=cl1(Rss)
1   0   0    0   1    0   0    0   0   1   1   s   s   s    s   s   P   P   -   -     -   -   -   -   0    0   0   d   d   d    d   d Rd=normamt(Rss)
1   0   0    0   1    0   0    0   0   1   1   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   0   d   d   d    d   d Rd=add(clb(Rss),#s6)
1   0   0    0   1    1   0    0   0   0   1   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0   0   d   d   d    d   d Rd=add(clb(Rs),#s6)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   0   d   d   d    d   d Rd=clb(Rs)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   1   d   d   d    d   d Rd=cl0(Rs)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   0   d   d   d    d   d Rd=cl1(Rs)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   1   d   d   d    d   d Rd=normamt(Rs)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   464

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Count population
                          Population Count (popcount) counts the number of bits in Rss that are set.

                                               Syntax                                                                 Behavior
                          Rd=popcount(Rss)                                          Rd = count_ones(Rss);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=popcount(Rss)                                          Word32 Q6_R_popcount_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   1    0   0    0   0   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0    1   1   d   d   d    d   d Rd=popcount(Rss)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   465

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Count trailing
                          Count trailing zeros (ct0) counts the number of consecutive zeros starting with the least
                          significant bit.

                          Count trailing ones (ct1) counts the number of consecutive ones starting with the least
                          significant bit.

                                               Syntax                                                                  Behavior
                          Rd=ct0(Rs)                                                Rd = count_leading_ones(~reverse_bits(Rs));
                          Rd=ct0(Rss)                                               Rd =
                                                                                    count_leading_ones(~reverse_bits(Rss));
                          Rd=ct1(Rs)                                                Rd = count_leading_ones(reverse_bits(Rs));
                          Rd=ct1(Rss)                                               Rd = count_leading_ones(reverse_bits(Rss));


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=ct0(Rs)                                                Word32 Q6_R_ct0_R(Word32 Rs)
                          Rd=ct0(Rss)                                               Word32 Q6_R_ct0_P(Word64 Rss)
                          Rd=ct1(Rs)                                                Word32 Q6_R_ct1_R(Word32 Rs)
                          Rd=ct1(Rss)                                               Word32 Q6_R_ct1_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   1    0   0    0   1   1   1   s   s   s    s   s   P   P   -   -    -    -   -   -   0    1   0   d   d   d    d   d Rd=ct0(Rss)
1   0   0    0   1    0   0    0   1   1   1   s   s   s    s   s   P   P   -   -    -    -   -   -   1    0   0   d   d   d    d   d Rd=ct1(Rss)
1   0   0    0   1    1   0    0   0   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   0   d   d   d    d   d Rd=ct0(Rs)
1   0   0    0   1    1   0    0   0   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   1   d   d   d    d   d Rd=ct1(Rs)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   466

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



Extract bitfield
                Extract a bitfield from the source register (or register pair) and deposit into the least
                significant bits of the destination register (or register pair). The other, more significant bits
                in the destination are either cleared or sign-extended, depending on the instruction.

                The width of the extracted field is obtained from the first immediate or from the most-
                significant word of Rtt. The field offset is obtained from either the second immediate or
                from the least-significant word of Rtt.

                For register-based extract, where Rtt supplies the offset and width, the offset value is
                treated as a signed 7-bit number. If this value is negative, the source register Rss is shifted
                left (the reverse direction). Width number of bits are then taken from the least-significant
                portion of this result.

                If the shift amount and/or offset captures data beyond the most significant end of the input,
                these bits will be taken as zero.

                                                   Width                   Offset


                                                                                             Rs




                                                                                            Rd

                               Zero Extension




80-N2040-36 B                                         467

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                           Instruction Set




                             Syntax                                Behavior
                Rd=extract(Rs,#u5,#U5)         width=#u;
                                               offset=#U;
                                               Rd = sxtwidth->32((Rs >> offset));
                Rd=extract(Rs,Rtt)             width=zxt6->32((Rtt.w[1]));
                                               offset=sxt7->32((Rtt.w[0]));
                                               Rd = sxtwidth->64((offset>0)?(zxt32->64(zxt32-
                                               >64(Rs))>>>offset):(zxt32->64(zxt32-
                                               >64(Rs))<<offset));

                Rd=extractu(Rs,#u5,#U5)        width=#u;
                                               offset=#U;
                                               Rd = zxtwidth->32((Rs >> offset));
                Rd=extractu(Rs,Rtt)            width=zxt6->32((Rtt.w[1]));
                                               offset=sxt7->32((Rtt.w[0]));
                                               Rd = zxtwidth->64((offset>0)?(zxt32->64(zxt32-
                                               >64(Rs))>>>offset):(zxt32->64(zxt32-
                                               >64(Rs))<<offset));

                Rdd=extract(Rss,#u6,#U6)       width=#u;
                                               offset=#U;
                                               Rdd = sxtwidth->64((Rss >> offset));
                Rdd=extract(Rss,Rtt)           width=zxt6->32((Rtt.w[1]));
                                               offset=sxt7->32((Rtt.w[0]));
                                               Rdd = sxtwidth-
                                               >64((offset>0)?(Rss>>>offset):(Rss<<offset)
                                               );
                Rdd=extractu(Rss,#u6,#U6)      width=#u;
                                               offset=#U;
                                               Rdd = zxtwidth->64((Rss >> offset));
                Rdd=extractu(Rss,Rtt)          width=zxt6->32((Rtt.w[1]));
                                               offset=sxt7->32((Rtt.w[0]));
                                               Rdd = zxtwidth-
                                               >64((offset>0)?(Rss>>>offset):(Rss<<offset)
                                               );


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rd=extract(Rs,#u5,#U5)         Word32 Q6_R_extract_RII(Word32 Rs, Word32
                                               Iu5, Word32 IU5)
                Rd=extract(Rs,Rtt)             Word32 Q6_R_extract_RP(Word32 Rs, Word64
                                               Rtt)
                Rd=extractu(Rs,#u5,#U5)        Word32 Q6_R_extractu_RII(Word32 Rs, Word32
                                               Iu5, Word32 IU5)




80-N2040-36 B                                 468

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                          Rd=extractu(Rs,Rtt)                                       Word32 Q6_R_extractu_RP(Word32 Rs, Word64
                                                                                    Rtt)
                          Rdd=extract(Rss,#u6,#U6)                                  Word64 Q6_P_extract_PII(Word64 Rss, Word32
                                                                                    Iu6, Word32 IU6)
                          Rdd=extract(Rss,Rtt)                                      Word64 Q6_P_extract_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=extractu(Rss,#u6,#U6)                                 Word64 Q6_P_extractu_PII(Word64 Rss, Word32
                                                                                    Iu6, Word32 IU6)
                          Rdd=extractu(Rss,Rtt)                                     Word64 Q6_P_extractu_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6    5     4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                  MinOp               d5

1   0   0    0   0    0   0    1   I   I   I   s   s   s    s   s   P   P   i   i     i   i    i   i   I     I     I   d   d   d    d   d Rdd=extractu(Rss,#u6,#U6)
1   0   0    0   1    0   1    0   I   I   I   s   s   s    s   s   P   P   i   i     i   i    i   i   I     I     I   d   d   d    d   d Rdd=extract(Rss,#u6,#U6)
1   0   0    0   1    1   0    1   0   I   I   s   s   s    s   s   P   P 0     i     i   i    i   i   I     I     I   d   d   d    d   d Rd=extractu(Rs,#u5,#U5)
1   0   0    0   1    1   0    1   1   I   I   s   s   s    s   s   P   P 0     i     i   i    i   i   I     I     I   d   d   d    d   d Rd=extract(Rs,#u5,#U5)
    ICLASS           RegType        Maj                s5           Parse                 t5           Min                     d5
1   1   0    0   0    0   0    1   0   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0    0      -   d   d   d    d   d Rdd=extractu(Rss,Rtt)
1   1   0    0   0    0   0    1   1   1   -   s   s   s    s   s   P   P   -   t    t    t    t   t   1    0      -   d   d   d    d   d Rdd=extract(Rss,Rtt)
1   1   0    0   1    0   0    1   0   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0    0      -   d   d   d    d   d Rd=extractu(Rs,Rtt)
1   1   0    0   1    0   0    1   0   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0    1      -   d   d   d    d   d Rd=extract(Rs,Rtt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type
                          RegType                  Register Type




80-N2040-36 B                                                                   469

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



Insert bitfield
                Replace a bitfield in the destination register (or register pair) with bits from the least
                significant portion of Rs/Rss. The number of bits is obtained from the first immediate or
                the most-significant word of Rtt. The bits are shifted by the second immediate or the least
                significant word of Rtt.

                If register Rtt specifies the offset, then the low 7-bits of Rtt are treated as a signed 7-bit
                value. If this value is negative, the result is zero.

                Shift amounts and offsets that are too large may push bits beyond the end of the
                destination register, in this case the bits will not appear in the destination register.

                                                                        Width

                                                                                           Rs




                                                                              Offset

                                                                                           Rd

                           Unchanged                                     Unchanged


                               Syntax                                           Behavior
                Rx=insert(Rs,#u5,#U5)                  width=#u;
                                                       offset=#U;
                                                       Rx &= ~(((1<<width)-1)<<offset);
                                                       Rx |= ((Rs & ((1<<width)-1)) << offset);
                Rx=insert(Rs,Rtt)                      width=zxt6->32((Rtt.w[1]));
                                                       offset=sxt7->32((Rtt.w[0]));
                                                       mask = ((1<<width)-1);
                                                       if (offset < 0) {
                                                           Rx = 0;
                                                       } else {
                                                           Rx &= ~(mask<<offset);
                                                           Rx |= ((Rs & mask) << offset);
                                                       };
                Rxx=insert(Rss,#u6,#U6)                width=#u;
                                                       offset=#U;
                                                       Rxx &= ~(((1<<width)-1)<<offset);
                                                       Rxx |= ((Rss & ((1<<width)-1)) << offset);
                Rxx=insert(Rss,Rtt)                    width=zxt6->32((Rtt.w[1]));
                                                       offset=sxt7->32((Rtt.w[0]));
                                                       mask = ((1<<width)-1);
                                                       if (offset < 0) {
                                                           Rxx = 0;
                                                       } else {
                                                           Rxx &= ~(mask<<offset);
                                                           Rxx |= ((Rss & mask) << offset);
                                                       };



80-N2040-36 B                                         470

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rx=insert(Rs,#u5,#U5)                                     Word32 Q6_R_insert_RII(Word32 Rx, Word32
                                                                                    Rs, Word32 Iu5, Word32 IU5)
                          Rx=insert(Rs,Rtt)                                         Word32 Q6_R_insert_RP(Word32 Rx, Word32 Rs,
                                                                                    Word64 Rtt)
                          Rxx=insert(Rss,#u6,#U6)                                   Word64 Q6_P_insert_PII(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6, Word32 IU6)
                          Rxx=insert(Rss,Rtt)                                       Word64 Q6_P_insert_PP(Word64 Rxx, Word64
                                                                                    Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6    5     4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                  MinOp               x5
1   0   0    0   0    0   1    1   I   I   I   s   s   s    s   s   P   P   i   i     i   i    i   i   I     I     I   x   x   x    x   x Rxx=insert(Rss,#u6,#U6)
1   0   0    0   1    1   1    1   0   I   I   s   s   s    s   s   P   P 0     i     i   i    i   i   I     I     I   x   x   x    x   x Rx=insert(Rs,#u5,#U5)
    ICLASS           RegType                           s5           Parse                 t5                                   x5
1   1   0    0   1    0   0    0   -   -   -   s   s   s    s   s   P   P   -   t    t    t    t   t   -     -     -   x   x   x    x   x Rx=insert(Rs,Rtt)
    ICLASS           RegType        Maj                s5           Parse                 t5                                   x5
1   1   0    0   1    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   -     -     -   x   x   x    x   x Rxx=insert(Rss,Rtt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          x5                       Field to encode register x
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          Maj                      Major Opcode
                          RegType                  Register Type
                          RegType                  Register Type




80-N2040-36 B                                                                   471

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Interleave/deinterleave
                          For interleave, bits I+32 of Rss (which are the bits from the upper source word) get placed
                          in the odd bits (I*2)+1 of Rdd, while bits I of Rss (which are the bits from the lower source
                          word) get placed in the even bits (I*2) of Rdd.

                          For deinterleave, the even bits of the source register are placed in the even register of the
                          result pair, and the odd bits of the source register are placed in the odd register of the result
                          pair.

                          Note that "r1:0 = deinterleave(r1:0)" is the inverse of "r1:0 = interleave(r1:0)".

                                               Syntax                                                                 Behavior
                          Rdd=deinterleave(Rss)                                     Rdd = deinterleave(ODD,EVEN);
                          Rdd=interleave(Rss)                                       Rdd = interleave(Rss.w[1],Rss.w[0]);


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=deinterleave(Rss)                                     Word64 Q6_P_deinterleave_P(Word64 Rss)
                          Rdd=interleave(Rss)                                       Word64 Q6_P_interleave_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   1   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   0   d   d   d    d   d Rdd=deinterleave(Rss)
1   0   0    0   0    0   0    0   1   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   1   d   d   d    d   d Rdd=interleave(Rss)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   472

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Linear feedback-shift iteration
                          Count the number of ones of the logical AND of the two source input values, and take the
                          least significant value of that sum. The first source value is shifted right by one bit, and the
                          parity is placed in the MSB.

                                               Syntax                                                                 Behavior
                          Rdd=lfs(Rss,Rtt)                                          Rdd = (Rss.u64 >> 1) | ((1&count_ones(Rss &
                                                                                    Rtt)).u64<<63) ;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=lfs(Rss,Rtt)                                          Word64 Q6_P_lfs_PP(Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse                t5           Min                 d5
1   1   0    0   0    0   0    1   1   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   0   d   d   d    d   d Rdd=lfs(Rss,Rtt)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   473

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Masked parity
                          Count the number of ones of the logical AND of the two source input values, and take the
                          least significant bit of that sum.

                                               Syntax                                                                 Behavior
                          Rd=parity(Rs,Rt)                                          Rd = 1&count_ones(Rs & Rt);
                          Rd=parity(Rss,Rtt)                                        Rd = 1&count_ones(Rss & Rtt);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=parity(Rs,Rt)                                          Word32 Q6_R_parity_RR(Word32 Rs, Word32 Rt)
                          Rd=parity(Rss,Rtt)                                        Word32 Q6_R_parity_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5                               d5
1   1   0    1   0    0   0    0   -   -   -   s   s   s    s   s   P   P   -   t    t   t    t   t   -   -   -   d   d   d    d   d Rd=parity(Rss,Rtt)
1   1   0    1   0    1   0    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   -   -   d   d   d    d   d Rd=parity(Rs,Rt)




                            Field name                                                            Description
                          RegType                  Register Type
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   474

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Bit reverse
                          Reverse the order of bits. The most significant gets swapped with the least significant, bit
                          30 gets swapped with bit 1, and so on.

                                               Syntax                                                                 Behavior
                          Rd=brev(Rs)                                               Rd = reverse_bits(Rs);
                          Rdd=brev(Rss)                                             Rdd = reverse_bits(Rss);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=brev(Rs)                                               Word32 Q6_R_brev_R(Word32 Rs)
                          Rdd=brev(Rss)                                             Word64 Q6_P_brev_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   1   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   0   d   d   d    d   d Rdd=brev(Rss)
1   0   0    0   1    1   0    0   0   1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   0   d   d   d    d   d Rd=brev(Rs)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   475

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Set/clear/toggle bit
                          Set (to 1), clear (to 0), or toggle a single bit in the source, and place the resulting value in
                          the destination. The bit to be manipulated can be indicated using an immediate or register
                          value.

                          If a register is used to indicate the bit position, and the value of the least-significant 7 bits
                          of Rt is out of range, then the destination register will be unchanged.

                                               Syntax                                                                Behavior
                          Rd=clrbit(Rs,#u5)                                       Rd = (Rs & (~(1<<#u)));
                          Rd=clrbit(Rs,Rt)                                        Rd = (Rs & (~((sxt7->32(Rt)>0)?(zxt32-
                                                                                  >64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7-
                                                                                  >32(Rt)))));

                          Rd=setbit(Rs,#u5)                                       Rd = (Rs | (1<<#u));
                          Rd=setbit(Rs,Rt)                                        Rd = (Rs | (sxt7->32(Rt)>0)?(zxt32-
                                                                                  >64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7-
                                                                                  >32(Rt)));

                          Rd=togglebit(Rs,#u5)                                    Rd = (Rs ^ (1<<#u));
                          Rd=togglebit(Rs,Rt)                                     Rd = (Rs ^ (sxt7->32(Rt)>0)?(zxt32-
                                                                                  >64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7-
                                                                                  >32(Rt)));


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rd=clrbit(Rs,#u5)                                       Word32 Q6_R_clrbit_RI(Word32 Rs, Word32
                                                                                  Iu5)
                          Rd=clrbit(Rs,Rt)                                        Word32 Q6_R_clrbit_RR(Word32 Rs, Word32 Rt)
                          Rd=setbit(Rs,#u5)                                       Word32 Q6_R_setbit_RI(Word32 Rs, Word32
                                                                                  Iu5)
                          Rd=setbit(Rs,Rt)                                        Word32 Q6_R_setbit_RR(Word32 Rs, Word32 Rt)
                          Rd=togglebit(Rs,#u5)                                    Word32 Q6_R_togglebit_RI(Word32 Rs, Word32
                                                                                  Iu5)
                          Rd=togglebit(Rs,Rt)                                     Word32 Q6_R_togglebit_RR(Word32 Rs, Word32
                                                                                  Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                               MinOp            d5
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   0    0   0   d   d   d    d   d Rd=setbit(Rs,#u5)
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   0    0   1   d   d   d    d   d Rd=clrbit(Rs,#u5)




80-N2040-36 B                                                                 476

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P 0     i     i   i    i   i   0   1   0   d   d   d    d   d Rd=togglebit(Rs,#u5)
    ICLASS           RegType       Maj                 s5           Parse                 t5           Min                 d5
1   1   0    0   0    1   1    0   1   0   -   s   s   s    s   s   P   P   -   t   t     t    t   t   0   0   -   d   d   d    d   d Rd=setbit(Rs,Rt)
1   1   0    0   0    1   1    0   1   0   -   s   s   s    s   s   P   P   -   t   t     t    t   t   0   1   -   d   d   d    d   d Rd=clrbit(Rs,Rt)
1   1   0    0   0    1   1    0   1   0   -   s   s   s    s   s   P   P   -   t   t     t    t   t   1   0   -   d   d   d    d   d Rd=togglebit(Rs,Rt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type
                          RegType                  Register Type




80-N2040-36 B                                                                   477

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Split bitfield
                Split the bitfield in a register into upper and lower parts of variable size. The lower part is
                placed in the lower word of a destination register pair, and the upper part is placed in the
                upper word of the destination. An immediate value or register Rt is used to determine the
                bit position of the split.


                                                                 Bits

                                                                                   Rs




                                                                                                      Rdd[0]

                                                       Zero



                                                                                  Rdd[1]

                  Zero


                               Syntax                                         Behavior
                Rdd=bitsplit(Rs,#u5)                  Rdd.w[1]=(Rs>>#u);
                                                      Rdd.w[0]=zxt#u->32(Rs);
                Rdd=bitsplit(Rs,Rt)                   shamt = zxt5->32(Rt);
                                                      Rdd.w[1]=(Rs>>shamt);
                                                      Rdd.w[0]=zxtshamt->32(Rs);


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rdd=bitsplit(Rs,#u5)                  Word64 Q6_P_bitsplit_RI(Word32 Rs, Word32
                                                      Iu5)
                Rdd=bitsplit(Rs,Rt)                   Word64 Q6_P_bitsplit_RR(Word32 Rs, Word32
                                                      Rt)




80-N2040-36 B                                        478

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6    5     4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                  MinOp               d5
1   0   0    0   1    0   0    0   1   1   0   s   s   s    s   s   P   P 0     i     i   i    i   i   1    0    0     d   d   d    d   d Rdd=bitsplit(Rs,#u5)
    ICLASS           RegType                           s5           Parse                 t5                                   d5
1   1   0    1   0    1   0    0   -   -   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -     -     -   d   d   d    d   d Rdd=bitsplit(Rs,Rt)




                            Field name                                                             Description
                          RegType                  Register Type
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   479

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                           Instruction Set



Table index
                The table index instruction supports fast lookup tables where the index into the table is
                stored in a bit-field. The instruction forms the address of a table element by extracting the
                bit-field and inserting it into the appropriate bits of a pointer to the table element.

                Tables are defined to contain entries of bytes, halfwords, words, or doublewords. The table
                must be aligned to a power-of-2 size greater than or equal to the table size. For example, a
                4Kbyte table should be aligned to a 4Kbyte boundary. This instruction supports tables
                with a maximum of 32K table entries.

                Register Rx contains a pointer to within the table. Register Rs contains a field to be
                extracted and used as a table index. This instruction first extracts the field from register Rs
                and then inserts it into register Rx. The insertion point is bit 0 for tables of bytes, bit 1 for
                tables of halfwords, bit 2 for tables of words, and bit 3 for tables of doublewords.

                In the assembly syntax, the width and offset values represent the field in Rs to be
                extracted. Unsigned constants should be used to specify the width and offsets in assembly.
                In the encoded instruction, however, these values are adjusted by the assembler as follows.
                     ï®   For tableidxb, no adjustment is necessary.
                     ï®   For tableidxh, the assembler encodes offset-1 in the signed immediate field.
                     ï®   For tableidxw, the assembler encodes offset-2 in the signed immediate field.
                     ï®   For tableidxd, the assembler encodes offset-3 in the signed immediate field.
                         Rx=TABLEIDXD(Rs,#width,#offset)

                                                    Width                 Offset



                                                                                               Rs




                                 Unchanged                                                     Rx


                                                                                   Unchanged




80-N2040-36 B                                         480

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                             Syntax                                Behavior
                Rx=tableidxb(Rs,#u4,#S6):raw width=#u;
                                             offset=#S;
                                             field = Rs[(width+offset-1):offset];
                                             Rx[(width-1+0):0]=field;
                Rx=tableidxb(Rs,#u4,#U5)       Assembler mapped to:
                                               "Rx=tableidxb(Rs,#u4,#U5):raw"
                Rx=tableidxd(Rs,#u4,#S6):raw width=#u;
                                             offset=#S+3;
                                             field = Rs[(width+offset-1):offset];
                                             Rx[(width-1+3):3]=field;
                Rx=tableidxd(Rs,#u4,#U5)       Assembler mapped to:
                                               "Rx=tableidxd(Rs,#u4,#U5-3):raw"
                Rx=tableidxh(Rs,#u4,#S6):raw width=#u;
                                             offset=#S+1;
                                             field = Rs[(width+offset-1):offset];
                                             Rx[(width-1+1):1]=field;
                Rx=tableidxh(Rs,#u4,#U5)       Assembler mapped to:
                                               "Rx=tableidxh(Rs,#u4,#U5-1):raw"
                Rx=tableidxw(Rs,#u4,#S6):raw width=#u;
                                             offset=#S+2;
                                             field = Rs[(width+offset-1):offset];
                                             Rx[(width-1+2):2]=field;
                Rx=tableidxw(Rs,#u4,#U5)       Assembler mapped to:
                                               "Rx=tableidxw(Rs,#u4,#U5-2):raw"


                Class: XTYPE (slots 2,3)

                Intrinsics


                Rx=tableidxb(Rs,#u4,#U5)       Word32 Q6_R_tableidxb_RII(Word32 Rx, Word32
                                               Rs, Word32 Iu4, Word32 IU5)
                Rx=tableidxd(Rs,#u4,#U5)       Word32 Q6_R_tableidxd_RII(Word32 Rx, Word32
                                               Rs, Word32 Iu4, Word32 IU5)
                Rx=tableidxh(Rs,#u4,#U5)       Word32 Q6_R_tableidxh_RII(Word32 Rx, Word32
                                               Rs, Word32 Iu4, Word32 IU5)
                Rx=tableidxw(Rs,#u4,#U5)       Word32 Q6_R_tableidxw_RII(Word32 Rx, Word32
                                               Rs, Word32 Iu4, Word32 IU5)




80-N2040-36 B                                 481

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6    5     4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp               x5
1   0   0    0   0    1   1    1   0   0   i   s   s   s    s   s   P   P   I   I     I   I   I   I   i     i     i   x   x   x    x   x   Rx=tableidxb(Rs,#u4,#S6):raw
1   0   0    0   0    1   1    1   0   1   i   s   s   s    s   s   P   P   I   I     I   I   I   I   i     i     i   x   x   x    x   x   Rx=tableidxh(Rs,#u4,#S6):raw
1   0   0    0   0    1   1    1   1   0   i   s   s   s    s   s   P   P   I   I     I   I   I   I   i     i     i   x   x   x    x   x   Rx=tableidxw(Rs,#u4,#S6):raw
1   0   0    0   0    1   1    1   1   1   i   s   s   s    s   s   P   P   I   I     I   I   I   I   i     i     i   x   x   x    x   x   Rx=tableidxd(Rs,#u4,#S6):raw




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          x5                       Field to encode register x
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   482

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



   11.10.3 XTYPE/COMPLEX
                    The XTYPE/COMPLEX instruction subclass includes instructions which are for complex
                    math, using imaginary values.

Complex add/sub halfwords
                    Cross vector add-sub or sub-add used to perform X+jY and X-jY complex operations.
                    Each 16-bit result is saturated to 16-bits.


                                       Rdd=vxaddsubh(Rss,Rtt):sat
                I                         R                    I                      R               Rss

                I                         R                    I                      R               Rtt

                    -                                              -
                +                         +                   +                      +

           Sat_16                       Sat_16             Sat_16                   Sat_16


                I                         R                    I                      R             Rdd



                               Rdd=vxsubaddh(Rss,Rt):rnd:>>1:sat
                I                         R                   I                      R               Rss
                I                         R                   I                      R                Rtt

                                   -                                            -
    1           +              1         +           1       +              1        +

            >>1                          >>1                 >>1                    >>1

                                                                                                   Rdd
           Sat_16                       Sat_16             Sat_16                   Sat_16


                I                         R                    I                      R




80-N2040-36 B                                        483

                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set




                                              Syntax                                                                     Behavior
                 Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat Rdd.h[0]=sat16((Rss.h[0]+Rtt.h[1]+1)>>1);
                                                    Rdd.h[1]=sat16((Rss.h[1]-Rtt.h[0]+1)>>1);
                                                    Rdd.h[2]=sat16((Rss.h[2]+Rtt.h[3]+1)>>1);
                                                    Rdd.h[3]=sat16((Rss.h[3]-Rtt.h[2]+1)>>1);
                 Rdd=vxaddsubh(Rss,Rtt):sat                                            Rdd.h[0]=sat16(Rss.h[0]+Rtt.h[1]);
                                                                                       Rdd.h[1]=sat16(Rss.h[1]-Rtt.h[0]);
                                                                                       Rdd.h[2]=sat16(Rss.h[2]+Rtt.h[3]);
                                                                                       Rdd.h[3]=sat16(Rss.h[3]-Rtt.h[2]);
                 Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat Rdd.h[0]=sat16((Rss.h[0]-Rtt.h[1]+1)>>1);
                                                    Rdd.h[1]=sat16((Rss.h[1]+Rtt.h[0]+1)>>1);
                                                    Rdd.h[2]=sat16((Rss.h[2]-Rtt.h[3]+1)>>1);
                                                    Rdd.h[3]=sat16((Rss.h[3]+Rtt.h[2]+1)>>1);
                 Rdd=vxsubaddh(Rss,Rtt):sat                                            Rdd.h[0]=sat16(Rss.h[0]-Rtt.h[1]);
                                                                                       Rdd.h[1]=sat16(Rss.h[1]+Rtt.h[0]);
                                                                                       Rdd.h[2]=sat16(Rss.h[2]-Rtt.h[3]);
                                                                                       Rdd.h[3]=sat16(Rss.h[3]+Rtt.h[2]);


                           Class: XTYPE (slots 2,3)

                           Notes

                                    ï®     If saturation occurs during execution of this instruction (a result is clamped to
                                          either maximum or minimum values), the OVF bit in the Status Register is set.
                                          OVF will remain set until explicitly cleared by a transfer to SR.

                           Intrinsics

                 Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat Word64 Q6_P_vxaddsubh_PP_rnd_rs1_sat(Word64
                                                    Rss, Word64 Rtt)
                 Rdd=vxaddsubh(Rss,Rtt):sat                                            Word64 Q6_P_vxaddsubh_PP_sat(Word64 Rss,
                                                                                       Word64 Rtt)
                 Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat Word64 Q6_P_vxsubaddh_PP_rnd_rs1_sat(Word64
                                                    Rss, Word64 Rtt)
                 Rdd=vxsubaddh(Rss,Rtt):sat                                            Word64 Q6_P_vxsubaddh_PP_sat(Word64 Rss,
                                                                                       Word64 Rtt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2    1   0
    ICLASS            RegType           Maj               s5           Parse                t5           Min                 d5
1   1   0    0    0    0   0    1   0     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   0   d   d   d    d   d   Rdd=vxaddsubh(Rss,Rtt):sat
1   1   0    0    0    0   0    1   0     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   0   d   d   d    d   d   Rdd=vxsubaddh(Rss,Rtt):sat
1   1   0    0    0    0   0    1   1     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   d   d   d    d   d   Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat
1   1   0    0    0    0   0    1   1     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   d   d   d    d   d   Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat




80-N2040-36 B                                                                      484

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       485

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



Complex add/sub words
                    Cross vector add-sub or sub-add used to perform X+jY and X-jY complex operations.
                    Each 32-bit result is saturated to 32-bits.


      Rdd=vxaddsubw(Rss,Rt):sat                                   Rdd=vxsubaddw(Rss,Rt):sat
                I                     R               Rss                I                      R                    Rss

                I                     R               Rtt                I                      R                    Rtt




            -                         +                                 +                      -

          Sat_32                    Sat_32                            Sat_32                 Sat_32


                I                     R             Rdd                  I                      R               Rdd


                                  Syntax                                       Behavior
                    Rdd=vxaddsubw(Rss,Rtt):sat            Rdd.w[0]=sat32(Rss.w[0]+Rtt.w[1]);
                                                          Rdd.w[1]=sat32(Rss.w[1]-Rtt.w[0]);
                    Rdd=vxsubaddw(Rss,Rtt):sat            Rdd.w[0]=sat32(Rss.w[0]-Rtt.w[1]);
                                                          Rdd.w[1]=sat32(Rss.w[1]+Rtt.w[0]);


                    Class: XTYPE (slots 2,3)

                    Notes

                        ï®   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), then the OVF bit in the Status Register is
                            set. OVF will remain set until explicitly cleared by a transfer to SR.

                    Intrinsics

                    Rdd=vxaddsubw(Rss,Rtt):sat          Word64 Q6_P_vxaddsubw_PP_sat(Word64 Rss,
                                                        Word64 Rtt)
                    Rdd=vxsubaddw(Rss,Rtt):sat          Word64 Q6_P_vxsubaddw_PP_sat(Word64 Rss,
                                                        Word64 Rtt)




80-N2040-36 B                                          486

                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse               t5           Min                 d5
1   1   0    0   0    0   0    1   0   1   -   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   0   d   d   d    d   d   Rdd=vxaddsubw(Rss,Rtt):sat
1   1   0    0   0    0   0    1   0   1   -   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   0   d   d   d    d   d   Rdd=vxsubaddw(Rss,Rtt):sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   487

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



Complex multiply
                Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
                halfword and an imaginary 16-bit value in the high halfword. Optionally, scale the result
                by 0-1 bits. Optionally, add a complex accumulator. Saturate the real and imaginary
                portions to 32-bits. The output has a real 32-bit value in the low word and an imaginary
                32-bit value in the high word. The Rt input can be optionally conjugated. Another option
                is that the result can be subtracted from the destination rather than accumulated.

                                                  Rxx+=cmpy(Rs,Rt):sat

                 Rs            I                  R                 I                     R            Rs


                 Rt            I                  R                 I                     R            Rt




                                   *                  *                 *                     *
                                    32                32                    32                32


                               <<0-1              <<0-1             <<0-1                 <<0-1

                                                                        -
                                          Add                                     Add


                                         Sat_32                                  Sat_32                      32



                       32



                                   Imaginary Accumulation           Real Accumulation

                                                            Rxx




80-N2040-36 B                                         488

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set




                              Syntax                                       Behavior
                Rdd=cmpy(Rs,Rt)[:<<1]:sat            Rdd.w[1]=sat32((Rs.h[1] * Rt.h[0])[<<1] +
                                                     (Rs.h[0] * Rt.h[1])[<<1]);
                                                     Rdd.w[0]=sat32((Rs.h[0] * Rt.h[0])[<<1] -
                                                     (Rs.h[1] * Rt.h[1])[<<1]);
                Rdd=cmpy(Rs,Rt*)[:<<1]:sat           Rdd.w[1]=sat32((Rs.h[1] * Rt.h[0])[<<1] -
                                                     (Rs.h[0] * Rt.h[1])[<<1]);
                                                     Rdd.w[0]=sat32((Rs.h[0] * Rt.h[0])[<<1] +
                                                     (Rs.h[1] * Rt.h[1])[<<1]);
                Rxx+=cmpy(Rs,Rt)[:<<1]:sat           Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] *
                                                     Rt.h[0])[<<1] + (Rs.h[0] * Rt.h[1])[<<1]);
                                                     Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] *
                                                     Rt.h[0])[<<1] - (Rs.h[1] * Rt.h[1])[<<1]);
                Rxx+=cmpy(Rs,Rt*)[:<<1]:sat          Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] *
                                                     Rt.h[0])[<<1] - (Rs.h[0] * Rt.h[1])[<<1]);
                                                     Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] *
                                                     Rt.h[0])[<<1] + (Rs.h[1] * Rt.h[1])[<<1]);
                Rxx-=cmpy(Rs,Rt)[:<<1]:sat           Rxx.w[1]=sat32(Rxx.w[1] - ((Rs.h[1] *
                                                     Rt.h[0])[<<1] + (Rs.h[0] * Rt.h[1])[<<1]));
                                                     Rxx.w[0]=sat32(Rxx.w[0] - ((Rs.h[0] *
                                                     Rt.h[0])[<<1] - (Rs.h[1] * Rt.h[1])[<<1]));
                Rxx-=cmpy(Rs,Rt*)[:<<1]:sat          Rxx.w[1]=sat32(Rxx.w[1] - ((Rs.h[1] *
                                                     Rt.h[0])[<<1] - (Rs.h[0] * Rt.h[1])[<<1]));
                                                     Rxx.w[0]=sat32(Rxx.w[0] - ((Rs.h[0] *
                                                     Rt.h[0])[<<1] + (Rs.h[1] * Rt.h[1])[<<1]));


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rdd=cmpy(Rs,Rt):<<1:sat              Word64 Q6_P_cmpy_RR_s1_sat(Word32 Rs,
                                                     Word32 Rt)
                Rdd=cmpy(Rs,Rt):sat                  Word64 Q6_P_cmpy_RR_sat(Word32 Rs, Word32
                                                     Rt)
                Rdd=cmpy(Rs,Rt*):<<1:sat             Word64 Q6_P_cmpy_RR_conj_s1_sat(Word32 Rs,
                                                     Word32 Rt)
                Rdd=cmpy(Rs,Rt*):sat                 Word64 Q6_P_cmpy_RR_conj_sat(Word32 Rs,
                                                     Word32 Rt)
                Rxx+=cmpy(Rs,Rt):<<1:sat             Word64 Q6_P_cmpyacc_RR_s1_sat(Word64 Rxx,
                                                     Word32 Rs, Word32 Rt)
                Rxx+=cmpy(Rs,Rt):sat                 Word64 Q6_P_cmpyacc_RR_sat(Word64 Rxx,
                                                     Word32 Rs, Word32 Rt)
                Rxx+=cmpy(Rs,Rt*):<<1:sat            Word64 Q6_P_cmpyacc_RR_conj_s1_sat(Word64
                                                     Rxx, Word32 Rs, Word32 Rt)



80-N2040-36 B                                      489

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Rxx+=cmpy(Rs,Rt*):sat                                 Word64 Q6_P_cmpyacc_RR_conj_sat(Word64 Rxx,
                                                                                Word32 Rs, Word32 Rt)
                          Rxx-=cmpy(Rs,Rt):<<1:sat                              Word64 Q6_P_cmpynac_RR_s1_sat(Word64 Rxx,
                                                                                Word32 Rs, Word32 Rt)
                          Rxx-=cmpy(Rs,Rt):sat                                  Word64 Q6_P_cmpynac_RR_sat(Word64 Rxx,
                                                                                Word32 Rs, Word32 Rt)
                          Rxx-=cmpy(Rs,Rt*):<<1:sat                             Word64 Q6_P_cmpynac_RR_conj_s1_sat(Word64
                                                                                Rxx, Word32 Rs, Word32 Rt)
                          Rxx-=cmpy(Rs,Rt*):sat                                 Word64 Q6_P_cmpynac_RR_conj_sat(Word64 Rxx,
                                                                                Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse              t5               MinOp            d5
1   1   1    0   0    1   0    1   N 0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   d   d   d    d   d Rdd=cmpy(Rs,Rt)[:<<N]:sat
1   1   1    0   0    1   0    1   N 1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   d   d   d    d   d Rdd=cmpy(Rs,Rt*)[:<<N]:sat

    ICLASS           RegType       MajOp             s5           Parse              t5               MinOp            x5
1   1   1    0   0    1   1    1   N 0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   x   x   x    x   x  Rxx+=cmpy(Rs,Rt)[:<<N]:sat
1   1   1    0   0    1   1    1   N 0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   x   x   x    x   x  Rxx-=cmpy(Rs,Rt)[:<<N]:sat
1   1   1    0   0    1   1    1   N 1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   x   x   x    x   x  Rxx+=cmpy(Rs,Rt*)[:<<N]:sat
1   1   1    0   0    1   1    1   N 1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   x   x   x    x   x  Rxx-=cmpy(Rs,Rt*)[:<<N]:sat




                            Field name                                                        Description
                          ICLASS                 Instruction Class
                          MajOp                  Major Opcode
                          MinOp                  Minor Opcode
                          RegType                Register Type
                          Parse                  Packet/Loop parse bits
                          d5                     Field to encode register d
                          s5                     Field to encode register s
                          t5                     Field to encode register t
                          x5                     Field to encode register x




80-N2040-36 B                                                               490

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Complex multiply real or imaginary
                Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
                halfword and an imaginary 16-bit value in the high halfword. Take either the real or
                imaginary result and optionally accumulate with a 64-bit destination.


                                   Rxx+=cmpyi(Rs,Rt)

                                        I                    R          Rs


                                        I                    R           Rt




                                            *                    *
                                                32
                                                                 32



                                                     Add

                                                                                               64

                                                                                         Rxx
                                       Imaginary Accumulation


                              Syntax                                          Behavior
                Rdd=cmpyi(Rs,Rt)                           Rdd = (Rs.h[1] * Rt.h[0]) + (Rs.h[0] *
                                                           Rt.h[1]);
                Rdd=cmpyr(Rs,Rt)                           Rdd = (Rs.h[0] * Rt.h[0]) - (Rs.h[1] *
                                                           Rt.h[1]);
                Rxx+=cmpyi(Rs,Rt)                          Rxx = Rxx + (Rs.h[1] * Rt.h[0]) + (Rs.h[0]
                                                           * Rt.h[1]);
                Rxx+=cmpyr(Rs,Rt)                          Rxx = Rxx + (Rs.h[0] * Rt.h[0]) - (Rs.h[1]
                                                           * Rt.h[1]);




80-N2040-36 B                                          491

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=cmpyi(Rs,Rt)                                         Word64 Q6_P_cmpyi_RR(Word32 Rs, Word32 Rt)
                          Rdd=cmpyr(Rs,Rt)                                         Word64 Q6_P_cmpyr_RR(Word32 Rs, Word32 Rt)
                          Rxx+=cmpyi(Rs,Rt)                                        Word64 Q6_P_cmpyiacc_RR(Word64 Rxx, Word32
                                                                                   Rs, Word32 Rt)
                          Rxx+=cmpyr(Rs,Rt)                                        Word64 Q6_P_cmpyracc_RR(Word64 Rxx, Word32
                                                                                   Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   0    1   0    1   0    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rdd=cmpyi(Rs,Rt)
1   1   1    0   0    1   0    1   0    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    1   0   d   d   d    d   d Rdd=cmpyr(Rs,Rt)
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   0    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=cmpyi(Rs,Rt)
1   1   1    0   0    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    1   0   x   x   x    x   x Rxx+=cmpyr(Rs,Rt)




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  492

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                 Instruction Set



Complex multiply with round and pack
                Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
                halfword and an imaginary 16-bit value in the high halfword. The Rt input is optionally
                conjugated. The multiplier results are optionally scaled by 0-1 bits. A rounding constant is
                added to each real and imaginary sum. The real and imaginary parts are individually
                saturated to 32bits. The upper 16-bits of each 32-bit results are packed in a 32-bit
                destination register.


                                                   Rd=cmpy(Rs,Rt):rnd:sat

                 Rs             I                   R                    I                       R            Rs


                 Rt             I                   R                    I                       R            Rt




                                    *                   *                    *                       *
                                    32                  32                       32                  32


                  0x8000        <<0-1                <<0-1               <<0-1                   <<0-1       0x8000
                                                                             -
                                          Add                                          Add



                                         Sat_32                                       Sat_32

                                                  High 16bits                    High 16bits


                                                            I           R                 Rd


                              Syntax                                                  Behavior
                Rd=cmpy(Rs,Rt)[:<<1]:rnd:sat                Rd.h[1]=(sat32((Rs.h[1] * Rt.h[0])[<<1] +
                                                            (Rs.h[0] * Rt.h[1])[<<1] + 0x8000)).h[1];
                                                            Rd.h[0]=(sat32((Rs.h[0] * Rt.h[0])[<<1] -
                                                            (Rs.h[1] * Rt.h[1])[<<1] + 0x8000)).h[1];
                Rd=cmpy(Rs,Rt*)[:<<1]:rnd:sat Rd.h[1]=(sat32((Rs.h[1] * Rt.h[0])[<<1] -
                                              (Rs.h[0] * Rt.h[1])[<<1] + 0x8000)).h[1];
                                              Rd.h[0]=(sat32((Rs.h[0] * Rt.h[0])[<<1] +
                                              (Rs.h[1] * Rt.h[1])[<<1] + 0x8000)).h[1];




80-N2040-36 B                                           493

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), then the OVF bit in the Status Register is
                                        set. OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=cmpy(Rs,Rt):<<1:rnd:sat                              Word32 Q6_R_cmpy_RR_s1_rnd_sat(Word32 Rs,
                                                                                  Word32 Rt)
                          Rd=cmpy(Rs,Rt):rnd:sat                                  Word32 Q6_R_cmpy_RR_rnd_sat(Word32 Rs,
                                                                                  Word32 Rt)
                          Rd=cmpy(Rs,Rt*):<<1:rnd:sat                             Word32 Q6_R_cmpy_RR_conj_s1_rnd_sat(Word32
                                                                                  Rs, Word32 Rt)
                          Rd=cmpy(Rs,Rt*):rnd:sat                                 Word32 Q6_R_cmpy_RR_conj_rnd_sat(Word32 Rs,
                                                                                  Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp           s5           Parse              t5               MinOp            d5

1   1   1    0   1    1   0    1   N 0     1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   d   d   d    d   d Rd=cmpy(Rs,Rt)[:<<N]:rnd:sat
1   1   1    0   1    1   0    1   N 1     1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   d   d   d    d   d Rd=cmpy(Rs,Rt*)[:<<N]:rnd:sat




                            Field name                                                          Description
                          ICLASS                   Instruction Class
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                 494

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                     Instruction Set



Complex multiply 32x16
                    Multiply 32 by 16 bit complex values Rss and Rt. The inputs have a real value in the low
                    part of a register and the imaginary value in the upper part. The multiplier results are
                    scaled by 1 bit and accumulated with a rounding constant. The result is saturated to 32bits.


   Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat                                             Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat
                I                              R               Rss                     I                            R                  Rss

                                        I            R          Rt                                    I              R          Rt



                       *                             *                                      *    48
                                                                                                                           *
                             48
                                                     48                                                                   48
                                                               0x8000                                                                0x8000
                                  <<1          <<1                                               <<1               <<1
                              -
                                         Add                                                                 Add


                                        Sat_32                                                             Sat_32


                                   Real result            Rd                                              Imag result           Rd



                                        Syntax                                        Behavior
                Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat                       Rd = sat32(( (Rss.w[0] * Rt.h[1]) +
                                                                     (Rss.w[1] * Rt.h[0]) + 0x4000)>>15);
                Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat Rd = sat32(( (Rss.w[1] * Rt.h[0]) -
                                                (Rss.w[0] * Rt.h[1]) + 0x4000)>>15);
                Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat                       Rd = sat32(( (Rss.w[0] * Rt.h[0]) -
                                                                     (Rss.w[1] * Rt.h[1]) + 0x4000)>>15);
                Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat Rd = sat32(( (Rss.w[0] * Rt.h[0]) +
                                                (Rss.w[1] * Rt.h[1]) + 0x4000)>>15);


                    Class: XTYPE (slots 2,3)

                    Notes

                         ï®    If saturation occurs during execution of this instruction (a result is clamped to
                              either maximum or minimum values), the OVF bit in the Status Register is set.
                              OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                                    495

                     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Intrinsics

                     Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat                                 Word32 Q6_R_cmpyiwh_PR_s1_rnd_sat(Word64
                                                                                    Rss, Word32 Rt)
                     Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat Word32
                                                     Q6_R_cmpyiwh_PR_conj_s1_rnd_sat(Word64 Rss,
                                                     Word32 Rt)
                     Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat                                 Word32 Q6_R_cmpyrwh_PR_s1_rnd_sat(Word64
                                                                                    Rss, Word32 Rt)
                     Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat Word32
                                                     Q6_R_cmpyrwh_PR_conj_s1_rnd_sat(Word64 Rss,
                                                     Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                t5           Min                 d5
1   1   0    0   0    1   0    1   -   -   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   0   d   d   d    d   d Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat
1   1   0    0   0    1   0    1   -   -   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   1   d   d   d    d   d Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat
1   1   0    0   0    1   0    1   -   -   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   0   d   d   d    d   d Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat
1   1   0    0   0    1   0    1   -   -   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   1   d   d   d    d   d Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   496

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



Vector complex multiply real or imaginary
                The inputs Rss and Rtt are a vector of two complex values. Each complex value is
                composed of a 16-bit imaginary portion in the upper halfword and a 16-bit real portion in
                the lower halfword. Generate two complex results, either the real result or the imaginary
                result. These results are optionally shifted left by 0-1 bits, and optionally accumulated
                with the destination register.

                                        Rxx+=vcmpyi(Rss,Rtt):sat

                               I                 R               I                 R        Rss


                               I                 R               I                 R        Rtt




                                   *                 *               *                 *
                                   32                32              32                32


                               <<0-1             <<0-1           <<0-1             <<0-1




                                         Add                               Add


                                        Sat_32                            Sat_32                  32



                   32



                               Imag Accumulation                 Imag Accumulation

                                                           Rxx




80-N2040-36 B                                        497

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set




                              Syntax                                       Behavior
                Rdd=vcmpyi(Rss,Rtt)[:<<1]:sat Rdd.w[0]=sat32((Rss.h[1] * Rtt.h[0]) +
                                              (Rss.h[0] * Rtt.h[1])[<<1]);
                                              Rdd.w[1]=sat32((Rss.h[3] * Rtt.h[2]) +
                                              (Rss.h[2] * Rtt.h[3])[<<1]);
                Rdd=vcmpyr(Rss,Rtt)[:<<1]:sat Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0]) -
                                              (Rss.h[1] * Rtt.h[1])[<<1]);
                                              Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2]) -
                                              (Rss.h[3] * Rtt.h[3])[<<1]);
                Rxx+=vcmpyi(Rss,Rtt):sat             Rxx.w[0]=sat32(Rxx.w[0]       + (Rss.h[1] *
                                                     Rtt.h[0]) + (Rss.h[0] *       Rtt.h[1])<<0);
                                                     Rxx.w[1]=sat32(Rxx.w[1]       + (Rss.h[3] *
                                                     Rtt.h[2]) + (Rss.h[2] *       Rtt.h[3])<<0);
                Rxx+=vcmpyr(Rss,Rtt):sat             Rxx.w[0]=sat32(Rxx.w[0]       + (Rss.h[0] *
                                                     Rtt.h[0]) - (Rss.h[1] *       Rtt.h[1])<<0);
                                                     Rxx.w[1]=sat32(Rxx.w[1]       + (Rss.h[2] *
                                                     Rtt.h[2]) - (Rss.h[3] *       Rtt.h[3])<<0);


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rdd=vcmpyi(Rss,Rtt):<<1:sat          Word64 Q6_P_vcmpyi_PP_s1_sat(Word64 Rss,
                                                     Word64 Rtt)
                Rdd=vcmpyi(Rss,Rtt):sat              Word64 Q6_P_vcmpyi_PP_sat(Word64 Rss,
                                                     Word64 Rtt)
                Rdd=vcmpyr(Rss,Rtt):<<1:sat          Word64 Q6_P_vcmpyr_PP_s1_sat(Word64 Rss,
                                                     Word64 Rtt)
                Rdd=vcmpyr(Rss,Rtt):sat              Word64 Q6_P_vcmpyr_PP_sat(Word64 Rss,
                                                     Word64 Rtt)
                Rxx+=vcmpyi(Rss,Rtt):sat             Word64 Q6_P_vcmpyiacc_PP_sat(Word64 Rxx,
                                                     Word64 Rss, Word64 Rtt)
                Rxx+=vcmpyr(Rss,Rtt):sat             Word64 Q6_P_vcmpyracc_PP_sat(Word64 Rxx,
                                                     Word64 Rss, Word64 Rtt)




80-N2040-36 B                                      498

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            d5
1   1   1    0   1    0   0    0   N 0      1   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   0   d   d   d    d   d   Rdd=vcmpyr(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   0    0   N 1      0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   0   d   d   d    d   d   Rdd=vcmpyi(Rss,Rtt)[:<<N]:sat
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            x5
1   1   1    0   1    0   1    0   0    0   1   s   s   s    s   s   P   P 0   t   t   t    t   t   1    0   0   x   x   x    x   x Rxx+=vcmpyr(Rss,Rtt):sat
1   1   1    0   1    0   1    0   0    1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    0   0   x   x   x    x   x Rxx+=vcmpyi(Rss,Rtt):sat




                            Field name                                                          Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  499

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector complex conjugate
                          Perform a vector complex conjugate of both complex values in vector Rss. This is done by
                          negating the imaginary halfwords, and placing the result in destination Rdd.

                                               Syntax                                                                 Behavior
                          Rdd=vconj(Rss):sat                                        Rdd.h[1]=sat16(-Rss.h[1]);
                                                                                    Rdd.h[0]=Rss.h[0];
                                                                                    Rdd.h[3]=sat16(-Rss.h[3]);
                                                                                    Rdd.h[2]=Rss.h[2];


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), then the OVF bit in the Status Register is
                                       set. OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vconj(Rss):sat                                        Word64 Q6_P_vconj_P_sat(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   1   d   d   d    d   d Rdd=vconj(Rss):sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   500

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                            Instruction Set



Vector complex rotate
                Take the least significant bits of Rt, and use these bits to rotate each of the two complex
                values in the source vector a multiple of 90 degrees. Bits 0 and 1 control the rotation factor
                for word 0, and bits 2 and 3 control the rotation factor for word 1.

                If the rotation control bits are 0, the rotation is 0: the real and imaginary halves of the
                source appear unchanged and unmoved in the destination.

                If the rotation control bits are 1, the rotation is -pi/2: the real half of the destination gets the
                imaginary half of the source, and the imaginary half of the destination gets the negative
                real half of the source.

                If the rotation control bits are 2, the rotation is pi/2: the real half of the destination gets the
                negative imaginary half of the source, and the imaginary half of the destination gets the
                real half of the source.

                If the rotation control bits are 3, the rotation is pi: the real half of the destination gets the
                negative real half of the source, and the imaginary half of the destination gets the negative
                imaginary half of the source.

                                Syntax                                           Behavior
                Rdd=vcrotate(Rss,Rt)                    tmp = Rt[1:0];
                                                        if (tmp == 0) {
                                                            Rdd.h[0]=Rss.h[0];
                                                            Rdd.h[1]=Rss.h[1];
                                                        } else if (tmp == 1) {
                                                            Rdd.h[0]=Rss.h[1];
                                                            Rdd.h[1]=sat16(-Rss.h[0]);
                                                        } else if (tmp == 2) {
                                                            Rdd.h[0]=sat16(-Rss.h[1]);
                                                            Rdd.h[1]=Rss.h[0];
                                                        } else {
                                                            Rdd.h[0]=sat16(-Rss.h[0]);
                                                            Rdd.h[1]=sat16(-Rss.h[1]);
                                                        };
                                                        tmp = Rt[3:2];
                                                        if (tmp == 0) {
                                                            Rdd.h[2]=Rss.h[2];
                                                            Rdd.h[3]=Rss.h[3];
                                                        } else if (tmp == 1) {
                                                            Rdd.h[2]=Rss.h[3];
                                                            Rdd.h[3]=sat16(-Rss.h[2]);
                                                        } else if (tmp == 2) {
                                                            Rdd.h[2]=sat16(-Rss.h[3]);
                                                            Rdd.h[3]=Rss.h[2];
                                                        } else {
                                                            Rdd.h[2]=sat16(-Rss.h[2]);
                                                            Rdd.h[3]=sat16(-Rss.h[3]);
                                                        };




80-N2040-36 B                                          501

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®     If saturation occurs during execution of this instruction (a result is clamped to
                                         either maximum or minimum values), the OVF bit in the Status Register is set.
                                         OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vcrotate(Rss,Rt)                                        Word64 Q6_P_vcrotate_PR(Word64 Rss, Word32
                                                                                      Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS           RegType           Maj               s5           Parse                t5           Min                 d5
1   1   0    0   0    0   1    1   1     1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   d   d   d    d   d Rdd=vcrotate(Rss,Rt)




                            Field name                                                              Description
                          ICLASS                     Instruction Class
                          Parse                      Packet/Loop parse bits
                          d5                         Field to encode register d
                          s5                         Field to encode register s
                          t5                         Field to encode register t
                          Maj                        Major Opcode
                          Min                        Minor Opcode
                          RegType                    Register Type




80-N2040-36 B                                                                     502

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Vector reduce complex multiply real or imaginary
                The input vectors are two packed complex values, each with a real low halfword and
                imaginary high halfword. Compute either the real or imaginary products, add the
                intermediate results together and optionally accumulate with the destination. The Rtt input
                is optionally conjugated (negate the imaginary portion) before multiplication.

                Using vrcmpyr and vrcmpyi, it is possible to sustain an average of one full complex
                multiply per cycle in a complex FIR, while also keeping both the real and imaginary
                accumulators in full precision 64-bit values.


                                          Rxx+=vrcmpyi(Rss,Rtt)

                         I                  R                  I             R           Rss


                         I                  R                  I             R            Rtt




                             *     32
                                                *                  *             *
                                                    32             32
                                                                        32

                                                    Add

                                                                                                64

                                                                                        Rxx
                                          Imaginary Accumulation


                                 Syntax                                      Behavior
                Rdd=vrcmpyi(Rss,Rtt)                      Rdd = (Rss.h[1] * Rtt.h[0]) + (Rss.h[0] *
                                                          Rtt.h[1]) + (Rss.h[3] * Rtt.h[2]) +
                                                          (Rss.h[2] * Rtt.h[3]);
                Rdd=vrcmpyi(Rss,Rtt*)                     Rdd = (Rss.h[1] * Rtt.h[0]) - (Rss.h[0] *
                                                          Rtt.h[1]) + (Rss.h[3] * Rtt.h[2]) -
                                                          (Rss.h[2] * Rtt.h[3]);
                Rdd=vrcmpyr(Rss,Rtt)                      Rdd = (Rss.h[0] * Rtt.h[0]) - (Rss.h[1] *
                                                          Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) -
                                                          (Rss.h[3] * Rtt.h[3]);




80-N2040-36 B                                            503

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                                                Syntax                                                                Behavior
                          Rdd=vrcmpyr(Rss,Rtt*)                                    Rdd = (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
                                                                                   Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) +
                                                                                   (Rss.h[3] * Rtt.h[3]);
                          Rxx+=vrcmpyi(Rss,Rtt)                                    Rxx = Rxx + (Rss.h[1] * Rtt.h[0]) +
                                                                                   (Rss.h[0] * Rtt.h[1]) + (Rss.h[3] *
                                                                                   Rtt.h[2]) + (Rss.h[2] * Rtt.h[3]);
                          Rxx+=vrcmpyi(Rss,Rtt*)                                   Rxx = Rxx + (Rss.h[1] * Rtt.h[0]) -
                                                                                   (Rss.h[0] * Rtt.h[1]) + (Rss.h[3] *
                                                                                   Rtt.h[2]) - (Rss.h[2] * Rtt.h[3]);
                          Rxx+=vrcmpyr(Rss,Rtt)                                    Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) -
                                                                                   (Rss.h[1] * Rtt.h[1]) + (Rss.h[2] *
                                                                                   Rtt.h[2]) - (Rss.h[3] * Rtt.h[3]);
                          Rxx+=vrcmpyr(Rss,Rtt*)                                   Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) +
                                                                                   (Rss.h[1] * Rtt.h[1]) + (Rss.h[2] *
                                                                                   Rtt.h[2]) + (Rss.h[3] * Rtt.h[3]);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vrcmpyi(Rss,Rtt)                                     Word64 Q6_P_vrcmpyi_PP(Word64 Rss, Word64
                                                                                   Rtt)
                          Rdd=vrcmpyi(Rss,Rtt*)                                    Word64 Q6_P_vrcmpyi_PP_conj(Word64 Rss,
                                                                                   Word64 Rtt)
                          Rdd=vrcmpyr(Rss,Rtt)                                     Word64 Q6_P_vrcmpyr_PP(Word64 Rss, Word64
                                                                                   Rtt)
                          Rdd=vrcmpyr(Rss,Rtt*)                                    Word64 Q6_P_vrcmpyr_PP_conj(Word64 Rss,
                                                                                   Word64 Rtt)
                          Rxx+=vrcmpyi(Rss,Rtt)                                    Word64 Q6_P_vrcmpyiacc_PP(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)
                          Rxx+=vrcmpyi(Rss,Rtt*)                                   Word64 Q6_P_vrcmpyiacc_PP_conj(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)
                          Rxx+=vrcmpyr(Rss,Rtt)                                    Word64 Q6_P_vrcmpyracc_PP(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)
                          Rxx+=vrcmpyr(Rss,Rtt*)                                   Word64 Q6_P_vrcmpyracc_PP_conj(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   0    0   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vrcmpyi(Rss,Rtt)
1   1   1    0   1    0   0    0   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vrcmpyr(Rss,Rtt)
1   1   1    0   1    0   0    0   0    1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rdd=vrcmpyi(Rss,Rtt*)
1   1   1    0   1    0   0    0   0    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   1   d   d   d    d   d Rdd=vrcmpyr(Rss,Rtt*)




80-N2040-36 B                                                                  504

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            x5
1   1   1    0   1    0   1    0   0    0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   x   x   x    x   x Rxx+=vrcmpyi(Rss,Rtt)
1   1   1    0   1    0   1    0   0    0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vrcmpyr(Rss,Rtt)
1   1   1    0   1    0   1    0   0    1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   x   x   x    x   x Rxx+=vrcmpyi(Rss,Rtt*)
1   1   1    0   1    0   1    0   0    1   1   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vrcmpyr(Rss,Rtt*)




                            Field name                                                          Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  505

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                             Instruction Set



Vector reduce complex multiply by scalar
                Multiply a complex number by a scalar. Rss contains two complex numbers. The real
                portions are each multiplied by two scalars contained in register Rt, scaled, summed,
                optionally accumulated, saturated, and stored in the lower word of Rdd. A similar
                operation is done on the two imaginary portions of Rss.

                                                Rdd=vrcmpys(Rss,Rt):<<1:sat

                                   I                     R         I                     R               Rss


                 Rt            b                     a                 b                     a            Rt




                                   *                     *                 *                     *
                                       32                    32            32                    32


                                <<1                  <<1               <<1                   <<1




                                             Add                                 Add



                                            Sat_32                              Sat_32




                                        I                                                                      Rdd




80-N2040-36 B                                            506

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set




                         Syntax                                            Behavior
       Rdd=vrcmpys(Rss,Rt):<<1:sat                   if ("Rt & 1") {
                                                         Assembler mapped to:
                                                     "Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi";
                                                     } else {
                                                         Assembler mapped to:
                                                     "Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo";
                                                     };
       Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi           Rdd.w[1]=sat32((Rss.h[1] *
                                                     Rtt.w[1].h[0])<<1 + (Rss.h[3] *
                                                     Rtt.w[1].h[1])<<1);
                                                     Rdd.w[0]=sat32((Rss.h[0] *
                                                     Rtt.w[1].h[0])<<1 + (Rss.h[2] *
                                                     Rtt.w[1].h[1])<<1);
       Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo           Rdd.w[1]=sat32((Rss.h[1] *
                                                     Rtt.w[0].h[0])<<1 + (Rss.h[3] *
                                                     Rtt.w[0].h[1])<<1);
                                                     Rdd.w[0]=sat32((Rss.h[0] *
                                                     Rtt.w[0].h[0])<<1 + (Rss.h[2] *
                                                     Rtt.w[0].h[1])<<1);
       Rxx+=vrcmpys(Rss,Rt):<<1:sat                  if ("Rt & 1") {
                                                         Assembler mapped to:
                                                     "Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi";
                                                     } else {
                                                         Assembler mapped to:
                                                     "Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo";
                                                     };
       Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[1] *
                                            Rtt.w[1].h[0])<<1 + (Rss.h[3] *
                                            Rtt.w[1].h[1])<<1);
                                            Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *
                                            Rtt.w[1].h[0])<<1 + (Rss.h[2] *
                                            Rtt.w[1].h[1])<<1);
       Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[1] *
                                            Rtt.w[0].h[0])<<1 + (Rss.h[3] *
                                            Rtt.w[0].h[1])<<1);
                                            Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *
                                            Rtt.w[0].h[0])<<1 + (Rss.h[2] *
                                            Rtt.w[0].h[1])<<1);


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                      507

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Intrinsics

                          Rdd=vrcmpys(Rss,Rt):<<1:sat                              Word64 Q6_P_vrcmpys_PR_s1_sat(Word64 Rss,
                                                                                   Word32 Rt)
                          Rxx+=vrcmpys(Rss,Rt):<<1:sat Word64 Q6_P_vrcmpysacc_PR_s1_sat(Word64
                                                       Rxx, Word64 Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   0    0   1    0   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   d   d   d    d   d   Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi
1   1   1    0   1    0   0    0   1    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   d   d   d    d   d   Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            x5

1   1   1    0   1    0   1    0   1    0   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   x   x   x    x   x Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi
1   1   1    0   1    0   1    0   1    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   x   x   x    x   x Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  508

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                              Instruction Set



Vector reduce complex multiply by scalar with round and
pack
                Multiply a complex number by scalar. Rss contains two complex numbers. The real
                portions are each multiplied by two scalars contained in register Rt, scaled, summed,
                rounded, and saturated. The upper 16bits of this result are packed in the lower halfword of
                Rd. A similar operation is done on the two imaginary portions of Rss.

                                               Rd=vrcmpys(Rss,Rt):<<1:rnd:sat

                                   I                       R        I                     R               Rss


                 Rt            b                       a                b                     a            Rt




                                   *                       *                *                     *
                                       32                      32           32                    32


                  0x8000        <<0-1                   <<0-1           <<0-1                 <<0-1       0x8000



                                             Add                                  Add



                                            Sat_32                               Sat_32

                                                     High 16bits            High 16bits


                                                               I        R            Rd




80-N2040-36 B                                              509

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set




                                         Syntax                                                                        Behavior
        Rd=vrcmpys(Rss,Rt):<<1:rnd:sat                                              if ("Rt & 1") {
                                                                                        Assembler mapped to:
                                                                                    "Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi";
                                                                                    } else {
                                                                                        Assembler mapped to:
                                                                                    "Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo";
                                                                                    };
        Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi Rd.h[1]=sat32((Rss.h[1] * Rtt.w[1].h[0])<<1
                                               + (Rss.h[3] * Rtt.w[1].h[1])<<1 +
                                               0x8000).h[1];
                                               Rd.h[0]=sat32((Rss.h[0] * Rtt.w[1].h[0])<<1
                                               + (Rss.h[2] * Rtt.w[1].h[1])<<1 +
                                               0x8000).h[1];
        Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo Rd.h[1]=sat32((Rss.h[1] * Rtt.w[0].h[0])<<1
                                               + (Rss.h[3] * Rtt.w[0].h[1])<<1 +
                                               0x8000).h[1];
                                               Rd.h[0]=sat32((Rss.h[0] * Rtt.w[0].h[0])<<1
                                               + (Rss.h[2] * Rtt.w[0].h[1])<<1 +
                                               0x8000).h[1];


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), the OVF bit in the Status Register is set.
                                        OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                 Rd=vrcmpys(Rss,Rt):<<1:rnd:sat Word32 Q6_R_vrcmpys_PR_s1_rnd_sat(Word64 Rss,
                                                Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp             s5           Parse              t5               MinOp            d5

1   1   1    0   1    0   0    1   1     -   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   0   d   d   d    d   d Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi
1   1   1    0   1    0   0    1   1     -   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   d   d   d    d   d Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo




                            Field name                                                            Description
                          ICLASS                     Instruction Class
                          MajOp                      Major Opcode
                          MinOp                      Minor Opcode
                          RegType                    Register Type
                          Parse                      Packet/Loop parse bits




80-N2040-36 B                                                                   510

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       511

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                          Instruction Set



Vector reduce complex rotate
                This instruction is useful for CDMA despreading. An unsigned 2-bit immediate specifies a
                byte to use in Rt. Each of four 2-bit fields in the specified byte selects a rotation amount
                for one of the four complex numbers in Rss. The real and imaginary products are
                accumulated and stored as a 32-bit complex number in Rd. Optionally, the destination
                register can also be accumulated.
                 Rxx += vrcrotate(Rss,Rt,#0)



                                                                                         Rt




                           1 j -1 -j           1 j -1 -j         1 j -1 -j             1 j -1 -j

                              mux                mux               mux                   mux




                           Im3       Re3        Im2        Re2    Im1        Re1       Im0       Re0         Rss




                                 *                *                 *                        *

                                       +                                           +


                                           I                                   R                       Rxx




80-N2040-36 B                                                    512

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                             Syntax                                Behavior
                Rdd=vrcrotate(Rss,Rt,#u2)      sumr = 0;
                                               sumi = 0;
                                               control = Rt.ub[#u];
                                               for (i = 0; i < 8; i += 2) {
                                                   tmpr = Rss.b[i];
                                                   tmpi = Rss.b[i+1];
                                                   switch (control & 3) {
                                                       case 0: sumr += tmpr;
                                                       sumi += tmpi;
                                                       break;
                                                       case 1: sumr += tmpi;
                                                       sumi -= tmpr;
                                                       break;
                                                       case 2: sumr -= tmpi;
                                                       sumi += tmpr;
                                                       break;
                                                       case 3: sumr -= tmpr;
                                                       sumi -= tmpi;
                                                       break;
                                                   };
                                                   control = control >> 2;
                                               };
                                               Rdd.w[0]=sumr;
                                               Rdd.w[1]=sumi;
                Rxx+=vrcrotate(Rss,Rt,#u2)     sumr = 0;
                                               sumi = 0;
                                               control = Rt.ub[#u];
                                               for (i = 0; i < 8; i += 2) {
                                                   tmpr = Rss.b[i];
                                                   tmpi = Rss.b[i+1];
                                                   switch (control & 3) {
                                                       case 0: sumr += tmpr;
                                                       sumi += tmpi;
                                                       break;
                                                       case 1: sumr += tmpi;
                                                       sumi -= tmpr;
                                                       break;
                                                       case 2: sumr -= tmpi;
                                                       sumi += tmpr;
                                                       break;
                                                       case 3: sumr -= tmpr;
                                                       sumi -= tmpi;
                                                       break;
                                                   };
                                                   control = control >> 2;
                                               };
                                               Rxx.w[0]=Rxx.w[0] + sumr;
                                               Rxx.w[1]=Rxx.w[1] + sumi;


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rdd=vrcrotate(Rss,Rt,#u2)      Word64 Q6_P_vrcrotate_PRI(Word64 Rss,
                                               Word32 Rt, Word32 Iu2)
                Rxx+=vrcrotate(Rss,Rt,#u2)     Word64 Q6_P_vrcrotateacc_PRI(Word64 Rxx,
                                               Word64 Rss, Word32 Rt, Word32 Iu2)



80-N2040-36 B                                 513

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse               t5           Min                 d5
1   1   0    0   0    0   1    1   1   1   -   s   s   s    s   s   P   P   i   t   t   t    t   t   1   1   i   d   d   d    d   d Rdd=vrcrotate(Rss,Rt,#u2)
    ICLASS           RegType       Maj                 s5           Parse               t5                               x5
1   1   0    0   1    0   1    1   1   0   1   s   s   s    s   s   P   P   i   t   t   t    t   t   -   -   i   x   x   x    x   x Rxx+=vrcrotate(Rss,Rt,#u2)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          x5                       Field to encode register x
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   514

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                  Instruction Set



   11.10.4 XTYPE/FP
                The XTYPE/FP instruction subclass includes instructions which are for floating point
                math.




80-N2040-36 B                                     515

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Floating point addition
                          Add two floating point values

                                                Syntax                                                                Behavior
                          Rd=sfadd(Rs,Rt)                                          Rd=Rs+Rt;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sfadd(Rs,Rt)                                          Word32 Q6_R_sfadd_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   1    1   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rd=sfadd(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  516

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Classify floating-point value
                          Classify floating point values. Classes are Normal, Subnormal, Zero, NaN, or Infinity. If
                          the number is one of the specified classes, return true.

                                               Syntax                                                                 Behavior
                          Pd=dfclass(Rss,#u5)                                       Pd = 0;
                                                                                    class = fpclassify(Rss);
                                                                                    if (#u.0 && (class == FP_ZERO)) Pd = 0xff;
                                                                                    if (#u.1 && (class == FP_NORMAL)) Pd =
                                                                                    0xff;
                                                                                    if (#u.2 && (class == FP_SUBNORMAL)) Pd =
                                                                                    0xff;
                                                                                    if (#u.3 && (class == FP_INFINITE)) Pd =
                                                                                    0xff;
                                                                                    if (#u.4 && (class == FP_NAN)) Pd = 0xff;
                                                                                    cancel_flags();
                          Pd=sfclass(Rs,#u5)                                        Pd = 0;
                                                                                    class = fpclassify(Rs);
                                                                                    if (#u.0 && (class == FP_ZERO)) Pd = 0xff;
                                                                                    if (#u.1 && (class == FP_NORMAL)) Pd =
                                                                                    0xff;
                                                                                    if (#u.2 && (class == FP_SUBNORMAL)) Pd =
                                                                                    0xff;
                                                                                    if (#u.3 && (class == FP_INFINITE)) Pd =
                                                                                    0xff;
                                                                                    if (#u.4 && (class == FP_NAN)) Pd = 0xff;
                                                                                    cancel_flags();


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=dfclass(Rss,#u5)                                       Byte Q6_p_dfclass_PI(Word64 Rss, Word32
                                                                                    Iu5)
                          Pd=sfclass(Rs,#u5)                                        Byte Q6_p_sfclass_RI(Word32 Rs, Word32 Iu5)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1    0
    ICLASS           RegType       MajOp               s5           Parse                                                          d2
1   0   0    0   0    1   0    1   1   1   1   s   s   s    s   s   P   P 0     i     i   i   i   i   -   -   -   -    -   -   d    d Pd=sfclass(Rs,#u5)
    ICLASS           RegType                           s5           Parse                                                          d2
1   1   0    1   1    1   0    0   1   0   0   s   s   s    s   s   P   P   -   0    0    0   i   i   i   i   i   1   0    -   d    d Pd=dfclass(Rss,#u5)




                            Field name                                                            Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits




80-N2040-36 B                                                                   517

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                d2             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                RegType        Register Type




80-N2040-36 B                                       518

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Compare floating-point value
                          Compare floating point values. p0 returns true if at least one value is a NaN, zero
                          otherwise.

                                               Syntax                                                                 Behavior
                          Pd=dfcmp.eq(Rss,Rtt)                                      Pd=Rss==Rtt ? 0xff : 0x00;
                          Pd=dfcmp.ge(Rss,Rtt)                                      Pd=Rss>=Rtt ? 0xff : 0x00;
                          Pd=dfcmp.gt(Rss,Rtt)                                      Pd=Rss>Rtt ? 0xff : 0x00;
                          Pd=dfcmp.uo(Rss,Rtt)                                      Pd=isunordered(Rss,Rtt) ? 0xff : 0x00;
                          Pd=sfcmp.eq(Rs,Rt)                                        Pd=Rs==Rt ? 0xff : 0x00;
                          Pd=sfcmp.ge(Rs,Rt)                                        Pd=Rs>=Rt ? 0xff : 0x00;
                          Pd=sfcmp.gt(Rs,Rt)                                        Pd=Rs>Rt ? 0xff : 0x00;
                          Pd=sfcmp.uo(Rs,Rt)                                        Pd=isunordered(Rs,Rt) ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Pd=dfcmp.eq(Rss,Rtt)                                      Byte Q6_p_dfcmp_eq_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=dfcmp.ge(Rss,Rtt)                                      Byte Q6_p_dfcmp_ge_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=dfcmp.gt(Rss,Rtt)                                      Byte Q6_p_dfcmp_gt_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=dfcmp.uo(Rss,Rtt)                                      Byte Q6_p_dfcmp_uo_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=sfcmp.eq(Rs,Rt)                                        Byte Q6_p_sfcmp_eq_RR(Word32 Rs, Word32 Rt)
                          Pd=sfcmp.ge(Rs,Rt)                                        Byte Q6_p_sfcmp_ge_RR(Word32 Rs, Word32 Rt)
                          Pd=sfcmp.gt(Rs,Rt)                                        Byte Q6_p_sfcmp_gt_RR(Word32 Rs, Word32 Rt)
                          Pd=sfcmp.uo(Rs,Rt)                                        Byte Q6_p_sfcmp_uo_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1    0
    ICLASS           RegType       Maj                 s5           Parse                t5           Min                          d2
1   1   0    0   0    1   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   -    -   -   d    d Pd=sfcmp.ge(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   -    -   -   d    d Pd=sfcmp.uo(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   -    -   -   d    d Pd=sfcmp.eq(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   0   -    -   -   d    d Pd=sfcmp.gt(Rs,Rt)




80-N2040-36 B                                                                   519

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2   1    0
    ICLASS           RegType                           s5           Parse               t5               MinOp                    d2
1   1   0    1   0    0   1    0   1   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0    0   0   -   -   -   d    d Pd=dfcmp.eq(Rss,Rtt)
1   1   0    1   0    0   1    0   1   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0    0   1   -   -   -   d    d Pd=dfcmp.gt(Rss,Rtt)
1   1   0    1   0    0   1    0   1   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0    1   0   -   -   -   d    d Pd=dfcmp.ge(Rss,Rtt)
1   1   0    1   0    0   1    0   1   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0    1   1   -   -   -   d    d Pd=dfcmp.uo(Rss,Rtt)




                            Field name                                                           Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   520

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Convert floating-point value to other format
                          Convert floating point values. If rounding is required, it happens according to the rounding
                          mode.

                                               Syntax                                                                 Behavior
                          Rd=convert_df2sf(Rss)                                     Rd = conv_df_to_sf(Rss);
                          Rdd=convert_sf2df(Rs)                                     Rdd = conv_sf_to_df(Rs);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=convert_df2sf(Rss)                                     Word32 Q6_R_convert_df2sf_P(Word64 Rss)
                          Rdd=convert_sf2df(Rs)                                     Word64 Q6_P_convert_sf2df_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -   -   -   -   0    0   0   d   d   d    d   d Rdd=convert_sf2df(Rs)
1   0   0    0   1    0   0    0   0   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   0    0   1   d   d   d    d   d Rd=convert_df2sf(Rss)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   521

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Convert integer to floating-point value
                          Convert floating point values. If rounding is required, it happens according to the rounding
                          mode unless the :chop option is specified.

                                               Syntax                                                                  Behavior
                          Rd=convert_d2sf(Rss)                                      Rd = conv_8s_to_sf(Rss.s64);
                          Rd=convert_ud2sf(Rss)                                     Rd = conv_8u_to_sf(Rss.u64);
                          Rd=convert_uw2sf(Rs)                                      Rd = conv_4u_to_sf(Rs.uw[0]);
                          Rd=convert_w2sf(Rs)                                       Rd = conv_4s_to_sf(Rs.s32);
                          Rdd=convert_d2df(Rss)                                     Rdd = conv_8s_to_df(Rss.s64);
                          Rdd=convert_ud2df(Rss)                                    Rdd = conv_8u_to_df(Rss.u64);
                          Rdd=convert_uw2df(Rs)                                     Rdd = conv_4u_to_df(Rs.uw[0]);
                          Rdd=convert_w2df(Rs)                                      Rdd = conv_4s_to_df(Rs.s32);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=convert_d2sf(Rss)                                      Word32 Q6_R_convert_d2sf_P(Word64 Rss)
                          Rd=convert_ud2sf(Rss)                                     Word32 Q6_R_convert_ud2sf_P(Word64 Rss)
                          Rd=convert_uw2sf(Rs)                                      Word32 Q6_R_convert_uw2sf_R(Word32 Rs)
                          Rd=convert_w2sf(Rs)                                       Word32 Q6_R_convert_w2sf_R(Word32 Rs)
                          Rdd=convert_d2df(Rss)                                     Word64 Q6_P_convert_d2df_P(Word64 Rss)
                          Rdd=convert_ud2df(Rss)                                    Word64 Q6_P_convert_ud2df_P(Word64 Rss)
                          Rdd=convert_uw2df(Rs)                                     Word64 Q6_P_convert_uw2df_R(Word32 Rs)
                          Rdd=convert_w2df(Rs)                                      Word64 Q6_P_convert_w2df_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   0    0   0    0   1   1   1   s   s   s    s   s   P   P 0     -    -    -   -   -   0    1   0   d   d   d    d   d Rdd=convert_ud2df(Rss)
1   0   0    0   0    0   0    0   1   1   1   s   s   s    s   s   P   P 0     -    -    -   -   -   0    1   1   d   d   d    d   d Rdd=convert_d2df(Rss)
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -    -   -   -   0    0   1   d   d   d    d   d Rdd=convert_uw2df(Rs)
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -    -   -   -   0    1   0   d   d   d    d   d Rdd=convert_w2df(Rs)
1   0   0    0   1    0   0    0   0   0   1   s   s   s    s   s   P   P   -   -    -    -   -   -   0    0   1   d   d   d    d   d Rd=convert_ud2sf(Rss)
1   0   0    0   1    0   0    0   0   1   0   s   s   s    s   s   P   P   -   -    -    -   -   -   0    0   1   d   d   d    d   d Rd=convert_d2sf(Rss)
1   0   0    0   1    0   1    1   0   0   1   s   s   s    s   s   P   P   -   -    -    -   -   -   0    0   0   d   d   d    d   d Rd=convert_uw2sf(Rs)
1   0   0    0   1    0   1    1   0   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   0    0   0   d   d   d    d   d Rd=convert_w2sf(Rs)




80-N2040-36 B                                                                   522

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       523

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Convert floating-point value to integer
                Convert floating point values. If rounding is required, it happens according to the rounding
                mode unless the :chop option is specified. If the value is out of range of the destination
                integer type, the INVALID flag is raised and closest integer is chosen, including for
                infinite inputs. For NaN inputs, the INVALID flag is also raised, and the output value is
                IMPLEMENTATION DEFINED.

                               Syntax                                       Behavior
                Rd=convert_df2uw(Rss)                Rd = conv_df_to_4u(Rss).uw[0];
                Rd=convert_df2uw(Rss):chop           round_to_zero();
                                                     Rd = conv_df_to_4u(Rss).uw[0];
                Rd=convert_df2w(Rss)                 Rd = conv_df_to_4s(Rss).s32;
                Rd=convert_df2w(Rss):chop            round_to_zero();
                                                     Rd = conv_df_to_4s(Rss).s32;
                Rd=convert_sf2uw(Rs)                 Rd = conv_sf_to_4u(Rs).uw[0];
                Rd=convert_sf2uw(Rs):chop            round_to_zero();
                                                     Rd = conv_sf_to_4u(Rs).uw[0];
                Rd=convert_sf2w(Rs)                  Rd = conv_sf_to_4s(Rs).s32;
                Rd=convert_sf2w(Rs):chop             round_to_zero();
                                                     Rd = conv_sf_to_4s(Rs).s32;
                Rdd=convert_df2d(Rss)                Rdd = conv_df_to_8s(Rss).s64;
                Rdd=convert_df2d(Rss):chop           round_to_zero();
                                                     Rdd = conv_df_to_8s(Rss).s64;
                Rdd=convert_df2ud(Rss)               Rdd = conv_df_to_8u(Rss).u64;
                Rdd=convert_df2ud(Rss):chop          round_to_zero();
                                                     Rdd = conv_df_to_8u(Rss).u64;
                Rdd=convert_sf2d(Rs)                 Rdd = conv_sf_to_8s(Rs).s64;
                Rdd=convert_sf2d(Rs):chop            round_to_zero();
                                                     Rdd = conv_sf_to_8s(Rs).s64;
                Rdd=convert_sf2ud(Rs)                Rdd = conv_sf_to_8u(Rs).u64;
                Rdd=convert_sf2ud(Rs):chop           round_to_zero();
                                                     Rdd = conv_sf_to_8u(Rs).u64;




80-N2040-36 B                                       524

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rd=convert_df2uw(Rss)                                     Word32 Q6_R_convert_df2uw_P(Word64 Rss)
                          Rd=convert_df2uw(Rss):chop                                Word32 Q6_R_convert_df2uw_P_chop(Word64
                                                                                    Rss)
                          Rd=convert_df2w(Rss)                                      Word32 Q6_R_convert_df2w_P(Word64 Rss)
                          Rd=convert_df2w(Rss):chop                                 Word32 Q6_R_convert_df2w_P_chop(Word64 Rss)
                          Rd=convert_sf2uw(Rs)                                      Word32 Q6_R_convert_sf2uw_R(Word32 Rs)
                          Rd=convert_sf2uw(Rs):chop                                 Word32 Q6_R_convert_sf2uw_R_chop(Word32 Rs)
                          Rd=convert_sf2w(Rs)                                       Word32 Q6_R_convert_sf2w_R(Word32 Rs)
                          Rd=convert_sf2w(Rs):chop                                  Word32 Q6_R_convert_sf2w_R_chop(Word32 Rs)
                          Rdd=convert_df2d(Rss)                                     Word64 Q6_P_convert_df2d_P(Word64 Rss)
                          Rdd=convert_df2d(Rss):chop                                Word64 Q6_P_convert_df2d_P_chop(Word64 Rss)
                          Rdd=convert_df2ud(Rss)                                    Word64 Q6_P_convert_df2ud_P(Word64 Rss)
                          Rdd=convert_df2ud(Rss):chop                               Word64 Q6_P_convert_df2ud_P_chop(Word64
                                                                                    Rss)
                          Rdd=convert_sf2d(Rs)                                      Word64 Q6_P_convert_sf2d_R(Word32 Rs)
                          Rdd=convert_sf2d(Rs):chop                                 Word64 Q6_P_convert_sf2d_R_chop(Word32 Rs)
                          Rdd=convert_sf2ud(Rs)                                     Word64 Q6_P_convert_sf2ud_R(Word32 Rs)
                          Rdd=convert_sf2ud(Rs):chop                                Word64 Q6_P_convert_sf2ud_R_chop(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp            d5
1   0   0    0   0    0   0    0   1   1   1   s   s   s    s   s   P   P 0     -    -   -   -   -   0    0   0   d   d   d    d   d Rdd=convert_df2d(Rss)
1   0   0    0   0    0   0    0   1   1   1   s   s   s    s   s   P   P 0     -    -   -   -   -   0    0   1   d   d   d    d   d Rdd=convert_df2ud(Rss)
1   0   0    0   0    0   0    0   1   1   1   s   s   s    s   s   P   P 0     -    -   -   -   -   1    1   0   d   d   d    d   d Rdd=convert_df2d(Rss):chop
1   0   0    0   0    0   0    0   1   1   1   s   s   s    s   s   P   P 0     -    -   -   -   -   1    1   1   d   d   d    d   d Rdd=convert_df2ud(Rss):chop
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -   -   -   -   0    1   1   d   d   d    d   d Rdd=convert_sf2ud(Rs)
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   0   d   d   d    d   d Rdd=convert_sf2d(Rs)
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0   1   d   d   d    d   d Rdd=convert_sf2ud(Rs):ch
1   0   0    0   0    1   0    0   1   -   -   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   0   d   d   d    d   d Rdd=convert_sf2d(Rs):chop
1   0   0    0   1    0   0    0   0   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0    0   1   d   d   d    d   d Rd=convert_df2uw(Rss)
1   0   0    0   1    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -   -   -   -   0    0   1   d   d   d    d   d Rd=convert_df2w(Rss)
1   0   0    0   1    0   0    0   1   0   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0    0   1   d   d   d    d   d Rd=convert_df2uw(Rss):chop




80-N2040-36 B                                                                   525

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                 Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3   2   1   0
1   0   0   0   1   0   0   0   1   1   1   s   s   s   s   s   P   P   -   -   -     -   -   -   0   0   1   d   d   d   d   d Rd=convert_df2w(Rss):chop
1   0   0   0   1   0   1   1   0   1   1   s   s   s   s   s   P   P   -   -   -     -   -   -   0   0   0   d   d   d   d   d Rd=convert_sf2uw(Rs)
1   0   0   0   1   0   1   1   0   1   1   s   s   s   s   s   P   P   -   -   -     -   -   -   0   0   1   d   d   d   d   d Rd=convert_sf2uw(Rs):chop
1   0   0   0   1   0   1   1   1   0   0   s   s   s   s   s   P   P   -   -     -   -   -   -   0   0   0   d   d   d   d   d Rd=convert_sf2w(Rs)
1   0   0   0   1   0   1   1   1   0   0   s   s   s   s   s   P   P   -   -     -   -   -   -   0   0   1   d   d   d   d   d Rd=convert_sf2w(Rs):chop




                          Field name                                                          Description
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        d5                      Field to encode register d
                        s5                      Field to encode register s
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        RegType                 Register Type




80-N2040-36 B                                                               526

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Floating point extreme value assistance
                          For divide and square root routines, certain values are problematic for the default routine.
                          These instructions appropriately fix up the numerator (fixupn), denominator (fixupd), or
                          radicand (fixupr) for proper calculations when combined with the divide or square root
                          approximation instructions.

                                                Syntax                                                                  Behavior
                          Rd=sffixupd(Rs,Rt)                                         (Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);
                                                                                     Rd = Rt;
                          Rd=sffixupn(Rs,Rt)                                         (Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);
                                                                                     Rd = Rs;
                          Rd=sffixupr(Rs)                                            (Rs,Rd,adjust)=invsqrt_common(Rs);
                                                                                     Rd = Rs;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sffixupd(Rs,Rt)                                         Word32 Q6_R_sffixupd_RR(Word32 Rs, Word32
                                                                                     Rt)
                          Rd=sffixupn(Rs,Rt)                                         Word32 Q6_R_sffixupn_RR(Word32 Rs, Word32
                                                                                     Rt)
                          Rd=sffixupr(Rs)                                            Word32 Q6_R_sffixupr_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp                s5           Parse                                 MinOp            d5
1   0   0    0   1    0   1    1   1    0   1   s   s   s    s   s   P   P   -   -    -   -    -   -   0    0   0   d   d   d    d   d Rd=sffixupr(Rs)
    ICLASS           RegType           MajOp            s5           Parse                t5               MinOp            d5
1   1   1    0   1    0   1    1   1    1   0   s   s   s    s   s   P   P 0     t    t   t    t   t   0    0   0   d   d   d    d   d Rd=sffixupn(Rs,Rt)
1   1   1    0   1    0   1    1   1    1   0   s   s   s    s   s   P   P 0     t    t   t    t   t   0    0   1   d   d   d    d   d Rd=sffixupd(Rs,Rt)




                            Field name                                                             Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type



80-N2040-36 B                                                                    527

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Floating point fused multiply-add
                          Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
                          precision is kept.

                                                Syntax                                                                Behavior
                          Rx+=sfmpy(Rs,Rt)                                         Rx=fmaf(Rs,Rt,Rx);
                          Rx-=sfmpy(Rs,Rt)                                         Rx=fmaf(-Rs,Rt,Rx);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rx+=sfmpy(Rs,Rt)                                         Word32 Q6_R_sfmpyacc_RR(Word32 Rx, Word32
                                                                                   Rs, Word32 Rt)
                          Rx-=sfmpy(Rs,Rt)                                         Word32 Q6_R_sfmpynac_RR(Word32 Rx, Word32
                                                                                   Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            x5
1   1   1    0   1    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   x   x   x    x   x Rx+=sfmpy(Rs,Rt)
1   1   1    0   1    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   1   x   x   x    x   x Rx-=sfmpy(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  528

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Floating point fused multiply-add with scaling
                          Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
                          precision is kept. Additionally, scale the output. This instruction has special handling of
                          corner cases. If a multiplicand source is zero, the accumulator is left unchanged; this is
                          important as -0.0 + 0.0*x yields -0.0. The scaling factor is the predicate taken as a two's
                          compliment number for single precision. The scaling factor is twice the predicate taken as
                          a two's compliment number for double precision.

                                                Syntax                                                               Behavior
                          Rx+=sfmpy(Rs,Rt,Pu):scale                                if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx
                                                                                   = NaN;
                                                                                   ;
                                                                                   tmp=fmaf(Rs,Rt,Rx) * 2**(Pu);
                                                                                   if ((tmp != Rx) || ((Rs != 0.0) && (Rt !=
                                                                                   0.0))) Rx = tmp;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rx+=sfmpy(Rs,Rt,Pu):scale                                Word32 Q6_R_sfmpyacc_RRp_scale(Word32 Rx,
                                                                                   Word32 Rs, Word32 Rt, Byte Pu)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               u2              x5

1   1   1    0   1    1   1    1   0    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1   u   u   x   x   x    x   x Rx+=sfmpy(Rs,Rt,Pu):scale




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          u2                        Field to encode register u
                          x5                        Field to encode register x




80-N2040-36 B                                                                  529

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



Floating point reciprocal square root approximation
                          Provides an approximation of the reciprocal square root of the radicand (Rs), if combined
                          with the appropriate fixup instruction. Certain values (such as infinities or zeros) in the
                          numerator or denominator may yield values that are not reciprocal approximations, but
                          yield the correct answer when combined with fixup instructions and the appropriate
                          routines.

                          For compatibility, exact results of these instructions can not be relied on. The precision of
                          the approximation for this architecture and later is at least 6.6 bits.

                                               Syntax                                                                     Behavior
                          Rd,Pe=sfinvsqrta(Rs)                                      if ((Rs,Rd,adjust)=invsqrt_common(Rs)) {
                                                                                         Pe = adjust;
                                                                                         idx = (Rs >> 17) & 0x7f;
                                                                                         mant = (invsqrt_lut[idx] << 15);
                                                                                         exp = 127 - ((exponent(Rs) - 127) >> 1)
                                                                                    - 1;
                                                                                         Rd = -1**Rs.31 * 1.MANT * 2**(exp-
                                                                                    BIAS);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   This instruction provides a certain amount of accuracy. In future versions the
                                       accuracy may increase. For future compatibility, dependence on exact values must
                                       be avoided.
                                   ï®   The predicate generated by this instruction can not be used as a .new predicate,
                                       nor can it be automatically ANDed with another predicate.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6    5       4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                    e2               d5
1   0   0    0   1    0   1    1   1   1   1   s   s   s    s   s   P   P   -   -    -   -   -   -   0   e        e   d   d   d    d   d Rd,Pe=sfinvsqrta(Rs)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          e2                       Field to encode register e
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   530

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Floating point fused multiply-add for library routines
                Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
                precision is kept. This instruction has special handling of corner cases. Addition of
                infinities with opposite signs, or subtraction of infinities with like signs, is defined as
                (positive) zero. Rounding is always Nearest-Even, except that overflows to infinity round
                to maximal finite values. If a multiplicand source is zero, the accumulator is left
                unchanged; this is important as -0.0 + 0.0*x yields -0.0. Flags and exceptions are not
                generated.

                              Syntax                                       Behavior
                Rx+=sfmpy(Rs,Rt):lib                 round_to_nearest();
                                                     infminusinf = ((isinf(Rx)) &&
                                                     (isinf(Rs*Rt)) && (Rs ^ Rx ^ Rt.31 != 0));
                                                     infinp = (isinf(Rx)) || (isinf(Rt)) ||
                                                     (isinf(Rs));
                                                     if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx
                                                     = NaN;
                                                     ;
                                                     if ((Rs != 0.0) && (Rt != 0.0)) {
                                                         Rx=fmaf(Rs,Rt,Rx);
                                                     } else {
                                                         if (isinf(Rs) || isinf(Rt)) Rx = NaN;
                                                     };
                                                     cancel_flags();
                                                     if (isinf(Rx) && !infinp) Rx = Rx - 1;
                                                     if (infminusinf) Rx = 0;
                Rx-=sfmpy(Rs,Rt):lib                 round_to_nearest();
                                                     infinp = (isinf(Rx)) || (isinf(Rt)) ||
                                                     (isinf(Rs));
                                                     infminusinf = ((isinf(Rx)) &&
                                                     (isinf(Rs*Rt)) && (Rs ^ Rx ^ Rt.31 == 0));
                                                     if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx
                                                     = NaN;
                                                     ;
                                                     if ((Rs != 0.0) && (Rt != 0.0)) {
                                                         Rx=fmaf(-Rs,Rt,Rx);
                                                     } else {
                                                         if (isinf(Rs) || isinf(Rt)) Rx = NaN;
                                                     };
                                                     cancel_flags();
                                                     if (isinf(Rx) && !infinp) Rx = Rx - 1;
                                                     if (infminusinf) Rx = 0;


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rx+=sfmpy(Rs,Rt):lib                 Word32 Q6_R_sfmpyacc_RR_lib(Word32 Rx,
                                                     Word32 Rs, Word32 Rt)
                Rx-=sfmpy(Rs,Rt):lib                 Word32 Q6_R_sfmpynac_RR_lib(Word32 Rx,
                                                     Word32 Rs, Word32 Rt)




80-N2040-36 B                                      531

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            x5
1   1   1    0   1    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   0   x   x   x    x   x Rx+=sfmpy(Rs,Rt):lib
1   1   1    0   1    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   1   x   x   x    x   x Rx-=sfmpy(Rs,Rt):lib




                            Field name                                                          Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  532

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Create floating-point constant
                          Using ten bits of immediate, form a floating-point constant.

                                               Syntax                                                                    Behavior
                          Rd=sfmake(#u10):neg                                      Rd = (127 - 6) << 23;
                                                                                   Rd += (#u << 17);
                                                                                   Rd |= (1 << 31);
                          Rd=sfmake(#u10):pos                                      Rd = (127 - 6) << 23;
                                                                                   Rd += #u << 17;
                          Rdd=dfmake(#u10):neg                                     Rdd = (1023ULL - 6) << 52;
                                                                                   Rdd += (#u) << 46;
                                                                                   Rdd |= ((1ULL) << 63);
                          Rdd=dfmake(#u10):pos                                     Rdd = (1023ULL - 6) << 52;
                                                                                   Rdd += (#u) << 46;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sfmake(#u10):neg                                      Word32 Q6_R_sfmake_I_neg(Word32 Iu10)
                          Rd=sfmake(#u10):pos                                      Word32 Q6_R_sfmake_I_pos(Word32 Iu10)
                          Rdd=dfmake(#u10):neg                                     Word64 Q6_P_dfmake_I_neg(Word32 Iu10)
                          Rdd=dfmake(#u10):pos                                     Word64 Q6_P_dfmake_I_pos(Word32 Iu10)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6    5     4   3   2    1   0
    ICLASS           RegType                                       Parse                                 MinOp               d5
1   1   0    1   0    1   1    0   0   0   i   -   -   -   -   -   P   P   i   i     i   i   i   i   i     i     i   d   d   d    d   d Rd=sfmake(#u10):pos
1   1   0    1   0    1   1    0   0   1   i   -   -   -   -   -   P   P   i   i     i   i   i   i   i     i     i   d   d   d    d   d Rd=sfmake(#u10):neg
    ICLASS           RegType                                       Parse                                                     d5
1   1   0    1   1    0   0    1   0   0   i   -   -   -   -   -   P   P   i   i     i   i   i   i   i     i     i   d   d   d    d   d Rdd=dfmake(#u10):pos
1   1   0    1   1    0   0    1   0   1   i   -   -   -   -   -   P   P   i   i     i   i   i   i   i     i     i   d   d   d    d   d Rdd=dfmake(#u10):neg




                            Field name                                                           Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d




80-N2040-36 B                                                                  533

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Floating point maximum
                          Maximum of two floating point values. If one value is a NaN, the other is chosen.

                                                Syntax                                                                Behavior
                          Rd=sfmax(Rs,Rt)                                          Rd = fmaxf(Rs,Rt);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sfmax(Rs,Rt)                                          Word32 Q6_R_sfmax_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   1    1   1    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rd=sfmax(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  534

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Floating point minimum
                          Minimum of two floating point values. If one value is a NaN, the other is chosen.

                                                Syntax                                                                Behavior
                          Rd=sfmin(Rs,Rt)                                          Rd = fmin(Rs,Rt);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sfmin(Rs,Rt)                                          Word32 Q6_R_sfmin_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   1    1   1    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   1   d   d   d    d   d Rd=sfmin(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  535

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Floating point multiply
                          Add two floating point values

                                                Syntax                                                                Behavior
                          Rd=sfmpy(Rs,Rt)                                          Rd=Rs*Rt;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sfmpy(Rs,Rt)                                          Word32 Q6_R_sfmpy_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   1    1   0    1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   0   d   d   d    d   d Rd=sfmpy(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  536

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



Floating point reciprocal approximation
                          Provides an approximation of the reciprocal of the denominator (Rt), if combined with the
                          appropriate fixup instructions. Certain values (such as infinities or zeros) in the numerator
                          or denominator may yield values that are not reciprocal approximations, but yield the
                          correct answer when combined with fixup instructions and the appropriate routines.

                          For compatibility, exact results of these instructions can not be relied on. The precision of
                          the approximation for this architecture and later is at least 6.6 bits.

                                                Syntax                                                                    Behavior
                          Rd,Pe=sfrecipa(Rs,Rt)                                    if ((Rs,Rt,Rd,adjust)=recip_common(Rs,Rt))
                                                                                   {
                                                                                       Pe = adjust;
                                                                                       idx = (Rt >> 16) & 0x7f;
                                                                                       mant = (recip_lut[idx] << 15) | 1;
                                                                                       exp = 127 - (exponent(Rt) - 127) - 1;
                                                                                       Rd = -1**Rt.31 * 1.MANT * 2**(exp-
                                                                                   BIAS);
                                                                                   };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    This instruction provides a certain amount of accuracy. In future versions the
                                        accuracy may increase. For future compatibility, dependence on exact values must
                                        be avoided.
                                   ï®    The predicate generated by this instruction can not be used as a .new predicate,
                                        nor can it be automatically ANDed with another predicate.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6    5       4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5                   e2               d5
1   1   1    0   1    0   1    1   1    1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1   e        e   d   d   d    d   d Rd,Pe=sfrecipa(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          e2                        Field to encode register e
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  537

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Floating point subtraction
                          Subtract two floating point values.

                                                Syntax                                                                Behavior
                          Rd=sfsub(Rs,Rt)                                          Rd=Rs-Rt;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=sfsub(Rs,Rt)                                          Word32 Q6_R_sfsub_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse              t5               MinOp            d5
1   1   1    0   1    0   1    1   0    0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   0    0   1   d   d   d    d   d Rd=sfsub(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t




80-N2040-36 B                                                                  538

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



   11.10.5 XTYPE/MPY
                The XTYPE/MPY instruction subclass includes instructions which perform
                multiplication.

Multiply and use lower result
                Multiply the signed 32-bit integer in Rs by either the signed 32-bit integer in Rt or an
                unsigned immediate value. The 64-bit result is optionally accumulated with the 32-bit
                destination, or added to an immediate. The least-significant 32-bits of the result are written
                to the single destination register.

                This multiply produces the correct results for the ANSI C multiplication of two signed or
                unsigned integers with an integer result.


                                          Rs


                                        Rt /#u8




                              *
                                64


                             Add


                       Low 32-bits                      32



                     Rx


                               Syntax                                        Behavior
                Rd=+mpyi(Rs,#u8)                      apply_extension(#u);
                                                      Rd=Rs*#u;
                Rd=-mpyi(Rs,#u8)                      Rd=Rs*-#u;
                Rd=add(#u6,mpyi(Rs,#U6))              apply_extension(#u);
                                                      Rd = #u + Rs*#U;
                Rd=add(#u6,mpyi(Rs,Rt))               apply_extension(#u);
                                                      Rd = #u + Rs*Rt;
                Rd=add(Ru,mpyi(#u6:2,Rs))             Rd = Ru + Rs*#u;
                Rd=add(Ru,mpyi(Rs,#u6))               apply_extension(#u);
                                                      Rd = Ru + Rs*#u;




80-N2040-36 B                                        539

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                             Syntax                                Behavior
                Rd=mpyi(Rs,#m9)                if ("((#m9<0) && (#m9>-256))") {
                                                   Assembler mapped to: "Rd=-
                                               mpyi(Rs,#m9*(-1))";
                                               } else {
                                                   Assembler mapped to:
                                               "Rd=+mpyi(Rs,#m9)";
                                               };
                Rd=mpyi(Rs,Rt)                 Rd=Rs*Rt;
                Rd=mpyui(Rs,Rt)                Assembler mapped to: "Rd=mpyi(Rs,Rt)"
                Rx+=mpyi(Rs,#u8)               apply_extension(#u);
                                               Rx=Rx + (Rs*#u);
                Rx+=mpyi(Rs,Rt)                Rx=Rx + Rs*Rt;
                Rx-=mpyi(Rs,#u8)               apply_extension(#u);
                                               Rx=Rx - (Rs*#u);
                Ry=add(Ru,mpyi(Ry,Rs))         Ry = Ru + Rs*Ry;


                Class: XTYPE (slots 2,3)

                Intrinsics


                Rd=add(#u6,mpyi(Rs,#U6))       Word32 Q6_R_add_mpyi_IRI(Word32 Iu6, Word32
                                               Rs, Word32 IU6)
                Rd=add(#u6,mpyi(Rs,Rt))        Word32 Q6_R_add_mpyi_IRR(Word32 Iu6, Word32
                                               Rs, Word32 Rt)
                Rd=add(Ru,mpyi(#u6:2,Rs))      Word32 Q6_R_add_mpyi_RIR(Word32 Ru, Word32
                                               Iu6_2, Word32 Rs)
                Rd=add(Ru,mpyi(Rs,#u6))        Word32 Q6_R_add_mpyi_RRI(Word32 Ru, Word32
                                               Rs, Word32 Iu6)
                Rd=mpyi(Rs,#m9)                Word32 Q6_R_mpyi_RI(Word32 Rs, Word32 Im9)
                Rd=mpyi(Rs,Rt)                 Word32 Q6_R_mpyi_RR(Word32 Rs, Word32 Rt)
                Rd=mpyui(Rs,Rt)                Word32 Q6_R_mpyui_RR(Word32 Rs, Word32 Rt)
                Rx+=mpyi(Rs,#u8)               Word32 Q6_R_mpyiacc_RI(Word32 Rx, Word32
                                               Rs, Word32 Iu8)
                Rx+=mpyi(Rs,Rt)                Word32 Q6_R_mpyiacc_RR(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx-=mpyi(Rs,#u8)               Word32 Q6_R_mpyinac_RI(Word32 Rx, Word32
                                               Rs, Word32 Iu8)
                Ry=add(Ru,mpyi(Ry,Rs))         Word32 Q6_R_add_mpyi_RRR(Word32 Ru, Word32
                                               Ry, Word32 Rs)




80-N2040-36 B                                 540

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                               Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                    8   7    6    5     4   3   2    1   0
    ICLASS           RegType                               s5           Parse                 t5               MinOp               d5
1   1   0    1   0    1   1    1   0     i     i   s   s   s    s   s   P   P   i   t     t   t    t   t   i     i     i   d   d   d    d   d Rd=add(#u6,mpyi(Rs,Rt))
    ICLASS           RegType                               s5           Parse                 d5
1   1   0    1   1    0   0    0   I     i     i   s   s   s    s   s   P   P   i   d   d     d    d   d   i     i     i   I   I   I    I   I Rd=add(#u6,mpyi(Rs,#U6))
    ICLASS           RegType                               s5           Parse                 d5                                   u5
1   1   0    1   1    1   1    1   0     i     i   s   s   s    s   s   P   P   i   d   d     d    d   d   i     i     i   u   u   u    u   u Rd=add(Ru,mpyi(#u6:2,Rs))
1   1   0    1   1    1   1    1   1     i     i   s   s   s    s   s   P   P   i   d   d     d    d   d   i     i     i   u   u   u    u   u Rd=add(Ru,mpyi(Rs,#u6))
    ICLASS           RegType           MajOp               s5           Parse                 y5                                   u5
1   1   1    0   0    0   1    1   0    0    0     s   s   s    s   s   P   P   -   y   y     y    y   y   -     -     -   u   u   u    u   u Ry=add(Ru,mpyi(Ry,Rs))
    ICLASS           RegType           MajOp               s5           Parse                                  MinOp               d5
1   1   1    0   0    0   0    0   0     -     -   s   s   s    s   s   P   P 0     i     i   i    i   i   i     i     i   d   d   d    d   d Rd=+mpyi(Rs,#u8)
1   1   1    0   0    0   0    0   1     -     -   s   s   s    s   s   P   P 0     i     i   i    i   i   i     i     i   d   d   d    d   d Rd=-mpyi(Rs,#u8)
    ICLASS           RegType           MajOp               s5           Parse                                  MinOp               x5
1   1   1    0   0    0   0    1   0     -     -   s   s   s    s   s   P   P 0     i     i   i    i   i   i     i     i   x   x   x    x   x Rx+=mpyi(Rs,#u8)
1   1   1    0   0    0   0    1   1     -     -   s   s   s    s   s   P   P 0     i     i   i    i   i   i     i     i   x   x   x    x   x Rx-=mpyi(Rs,#u8)
    ICLASS           RegType           MajOp               s5           Parse                 t5               MinOp               d5
1   1   1    0   1    1   0    1   0    0    0     s   s   s    s   s   P   P 0     t     t   t    t   t   0    0    0     d   d   d    d   d Rd=mpyi(Rs,Rt)
    ICLASS           RegType           MajOp               s5           Parse                 t5               MinOp               x5
1   1   1    0   1    1   1    1   0    0    0     s   s   s    s   s   P   P 0     t     t   t    t   t   0    0    0     x   x   x    x   x Rx+=mpyi(Rs,Rt)




                            Field name                                                                 Description
                          RegType                      Register Type
                          MajOp                        Major Opcode
                          MinOp                        Minor Opcode
                          ICLASS                       Instruction Class
                          MajOp                        Major Opcode
                          MinOp                        Minor Opcode
                          RegType                      Register Type
                          Parse                        Packet/Loop parse bits
                          d5                           Field to encode register d
                          s5                           Field to encode register s
                          t5                           Field to encode register t
                          u5                           Field to encode register u
                          x5                           Field to encode register x
                          y5                           Field to encode register y




80-N2040-36 B                                                                       541

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                   Instruction Set



Vector multiply word by signed half (32x16)
                Perform mixed precision vector multiply operations. A 32-bit word from vector Rss is
                multiplied by a 16-bit halfword (either even or odd) from vector Rtt. The multiplication is
                performed as a signed 32x16, which produces a 48-bit result. This result is optionally
                scaled left by one bit. This result is then shifted right by 16 bits, optionally accumulated
                and then saturated to 32-bits. This operation is available in vector form
                (vmpyweh/vmpywoh) and non-vector form (mpyweh/mpywoh).

                         s16                 s16                 s16              s16                 Rtt



                                              mux                                 mux


                                  s32                                  s32                            Rss



                                   *                                    *
                                     48      0x0     0x8000               48         0x0     0x8000

                                  <<0-1                                <<0-1
                                                   mux                                     mux




                                       Add                                  Add

                                     >>16                                   >>16


                                     Add                                       Add


                                   Sat_32                                   Sat_32                                 32



                    32




                                                               Rxx




80-N2040-36 B                                            542

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set




                          Syntax                                           Behavior
         Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat          Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.h[2])[<<1]+0x8000)>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.h[0])[<<1]+0x8000)>>16);
         Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat              Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.h[2])[<<1])>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.h[0])[<<1])>>16);
         Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat          Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.h[3])[<<1]+0x8000)>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.h[1])[<<1]+0x8000)>>16);
         Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat              Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.h[3])[<<1])>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.h[1])[<<1])>>16);
         Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                             Rtt.h[2])[<<1]+0x8000)>>16));
                                             Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                             Rtt.h[0])[<<1]+0x8000)>>16));
         Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat             Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                                     Rtt.h[2])[<<1])>>16));
                                                     Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                                     Rtt.h[0])[<<1])>>16));
         Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                             Rtt.h[3])[<<1]+0x8000)>>16));
                                             Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                             Rtt.h[1])[<<1]+0x8000)>>16 ));
         Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat             Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                                     Rtt.h[3])[<<1])>>16));
                                                     Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                                     Rtt.h[1])[<<1])>>16 ));


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                      543

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



                          Intrinsics

                 Rdd=vmpyweh(Rss,Rtt):<<1:rnd:sat                               Word64 Q6_P_vmpyweh_PP_s1_rnd_sat(Word64
                                                                                Rss, Word64 Rtt)
                 Rdd=vmpyweh(Rss,Rtt):<<1:sat                                   Word64 Q6_P_vmpyweh_PP_s1_sat(Word64 Rss,
                                                                                Word64 Rtt)
                 Rdd=vmpyweh(Rss,Rtt):rnd:sat                                   Word64 Q6_P_vmpyweh_PP_rnd_sat(Word64 Rss,
                                                                                Word64 Rtt)
                 Rdd=vmpyweh(Rss,Rtt):sat                                       Word64 Q6_P_vmpyweh_PP_sat(Word64 Rss,
                                                                                Word64 Rtt)
                 Rdd=vmpywoh(Rss,Rtt):<<1:rnd:sat                               Word64 Q6_P_vmpywoh_PP_s1_rnd_sat(Word64
                                                                                Rss, Word64 Rtt)
                 Rdd=vmpywoh(Rss,Rtt):<<1:sat                                   Word64 Q6_P_vmpywoh_PP_s1_sat(Word64 Rss,
                                                                                Word64 Rtt)
                 Rdd=vmpywoh(Rss,Rtt):rnd:sat                                   Word64 Q6_P_vmpywoh_PP_rnd_sat(Word64 Rss,
                                                                                Word64 Rtt)
                 Rdd=vmpywoh(Rss,Rtt):sat                                       Word64 Q6_P_vmpywoh_PP_sat(Word64 Rss,
                                                                                Word64 Rtt)
                 Rxx+=vmpyweh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpywehacc_PP_s1_rnd_sat(Word64
                                                   Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpyweh(Rss,Rtt):<<1:sat                                  Word64 Q6_P_vmpywehacc_PP_s1_sat(Word64
                                                                                Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpyweh(Rss,Rtt):rnd:sat                                  Word64 Q6_P_vmpywehacc_PP_rnd_sat(Word64
                                                                                Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpyweh(Rss,Rtt):sat                                      Word64 Q6_P_vmpywehacc_PP_sat(Word64 Rxx,
                                                                                Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywoh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpywohacc_PP_s1_rnd_sat(Word64
                                                   Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywoh(Rss,Rtt):<<1:sat                                  Word64 Q6_P_vmpywohacc_PP_s1_sat(Word64
                                                                                Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywoh(Rss,Rtt):rnd:sat                                  Word64 Q6_P_vmpywohacc_PP_rnd_sat(Word64
                                                                                Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywoh(Rss,Rtt):sat                                      Word64 Q6_P_vmpywohacc_PP_sat(Word64 Rxx,
                                                                                Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse              t5               MinOp            d5

1   1   1    0   1    0   0    0   N 0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vmpyweh(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   0    0   N 0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   d   d   d    d   d Rdd=vmpywoh(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   0    0   N 0   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vmpyweh(Rss,Rtt)[:<<N]:rnd:sat
1   1   1    0   1    0   0    0   N 0   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   d   d   d    d   d Rdd=vmpywoh(Rss,Rtt)[:<<N]:rnd:sat




80-N2040-36 B                                                               544

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                          8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse             t5               MinOp            x5
1   1   1    0   1    0   1    0   N 0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    0   1   x   x   x    x   x   Rxx+=vmpyweh(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   1    0   N 0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   1   x   x   x    x   x   Rxx+=vmpywoh(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   1    0   N 0   1   s   s   s    s   s   P   P 0   t   t   t    t   t   1    0   1   x   x   x    x   x   Rxx+=vmpyweh(Rss,Rtt)[:<<N]:rnd:sat
1   1   1    0   1    0   1    0   N 0   1   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   1   x   x   x    x   x   Rxx+=vmpywoh(Rss,Rtt)[:<<N]:rnd:sat




                            Field name                                                       Description
                          ICLASS                 Instruction Class
                          MajOp                  Major Opcode
                          MinOp                  Minor Opcode
                          RegType                Register Type
                          Parse                  Packet/Loop parse bits
                          d5                     Field to encode register d
                          s5                     Field to encode register s
                          t5                     Field to encode register t
                          x5                     Field to encode register x




80-N2040-36 B                                                               545

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                    Instruction Set



Vector multiply word by unsigned half (32x16)
                Perform mixed precision vector multiply operations. A 32-bit signed word from vector
                Rss is multiplied by a 16-bit unsigned halfword (either odd or even) from vector Rtt. This
                multiplication produces a 48-bit result. This result is optionally scaled left by one bit, and
                then a rounding constant is optionally added to the lower 16-bits. This result is then shifted
                right by 16 bits, optionally accumulated and then saturated to 32-bits. This is a dual vector
                operation and is performed for both high and low word of Rss.

                         u16                  u16                 u16              u16                 Rtt



                                               mux                                 mux


                                   s32                                  s32                            Rss



                                    *                                    *
                                     48       0x0     0x8000               48         0x0     0x8000

                                  <<0-1                                 <<0-1
                                                    mux                                     mux




                                        Add                                  Add

                                     >>16                                    >>16


                                      Add                                       Add


                                    Sat_32                                   Sat_32                                 32



                    32




                                                                Rxx




80-N2040-36 B                                             546

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set




                         Syntax                                            Behavior
       Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat           Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.uh[2])[<<1]+0x8000)>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.uh[0])[<<1]+0x8000)>>16);
       Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat               Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.uh[2])[<<1])>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.uh[0])[<<1])>>16);
       Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat           Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.uh[3])[<<1]+0x8000)>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.uh[1])[<<1]+0x8000)>>16);
       Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat               Rdd.w[1]=sat32(((Rss.w[1] *
                                                     Rtt.uh[3])[<<1])>>16);
                                                     Rdd.w[0]=sat32(((Rss.w[0] *
                                                     Rtt.uh[1])[<<1])>>16);
       Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                            Rtt.uh[2])[<<1]+0x8000)>>16));
                                            Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                            Rtt.uh[0])[<<1]+0x8000)>>16));
       Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sat              Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                                     Rtt.uh[2])[<<1])>>16));
                                                     Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                                     Rtt.uh[0])[<<1])>>16));
       Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                            Rtt.uh[3])[<<1]+0x8000)>>16));
                                            Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                            Rtt.uh[1])[<<1]+0x8000)>>16 ));
       Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sat              Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *
                                                     Rtt.uh[3])[<<1])>>16));
                                                     Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *
                                                     Rtt.uh[1])[<<1])>>16 ));


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                      547

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                           Intrinsics

                 Rdd=vmpyweuh(Rss,Rtt):<<1:rnd:sat                               Word64 Q6_P_vmpyweuh_PP_s1_rnd_sat(Word64
                                                                                 Rss, Word64 Rtt)
                 Rdd=vmpyweuh(Rss,Rtt):<<1:sat                                   Word64 Q6_P_vmpyweuh_PP_s1_sat(Word64 Rss,
                                                                                 Word64 Rtt)
                 Rdd=vmpyweuh(Rss,Rtt):rnd:sat                                   Word64 Q6_P_vmpyweuh_PP_rnd_sat(Word64 Rss,
                                                                                 Word64 Rtt)
                 Rdd=vmpyweuh(Rss,Rtt):sat                                       Word64 Q6_P_vmpyweuh_PP_sat(Word64 Rss,
                                                                                 Word64 Rtt)
                 Rdd=vmpywouh(Rss,Rtt):<<1:rnd:sat                               Word64 Q6_P_vmpywouh_PP_s1_rnd_sat(Word64
                                                                                 Rss, Word64 Rtt)
                 Rdd=vmpywouh(Rss,Rtt):<<1:sat                                   Word64 Q6_P_vmpywouh_PP_s1_sat(Word64 Rss,
                                                                                 Word64 Rtt)
                 Rdd=vmpywouh(Rss,Rtt):rnd:sat                                   Word64 Q6_P_vmpywouh_PP_rnd_sat(Word64 Rss,
                                                                                 Word64 Rtt)
                 Rdd=vmpywouh(Rss,Rtt):sat                                       Word64 Q6_P_vmpywouh_PP_sat(Word64 Rss,
                                                                                 Word64 Rtt)
                 Rxx+=vmpyweuh(Rss,Rtt):<<1:rnd:sat Word64
                                                    Q6_P_vmpyweuhacc_PP_s1_rnd_sat(Word64 Rxx,
                                                    Word64 Rss, Word64 Rtt)
                 Rxx+=vmpyweuh(Rss,Rtt):<<1:sat                                  Word64 Q6_P_vmpyweuhacc_PP_s1_sat(Word64
                                                                                 Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpyweuh(Rss,Rtt):rnd:sat                                  Word64 Q6_P_vmpyweuhacc_PP_rnd_sat(Word64
                                                                                 Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpyweuh(Rss,Rtt):sat                                      Word64 Q6_P_vmpyweuhacc_PP_sat(Word64 Rxx,
                                                                                 Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywouh(Rss,Rtt):<<1:rnd:sat Word64
                                                    Q6_P_vmpywouhacc_PP_s1_rnd_sat(Word64 Rxx,
                                                    Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywouh(Rss,Rtt):<<1:sat                                  Word64 Q6_P_vmpywouhacc_PP_s1_sat(Word64
                                                                                 Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywouh(Rss,Rtt):rnd:sat                                  Word64 Q6_P_vmpywouhacc_PP_rnd_sat(Word64
                                                                                 Rxx, Word64 Rss, Word64 Rtt)
                 Rxx+=vmpywouh(Rss,Rtt):sat                                      Word64 Q6_P_vmpywouhacc_PP_sat(Word64 Rxx,
                                                                                 Word64 Rss, Word64 Rtt)


                           Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7    6   5   4   3   2    1   0
    ICLASS            RegType       MajOp             s5           Parse              t5               MinOp            d5
1   1   1    0    1    0   0    0   N 1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vmpyweuh(Rss,Rtt)[:<<N]:sat
1   1   1    0    1    0   0    0   N 1   0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   d   d   d    d   d Rdd=vmpywouh(Rss,Rtt)[:<<N]:sat
1   1   1    0    1    0   0    0   N 1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   1   d   d   d    d   d Rdd=vmpyweuh(Rss,Rtt)[:<<N]:rnd:sat
1   1   1    0    1    0   0    0   N 1   1   s   s   s    s   s   P   P 0   t    t   t    t   t   1    1   1   d   d   d    d   d Rdd=vmpywouh(Rss,Rtt)[:<<N]:rnd:sat




80-N2040-36 B                                                                548

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                  Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                          8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse             t5               MinOp            x5
1   1   1    0   1    0   1    0   N 1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    0   1   x   x   x    x   x   Rxx+=vmpyweuh(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   1    0   N 1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   1   x   x   x    x   x   Rxx+=vmpywouh(Rss,Rtt)[:<<N]:sat
1   1   1    0   1    0   1    0   N 1   1   s   s   s    s   s   P   P 0   t   t   t    t   t   1    0   1   x   x   x    x   x   Rxx+=vmpyweuh(Rss,Rtt)[:<<N]:rnd:sat
1   1   1    0   1    0   1    0   N 1   1   s   s   s    s   s   P   P 0   t   t   t    t   t   1    1   1   x   x   x    x   x   Rxx+=vmpywouh(Rss,Rtt)[:<<N]:rnd:sat




                            Field name                                                       Description
                          ICLASS                 Instruction Class
                          MajOp                  Major Opcode
                          MinOp                  Minor Opcode
                          RegType                Register Type
                          Parse                  Packet/Loop parse bits
                          d5                     Field to encode register d
                          s5                     Field to encode register s
                          t5                     Field to encode register t
                          x5                     Field to encode register x




80-N2040-36 B                                                               549

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



Multiply signed halfwords
                 Multiply two signed halfwords. Optionally shift the multiplier result by 1 bit. This result
                 can be accumulated or rounded. The destination/accumulator can be either 32 or 64-bits.
                 For 32-bit results, saturation is optional.


 Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat]                        Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1]
 Rd = mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat]                 Rdd = mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd]

           Rs                   Rt                               Rs                   Rt




           mux                  mux                             mux                  mux



                    16x16                                                 16x16
                                                                                     0x0 0x8000
                                 0x0 0x8000
                         32                                                   32

                     <<0-1                                                <<0-1
                                                                                           mux
                                     mux


                          32-bit                                            64-bit Add/
                         Add/Sub                                               Sub



                      Optional Sat
                       to 32-bits


                                                                                                                   Rxx
                                                    Rx


                       Syntax                                                Behavior
 Rd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat] Rd=[sat32]([round]((Rs.h[01] *
                                           Rt.h[01])[<<1]));
 Rdd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd]                 Rdd=[round]((Rs.h[01] * Rt.h[01])[<<1]);
 Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat]                 Rx=[sat32](Rx+ (Rs.h[01] * Rt.h[01])[<<1]);
 Rx-=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat]                 Rx=[sat32](Rx- (Rs.h[01] * Rt.h[01])[<<1]);
 Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1]                      Rxx=Rxx+ (Rs.h[01] * Rt.h[01])[<<1];
 Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<1]                      Rxx=Rxx- (Rs.h[01] * Rt.h[01])[<<1];




80-N2040-36 B                                        550

                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), then the OVF bit in the Status Register is
                        set. OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rd=mpy(Rs.H,Rt.H)                   Word32 Q6_R_mpy_RhRh(Word32 Rs, Word32 Rt)
                Rd=mpy(Rs.H,Rt.H):<<1               Word32 Q6_R_mpy_RhRh_s1(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.H,Rt.H):<<1:rnd           Word32 Q6_R_mpy_RhRh_s1_rnd(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.H,Rt.H):<<1:rnd:sat Word32 Q6_R_mpy_RhRh_s1_rnd_sat(Word32 Rs,
                                              Word32 Rt)
                Rd=mpy(Rs.H,Rt.H):<<1:sat           Word32 Q6_R_mpy_RhRh_s1_sat(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.H,Rt.H):rnd               Word32 Q6_R_mpy_RhRh_rnd(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.H,Rt.H):rnd:sat           Word32 Q6_R_mpy_RhRh_rnd_sat(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.H,Rt.H):sat               Word32 Q6_R_mpy_RhRh_sat(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.H,Rt.L)                   Word32 Q6_R_mpy_RhRl(Word32 Rs, Word32 Rt)
                Rd=mpy(Rs.H,Rt.L):<<1               Word32 Q6_R_mpy_RhRl_s1(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.H,Rt.L):<<1:rnd           Word32 Q6_R_mpy_RhRl_s1_rnd(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.H,Rt.L):<<1:rnd:sat Word32 Q6_R_mpy_RhRl_s1_rnd_sat(Word32 Rs,
                                              Word32 Rt)
                Rd=mpy(Rs.H,Rt.L):<<1:sat           Word32 Q6_R_mpy_RhRl_s1_sat(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.H,Rt.L):rnd               Word32 Q6_R_mpy_RhRl_rnd(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.H,Rt.L):rnd:sat           Word32 Q6_R_mpy_RhRl_rnd_sat(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.H,Rt.L):sat               Word32 Q6_R_mpy_RhRl_sat(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.L,Rt.H)                   Word32 Q6_R_mpy_RlRh(Word32 Rs, Word32 Rt)
                Rd=mpy(Rs.L,Rt.H):<<1               Word32 Q6_R_mpy_RlRh_s1(Word32 Rs, Word32
                                                    Rt)
                Rd=mpy(Rs.L,Rt.H):<<1:rnd           Word32 Q6_R_mpy_RlRh_s1_rnd(Word32 Rs,
                                                    Word32 Rt)
                Rd=mpy(Rs.L,Rt.H):<<1:rnd:sat Word32 Q6_R_mpy_RlRh_s1_rnd_sat(Word32 Rs,
                                              Word32 Rt)



80-N2040-36 B                                      551

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                           Instruction Set



                Rd=mpy(Rs.L,Rt.H):<<1:sat       Word32 Q6_R_mpy_RlRh_s1_sat(Word32 Rs,
                                                Word32 Rt)
                Rd=mpy(Rs.L,Rt.H):rnd           Word32 Q6_R_mpy_RlRh_rnd(Word32 Rs, Word32
                                                Rt)
                Rd=mpy(Rs.L,Rt.H):rnd:sat       Word32 Q6_R_mpy_RlRh_rnd_sat(Word32 Rs,
                                                Word32 Rt)
                Rd=mpy(Rs.L,Rt.H):sat           Word32 Q6_R_mpy_RlRh_sat(Word32 Rs, Word32
                                                Rt)
                Rd=mpy(Rs.L,Rt.L)               Word32 Q6_R_mpy_RlRl(Word32 Rs, Word32 Rt)
                Rd=mpy(Rs.L,Rt.L):<<1           Word32 Q6_R_mpy_RlRl_s1(Word32 Rs, Word32
                                                Rt)
                Rd=mpy(Rs.L,Rt.L):<<1:rnd       Word32 Q6_R_mpy_RlRl_s1_rnd(Word32 Rs,
                                                Word32 Rt)
                Rd=mpy(Rs.L,Rt.L):<<1:rnd:sat Word32 Q6_R_mpy_RlRl_s1_rnd_sat(Word32 Rs,
                                              Word32 Rt)
                Rd=mpy(Rs.L,Rt.L):<<1:sat       Word32 Q6_R_mpy_RlRl_s1_sat(Word32 Rs,
                                                Word32 Rt)
                Rd=mpy(Rs.L,Rt.L):rnd           Word32 Q6_R_mpy_RlRl_rnd(Word32 Rs, Word32
                                                Rt)
                Rd=mpy(Rs.L,Rt.L):rnd:sat       Word32 Q6_R_mpy_RlRl_rnd_sat(Word32 Rs,
                                                Word32 Rt)
                Rd=mpy(Rs.L,Rt.L):sat           Word32 Q6_R_mpy_RlRl_sat(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.H,Rt.H)              Word64 Q6_P_mpy_RhRh(Word32 Rs, Word32 Rt)
                Rdd=mpy(Rs.H,Rt.H):<<1          Word64 Q6_P_mpy_RhRh_s1(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.H,Rt.H):<<1:rnd      Word64 Q6_P_mpy_RhRh_s1_rnd(Word32 Rs,
                                                Word32 Rt)
                Rdd=mpy(Rs.H,Rt.H):rnd          Word64 Q6_P_mpy_RhRh_rnd(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.H,Rt.L)              Word64 Q6_P_mpy_RhRl(Word32 Rs, Word32 Rt)
                Rdd=mpy(Rs.H,Rt.L):<<1          Word64 Q6_P_mpy_RhRl_s1(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.H,Rt.L):<<1:rnd      Word64 Q6_P_mpy_RhRl_s1_rnd(Word32 Rs,
                                                Word32 Rt)
                Rdd=mpy(Rs.H,Rt.L):rnd          Word64 Q6_P_mpy_RhRl_rnd(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.L,Rt.H)              Word64 Q6_P_mpy_RlRh(Word32 Rs, Word32 Rt)
                Rdd=mpy(Rs.L,Rt.H):<<1          Word64 Q6_P_mpy_RlRh_s1(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.L,Rt.H):<<1:rnd      Word64 Q6_P_mpy_RlRh_s1_rnd(Word32 Rs,
                                                Word32 Rt)
                Rdd=mpy(Rs.L,Rt.H):rnd          Word64 Q6_P_mpy_RlRh_rnd(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.L,Rt.L)              Word64 Q6_P_mpy_RlRl(Word32 Rs, Word32 Rt)




80-N2040-36 B                                  552

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                           Instruction Set



                Rdd=mpy(Rs.L,Rt.L):<<1          Word64 Q6_P_mpy_RlRl_s1(Word32 Rs, Word32
                                                Rt)
                Rdd=mpy(Rs.L,Rt.L):<<1:rnd      Word64 Q6_P_mpy_RlRl_s1_rnd(Word32 Rs,
                                                Word32 Rt)
                Rdd=mpy(Rs.L,Rt.L):rnd          Word64 Q6_P_mpy_RlRl_rnd(Word32 Rs, Word32
                                                Rt)
                Rx+=mpy(Rs.H,Rt.H)              Word32 Q6_R_mpyacc_RhRh(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.H):<<1          Word32 Q6_R_mpyacc_RhRh_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.H):<<1:sat      Word32 Q6_R_mpyacc_RhRh_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.H):sat          Word32 Q6_R_mpyacc_RhRh_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.L)              Word32 Q6_R_mpyacc_RhRl(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.L):<<1          Word32 Q6_R_mpyacc_RhRl_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.L):<<1:sat      Word32 Q6_R_mpyacc_RhRl_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.H,Rt.L):sat          Word32 Q6_R_mpyacc_RhRl_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.H)              Word32 Q6_R_mpyacc_RlRh(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.H):<<1          Word32 Q6_R_mpyacc_RlRh_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.H):<<1:sat      Word32 Q6_R_mpyacc_RlRh_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.H):sat          Word32 Q6_R_mpyacc_RlRh_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.L)              Word32 Q6_R_mpyacc_RlRl(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.L):<<1          Word32 Q6_R_mpyacc_RlRl_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.L):<<1:sat      Word32 Q6_R_mpyacc_RlRl_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx+=mpy(Rs.L,Rt.L):sat          Word32 Q6_R_mpyacc_RlRl_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.H)              Word32 Q6_R_mpynac_RhRh(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.H):<<1          Word32 Q6_R_mpynac_RhRh_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.H):<<1:sat      Word32 Q6_R_mpynac_RhRh_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.H):sat          Word32 Q6_R_mpynac_RhRh_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.L)              Word32 Q6_R_mpynac_RhRl(Word32 Rx, Word32
                                                Rs, Word32 Rt)



80-N2040-36 B                                  553

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                           Instruction Set



                Rx-=mpy(Rs.H,Rt.L):<<1          Word32 Q6_R_mpynac_RhRl_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.L):<<1:sat      Word32 Q6_R_mpynac_RhRl_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.H,Rt.L):sat          Word32 Q6_R_mpynac_RhRl_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.H)              Word32 Q6_R_mpynac_RlRh(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.H):<<1          Word32 Q6_R_mpynac_RlRh_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.H):<<1:sat      Word32 Q6_R_mpynac_RlRh_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.H):sat          Word32 Q6_R_mpynac_RlRh_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.L)              Word32 Q6_R_mpynac_RlRl(Word32 Rx, Word32
                                                Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.L):<<1          Word32 Q6_R_mpynac_RlRl_s1(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.L):<<1:sat      Word32 Q6_R_mpynac_RlRl_s1_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rx-=mpy(Rs.L,Rt.L):sat          Word32 Q6_R_mpynac_RlRl_sat(Word32 Rx,
                                                Word32 Rs, Word32 Rt)
                Rxx+=mpy(Rs.H,Rt.H)             Word64 Q6_P_mpyacc_RhRh(Word64 Rxx, Word32
                                                Rs, Word32 Rt)
                Rxx+=mpy(Rs.H,Rt.H):<<1         Word64 Q6_P_mpyacc_RhRh_s1(Word64 Rxx,
                                                Word32 Rs, Word32 Rt)
                Rxx+=mpy(Rs.H,Rt.L)             Word64 Q6_P_mpyacc_RhRl(Word64 Rxx, Word32
                                                Rs, Word32 Rt)
                Rxx+=mpy(Rs.H,Rt.L):<<1         Word64 Q6_P_mpyacc_RhRl_s1(Word64 Rxx,
                                                Word32 Rs, Word32 Rt)
                Rxx+=mpy(Rs.L,Rt.H)             Word64 Q6_P_mpyacc_RlRh(Word64 Rxx, Word32
                                                Rs, Word32 Rt)
                Rxx+=mpy(Rs.L,Rt.H):<<1         Word64 Q6_P_mpyacc_RlRh_s1(Word64 Rxx,
                                                Word32 Rs, Word32 Rt)
                Rxx+=mpy(Rs.L,Rt.L)             Word64 Q6_P_mpyacc_RlRl(Word64 Rxx, Word32
                                                Rs, Word32 Rt)
                Rxx+=mpy(Rs.L,Rt.L):<<1         Word64 Q6_P_mpyacc_RlRl_s1(Word64 Rxx,
                                                Word32 Rs, Word32 Rt)
                Rxx-=mpy(Rs.H,Rt.H)             Word64 Q6_P_mpynac_RhRh(Word64 Rxx, Word32
                                                Rs, Word32 Rt)
                Rxx-=mpy(Rs.H,Rt.H):<<1         Word64 Q6_P_mpynac_RhRh_s1(Word64 Rxx,
                                                Word32 Rs, Word32 Rt)
                Rxx-=mpy(Rs.H,Rt.L)             Word64 Q6_P_mpynac_RhRl(Word64 Rxx, Word32
                                                Rs, Word32 Rt)




80-N2040-36 B                                  554

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Rxx-=mpy(Rs.H,Rt.L):<<1                                 Word64 Q6_P_mpynac_RhRl_s1(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)
                          Rxx-=mpy(Rs.L,Rt.H)                                     Word64 Q6_P_mpynac_RlRh(Word64 Rxx, Word32
                                                                                  Rs, Word32 Rt)
                          Rxx-=mpy(Rs.L,Rt.H):<<1                                 Word64 Q6_P_mpynac_RlRh_s1(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)
                          Rxx-=mpy(Rs.L,Rt.L)                                     Word64 Q6_P_mpynac_RlRl(Word64 Rxx, Word32
                                                                                  Rs, Word32 Rt)
                          Rxx-=mpy(Rs.L,Rt.L):<<1                                 Word64 Q6_P_mpynac_RlRl_s1(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           d5
1   1   1    0   0    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   0   0   d   d   d    d   d Rdd=mpy(Rs.L,Rt.L)[:<<N]
1   1   1    0   0    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   0   1   d   d   d    d   d Rdd=mpy(Rs.L,Rt.H)[:<<N]
1   1   1    0   0    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   1   0   d   d   d    d   d Rdd=mpy(Rs.H,Rt.L)[:<<N]
1   1   1    0   0    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   1   1   d   d   d    d   d Rdd=mpy(Rs.H,Rt.H)[:<<N]
1   1   1    0   0    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   0   0   d   d   d    d   d Rdd=mpy(Rs.L,Rt.L)[:<<N]:rnd
1   1   1    0   0    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   0   1   d   d   d    d   d Rdd=mpy(Rs.L,Rt.H)[:<<N]:rnd
1   1   1    0   0    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   1   0   d   d   d    d   d Rdd=mpy(Rs.H,Rt.L)[:<<N]:rnd
1   1   1    0   0    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   -   1   1   d   d   d    d   d Rdd=mpy(Rs.H,Rt.H)[:<<N]:rnd
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           x5

1   1   1    0   0    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   x   x   x    x   x Rxx+=mpy(Rs.L,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   x   x   x    x   x Rxx+=mpy(Rs.L,Rt.H)[:<<N]
1   1   1    0   0    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   x   x   x    x   x Rxx+=mpy(Rs.H,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   x   x   x    x   x Rxx+=mpy(Rs.H,Rt.H)[:<<N]
1   1   1    0   0    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   x   x   x    x   x Rxx-=mpy(Rs.L,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   x   x   x    x   x Rxx-=mpy(Rs.L,Rt.H)[:<<N]
1   1   1    0   0    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   x   x   x    x   x Rxx-=mpy(Rs.H,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   x   x   x    x   x Rxx-=mpy(Rs.H,Rt.H)[:<<N]
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           d5
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   d   d   d    d   d Rd=mpy(Rs.L,Rt.L)[:<<N]
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   d   d   d    d   d Rd=mpy(Rs.L,Rt.H)[:<<N]
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   d   d   d    d   d Rd=mpy(Rs.H,Rt.L)[:<<N]
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   d   d   d    d   d Rd=mpy(Rs.H,Rt.H)[:<<N]
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   0   d   d   d    d   d Rd=mpy(Rs.L,Rt.L)[:<<N]:sat
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   1   d   d   d    d   d Rd=mpy(Rs.L,Rt.H)[:<<N]:sat
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   0   d   d   d    d   d Rd=mpy(Rs.H,Rt.L)[:<<N]:sat
1   1   1    0   1    1   0    0   N 0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   1   d   d   d    d   d Rd=mpy(Rs.H,Rt.H)[:<<N]:sat




80-N2040-36 B                                                                 555

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7   6   5   4   3   2    1   0
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   0   d   d   d    d   d Rd=mpy(Rs.L,Rt.L)[:<<N]:rnd
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   1   d   d   d    d   d Rd=mpy(Rs.L,Rt.H)[:<<N]:rnd
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   0   d   d   d    d   d Rd=mpy(Rs.H,Rt.L)[:<<N]:rnd
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   1   d   d   d    d   d Rd=mpy(Rs.H,Rt.H)[:<<N]:rnd
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   0   d   d   d    d   d Rd=mpy(Rs.L,Rt.L)[:<<N]:rnd:sat
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   1   d   d   d    d   d Rd=mpy(Rs.L,Rt.H)[:<<N]:rnd:sat
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   0   d   d   d    d   d Rd=mpy(Rs.H,Rt.L)[:<<N]:rnd:sat
1   1   1    0   1    1   0    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   1   d   d   d    d   d Rd=mpy(Rs.H,Rt.H)[:<<N]:rnd:sat
    ICLASS           RegType       MajOp             s5           Parse               t5               sH tH           x5
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   0   x   x   x    x   x Rx+=mpy(Rs.L,Rt.L)[:<<N]
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   1   x   x   x    x   x Rx+=mpy(Rs.L,Rt.H)[:<<N]
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   0   x   x   x    x   x Rx+=mpy(Rs.H,Rt.L)[:<<N]
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   1   x   x   x    x   x Rx+=mpy(Rs.H,Rt.H)[:<<N]

1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   0   x   x   x    x   x Rx+=mpy(Rs.L,Rt.L)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   1   x   x   x    x   x Rx+=mpy(Rs.L,Rt.H)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   0   x   x   x    x   x Rx+=mpy(Rs.H,Rt.L)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   1   x   x   x    x   x Rx+=mpy(Rs.H,Rt.H)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   0   x   x   x    x   x Rx-=mpy(Rs.L,Rt.L)[:<<N]
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   1   x   x   x    x   x Rx-=mpy(Rs.L,Rt.H)[:<<N]
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   0   x   x   x    x   x Rx-=mpy(Rs.H,Rt.L)[:<<N]
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   1   x   x   x    x   x Rx-=mpy(Rs.H,Rt.H)[:<<N]
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   0   x   x   x    x   x Rx-=mpy(Rs.L,Rt.L)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   1   x   x   x    x   x Rx-=mpy(Rs.L,Rt.H)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   0   x   x   x    x   x Rx-=mpy(Rs.H,Rt.L)[:<<N]:sat
1   1   1    0   1    1   1    0   N 0   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   1   x   x   x    x   x Rx-=mpy(Rs.H,Rt.H)[:<<N]:sat




                            Field name                                                         Description
                          ICLASS                 Instruction Class
                          MajOp                  Major Opcode
                          MinOp                  Minor Opcode
                          RegType                Register Type
                          sH                     Rs is High
                          tH                     Rt is High
                          sH                     Rs is High
                          tH                     Rt is High
                          sH                     Rs is High
                          tH                     Rt is High
                          sH                     Rs is High
                          tH                     Rt is High



80-N2040-36 B                                                                 556

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                x5             Field to encode register x




80-N2040-36 B                                       557

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Multiply unsigned halfwords
                   Multiply two unsigned halfwords. Scale the result by 0-3 bits. Optionally, add or subtract
                   the result from the accumulator.


 Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]                            Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]
 Rd = mpyu(Rs.[HL],Rt.[HL])[:<<1]                           Rdd = mpyu(Rs.[HL],Rt.[HL])[:<<1]

          Rs                     Rt                              Rs                  Rt




         mux                    mux                             mux                  mux



                     16x16                                                16x16
                                                                                     0x0
                                 0x0
                         32                                                   32

                     <<0-1                                                <<0-1
                                                                                          mux
                                      mux


                          32-bit                                            64-bit Add/
                         Add/Sub                                               Sub

                                         Rx




                                                                                                                  Rxx


                               Syntax                                         Behavior
                Rd=mpyu(Rs.[HL],Rt.[HL])[:<<1]          Rd=(Rs.uh[01] * Rt.uh[01])[<<1];
                Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1]         Rdd=(Rs.uh[01] * Rt.uh[01])[<<1];
                Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]         Rx=Rx+ (Rs.uh[01] * Rt.uh[01])[<<1];
                Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<1]         Rx=Rx- (Rs.uh[01] * Rt.uh[01])[<<1];
                Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] Rxx=Rxx+ (Rs.uh[01] * Rt.uh[01])[<<1];
                Rxx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] Rxx=Rxx- (Rs.uh[01] * Rt.uh[01])[<<1];




80-N2040-36 B                                         558

                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                Class: XTYPE (slots 2,3)

                Intrinsics


                Rd=mpyu(Rs.H,Rt.H)             UWord32 Q6_R_mpyu_RhRh(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.H,Rt.H):<<1         UWord32 Q6_R_mpyu_RhRh_s1(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.H,Rt.L)             UWord32 Q6_R_mpyu_RhRl(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.H,Rt.L):<<1         UWord32 Q6_R_mpyu_RhRl_s1(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.L,Rt.H)             UWord32 Q6_R_mpyu_RlRh(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.L,Rt.H):<<1         UWord32 Q6_R_mpyu_RlRh_s1(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.L,Rt.L)             UWord32 Q6_R_mpyu_RlRl(Word32 Rs, Word32
                                               Rt)
                Rd=mpyu(Rs.L,Rt.L):<<1         UWord32 Q6_R_mpyu_RlRl_s1(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.H,Rt.H)            UWord64 Q6_P_mpyu_RhRh(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.H,Rt.H):<<1        UWord64 Q6_P_mpyu_RhRh_s1(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.H,Rt.L)            UWord64 Q6_P_mpyu_RhRl(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.H,Rt.L):<<1        UWord64 Q6_P_mpyu_RhRl_s1(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.L,Rt.H)            UWord64 Q6_P_mpyu_RlRh(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.L,Rt.H):<<1        UWord64 Q6_P_mpyu_RlRh_s1(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.L,Rt.L)            UWord64 Q6_P_mpyu_RlRl(Word32 Rs, Word32
                                               Rt)
                Rdd=mpyu(Rs.L,Rt.L):<<1        UWord64 Q6_P_mpyu_RlRl_s1(Word32 Rs, Word32
                                               Rt)
                Rx+=mpyu(Rs.H,Rt.H)            Word32 Q6_R_mpyuacc_RhRh(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx+=mpyu(Rs.H,Rt.H):<<1        Word32 Q6_R_mpyuacc_RhRh_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx+=mpyu(Rs.H,Rt.L)            Word32 Q6_R_mpyuacc_RhRl(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx+=mpyu(Rs.H,Rt.L):<<1        Word32 Q6_R_mpyuacc_RhRl_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx+=mpyu(Rs.L,Rt.H)            Word32 Q6_R_mpyuacc_RlRh(Word32 Rx, Word32
                                               Rs, Word32 Rt)




80-N2040-36 B                                 559

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                Rx+=mpyu(Rs.L,Rt.H):<<1        Word32 Q6_R_mpyuacc_RlRh_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx+=mpyu(Rs.L,Rt.L)            Word32 Q6_R_mpyuacc_RlRl(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx+=mpyu(Rs.L,Rt.L):<<1        Word32 Q6_R_mpyuacc_RlRl_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx-=mpyu(Rs.H,Rt.H)            Word32 Q6_R_mpyunac_RhRh(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx-=mpyu(Rs.H,Rt.H):<<1        Word32 Q6_R_mpyunac_RhRh_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx-=mpyu(Rs.H,Rt.L)            Word32 Q6_R_mpyunac_RhRl(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx-=mpyu(Rs.H,Rt.L):<<1        Word32 Q6_R_mpyunac_RhRl_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx-=mpyu(Rs.L,Rt.H)            Word32 Q6_R_mpyunac_RlRh(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx-=mpyu(Rs.L,Rt.H):<<1        Word32 Q6_R_mpyunac_RlRh_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rx-=mpyu(Rs.L,Rt.L)            Word32 Q6_R_mpyunac_RlRl(Word32 Rx, Word32
                                               Rs, Word32 Rt)
                Rx-=mpyu(Rs.L,Rt.L):<<1        Word32 Q6_R_mpyunac_RlRl_s1(Word32 Rx,
                                               Word32 Rs, Word32 Rt)
                Rxx+=mpyu(Rs.H,Rt.H)           Word64 Q6_P_mpyuacc_RhRh(Word64 Rxx, Word32
                                               Rs, Word32 Rt)
                Rxx+=mpyu(Rs.H,Rt.H):<<1       Word64 Q6_P_mpyuacc_RhRh_s1(Word64 Rxx,
                                               Word32 Rs, Word32 Rt)
                Rxx+=mpyu(Rs.H,Rt.L)           Word64 Q6_P_mpyuacc_RhRl(Word64 Rxx, Word32
                                               Rs, Word32 Rt)
                Rxx+=mpyu(Rs.H,Rt.L):<<1       Word64 Q6_P_mpyuacc_RhRl_s1(Word64 Rxx,
                                               Word32 Rs, Word32 Rt)
                Rxx+=mpyu(Rs.L,Rt.H)           Word64 Q6_P_mpyuacc_RlRh(Word64 Rxx, Word32
                                               Rs, Word32 Rt)
                Rxx+=mpyu(Rs.L,Rt.H):<<1       Word64 Q6_P_mpyuacc_RlRh_s1(Word64 Rxx,
                                               Word32 Rs, Word32 Rt)
                Rxx+=mpyu(Rs.L,Rt.L)           Word64 Q6_P_mpyuacc_RlRl(Word64 Rxx, Word32
                                               Rs, Word32 Rt)
                Rxx+=mpyu(Rs.L,Rt.L):<<1       Word64 Q6_P_mpyuacc_RlRl_s1(Word64 Rxx,
                                               Word32 Rs, Word32 Rt)
                Rxx-=mpyu(Rs.H,Rt.H)           Word64 Q6_P_mpyunac_RhRh(Word64 Rxx, Word32
                                               Rs, Word32 Rt)
                Rxx-=mpyu(Rs.H,Rt.H):<<1       Word64 Q6_P_mpyunac_RhRh_s1(Word64 Rxx,
                                               Word32 Rs, Word32 Rt)
                Rxx-=mpyu(Rs.H,Rt.L)           Word64 Q6_P_mpyunac_RhRl(Word64 Rxx, Word32
                                               Rs, Word32 Rt)




80-N2040-36 B                                 560

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Rxx-=mpyu(Rs.H,Rt.L):<<1                                Word64 Q6_P_mpyunac_RhRl_s1(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)
                          Rxx-=mpyu(Rs.L,Rt.H)                                    Word64 Q6_P_mpyunac_RlRh(Word64 Rxx, Word32
                                                                                  Rs, Word32 Rt)
                          Rxx-=mpyu(Rs.L,Rt.H):<<1                                Word64 Q6_P_mpyunac_RlRh_s1(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)
                          Rxx-=mpyu(Rs.L,Rt.L)                                    Word64 Q6_P_mpyunac_RlRl(Word64 Rxx, Word32
                                                                                  Rs, Word32 Rt)
                          Rxx-=mpyu(Rs.L,Rt.L):<<1                                Word64 Q6_P_mpyunac_RlRl_s1(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           d5
1   1   1    0   0    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   0   0   d   d   d    d   d Rdd=mpyu(Rs.L,Rt.L)[:<<N]
1   1   1    0   0    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   0   1   d   d   d    d   d Rdd=mpyu(Rs.L,Rt.H)[:<<N]
1   1   1    0   0    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   1   0   d   d   d    d   d Rdd=mpyu(Rs.H,Rt.L)[:<<N]
1   1   1    0   0    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   1   1   d   d   d    d   d Rdd=mpyu(Rs.H,Rt.H)[:<<N]
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           x5

1   1   1    0   0    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   x   x   x    x   x Rxx+=mpyu(Rs.L,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   x   x   x    x   x Rxx+=mpyu(Rs.L,Rt.H)[:<<N]
1   1   1    0   0    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   x   x   x    x   x Rxx+=mpyu(Rs.H,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   x   x   x    x   x Rxx+=mpyu(Rs.H,Rt.H)[:<<N]
1   1   1    0   0    1   1    0   N 1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   x   x   x    x   x Rxx-=mpyu(Rs.L,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   x   x   x    x   x Rxx-=mpyu(Rs.L,Rt.H)[:<<N]
1   1   1    0   0    1   1    0   N 1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   x   x   x    x   x Rxx-=mpyu(Rs.H,Rt.L)[:<<N]
1   1   1    0   0    1   1    0   N 1   1   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   x   x   x    x   x Rxx-=mpyu(Rs.H,Rt.H)[:<<N]
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           d5
1   1   1    0   1    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   d   d   d    d   d Rd=mpyu(Rs.L,Rt.L)[:<<N]
1   1   1    0   1    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   d   d   d    d   d Rd=mpyu(Rs.L,Rt.H)[:<<N]
1   1   1    0   1    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   d   d   d    d   d Rd=mpyu(Rs.H,Rt.L)[:<<N]
1   1   1    0   1    1   0    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   1   d   d   d    d   d Rd=mpyu(Rs.H,Rt.H)[:<<N]
    ICLASS           RegType       MajOp             s5           Parse                t5               sH tH           x5
1   1   1    0   1    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   x   x   x    x   x Rx+=mpyu(Rs.L,Rt.L)[:<<N]
1   1   1    0   1    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   1   x   x   x    x   x Rx+=mpyu(Rs.L,Rt.H)[:<<N]
1   1   1    0   1    1   1    0   N 1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   0   x   x   x    x   x Rx+=mpyu(Rs.H,Rt.L)[:<<N]




80-N2040-36 B                                                                 561

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                             Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                       8   7   6   5   4   3   2   1   0
1   1   1   0   1   1   1   0   N 1   0   s   s   s   s   s   P   P   -   t   t   t   t   t   0   1   1   x   x   x   x   x Rx+=mpyu(Rs.H,Rt.H)[:<<N]
1   1   1   0   1   1   1   0   N 1   1   s   s   s   s   s   P   P   -   t   t   t   t   t   0   0   0   x   x   x   x   x Rx-=mpyu(Rs.L,Rt.L)[:<<N]
1   1   1   0   1   1   1   0   N 1   1   s   s   s   s   s   P   P   -   t   t   t   t   t   0   0   1   x   x   x   x   x Rx-=mpyu(Rs.L,Rt.H)[:<<N]
1   1   1   0   1   1   1   0   N 1   1   s   s   s   s   s   P   P   -   t   t   t   t   t   0   1   0   x   x   x   x   x Rx-=mpyu(Rs.H,Rt.L)[:<<N]
1   1   1   0   1   1   1   0   N 1   1   s   s   s   s   s   P   P   -   t   t   t   t   t   0   1   1   x   x   x   x   x Rx-=mpyu(Rs.H,Rt.H)[:<<N]




                          Field name                                                      Description
                        ICLASS                Instruction Class
                        MajOp                 Major Opcode
                        MinOp                 Minor Opcode
                        RegType               Register Type
                        sH                    Rs is High
                        tH                    Rt is High
                        sH                    Rs is High
                        tH                    Rt is High
                        sH                    Rs is High
                        tH                    Rt is High
                        sH                    Rs is High
                        tH                    Rt is High
                        Parse                 Packet/Loop parse bits
                        d5                    Field to encode register d
                        s5                    Field to encode register s
                        t5                    Field to encode register t
                        x5                    Field to encode register x




80-N2040-36 B                                                             562

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Polynomial multiply words
                Perform a 32x32 carryless polynomial multiply using 32-bit source registers Rs and Rt.
                The 64-bit result is optionally accumulated (XORed) with the destination register. Finite
                field multiply instructions are useful for many algorithms including scramble code
                generation, cryptographic algorithms, convolutional, and Reed Solomon codes.


                             Rxx += pmpyw(Rs,Rt)




                                  Rs



                                  Rt



                                          32x32
                                        Carryless
                                        Polynomial
                                           mpy       *
                                              XOR



                 Rxx



                              Syntax                                       Behavior
                Rdd=pmpyw(Rs,Rt)                      x = Rs.uw[0];
                                                      y = Rt.uw[0];
                                                      prod = 0;
                                                      for(i=0; i < 32; i++) {
                                                          if((y >> i) & 1) prod ^= (x << i);
                                                      };
                                                      Rdd = prod;
                Rxx^=pmpyw(Rs,Rt)                     x = Rs.uw[0];
                                                      y = Rt.uw[0];
                                                      prod = 0;
                                                      for(i=0; i < 32; i++) {
                                                          if((y >> i) & 1) prod ^= (x << i);
                                                      };
                                                      Rxx ^= prod;




80-N2040-36 B                                        563

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=pmpyw(Rs,Rt)                                         Word64 Q6_P_pmpyw_RR(Word32 Rs, Word32 Rt)
                          Rxx^=pmpyw(Rs,Rt)                                        Word64 Q6_P_pmpywxacc_RR(Word64 Rxx, Word32
                                                                                   Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   0    1   0    1   0    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   1   d   d   d    d   d Rdd=pmpyw(Rs,Rt)
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   0    1   1    1   0    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   1   x   x   x    x   x Rxx^=pmpyw(Rs,Rt)




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  564

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector reduce multiply word by signed half (32x16)
                Perform mixed precision vector multiply operations and accumulate the results. A 32-bit
                word from vector Rss is multiplied by a 16-bit halfword (either even or odd) from vector
                Rtt. The multiplication is performed as a signed 32x16, which produces a 48-bit result.
                This result is optionally scaled left by one bit. A similar operation is performed for both
                words in Rss, and the two results are accumulated. The final result is optionally
                accumulated with Rxx.


                         s16                s16               s16               s16         Rtt



                                            mux                                 mux


                                   s32                                s32                   Rss



                                    *                                  *
                                      48                                 48


                                   <<0-1                              <<0-1




                                                      Add




                             Rxx


                               Syntax                                         Behavior
                Rdd=vrmpyweh(Rss,Rtt)[:<<1]          Rdd = (Rss.w[1] * Rtt.h[2])[<<1] +
                                                     (Rss.w[0] * Rtt.h[0])[<<1];
                Rdd=vrmpywoh(Rss,Rtt)[:<<1]          Rdd = (Rss.w[1] * Rtt.h[3])[<<1] +
                                                     (Rss.w[0] * Rtt.h[1])[<<1];
                Rxx+=vrmpyweh(Rss,Rtt)[:<<1] Rxx += (Rss.w[1] * Rtt.h[2])[<<1] +
                                             (Rss.w[0] * Rtt.h[0])[<<1];
                Rxx+=vrmpywoh(Rss,Rtt)[:<<1] Rxx += (Rss.w[1] * Rtt.h[3])[<<1] +
                                             (Rss.w[0] * Rtt.h[1])[<<1];




80-N2040-36 B                                       565

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=vrmpyweh(Rss,Rtt)                                 Word64 Q6_P_vrmpyweh_PP(Word64 Rss, Word64
                                                                                Rtt)
                          Rdd=vrmpyweh(Rss,Rtt):<<1                             Word64 Q6_P_vrmpyweh_PP_s1(Word64 Rss,
                                                                                Word64 Rtt)
                          Rdd=vrmpywoh(Rss,Rtt)                                 Word64 Q6_P_vrmpywoh_PP(Word64 Rss, Word64
                                                                                Rtt)
                          Rdd=vrmpywoh(Rss,Rtt):<<1                             Word64 Q6_P_vrmpywoh_PP_s1(Word64 Rss,
                                                                                Word64 Rtt)
                          Rxx+=vrmpyweh(Rss,Rtt)                                Word64 Q6_P_vrmpywehacc_PP(Word64 Rxx,
                                                                                Word64 Rss, Word64 Rtt)
                          Rxx+=vrmpyweh(Rss,Rtt):<<1                            Word64 Q6_P_vrmpywehacc_PP_s1(Word64 Rxx,
                                                                                Word64 Rss, Word64 Rtt)
                          Rxx+=vrmpywoh(Rss,Rtt)                                Word64 Q6_P_vrmpywohacc_PP(Word64 Rxx,
                                                                                Word64 Rss, Word64 Rtt)
                          Rxx+=vrmpywoh(Rss,Rtt):<<1                            Word64 Q6_P_vrmpywohacc_PP_s1(Word64 Rxx,
                                                                                Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse               t5               MinOp            d5
1   1   1    0   1    0   0    0   N 0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    1   0   d   d   d    d   d Rdd=vrmpywoh(Rss,Rtt)[:<<N]
1   1   1    0   1    0   0    0   N 1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    0   0   d   d   d    d   d Rdd=vrmpyweh(Rss,Rtt)[:<<N]
    ICLASS           RegType       MajOp             s5           Parse               t5               MinOp            x5

1   1   1    0   1    0   1    0   N 0   1   s   s   s    s   s   P   P 0   t    t    t    t   t   1    1   0   x   x   x    x   x Rxx+=vrmpyweh(Rss,Rtt)[:<<N]
1   1   1    0   1    0   1    0   N 1   1   s   s   s    s   s   P   P 0   t    t    t    t   t   1    1   0   x   x   x    x   x Rxx+=vrmpywoh(Rss,Rtt)[:<<N]




                            Field name                                                         Description
                          ICLASS                 Instruction Class
                          MajOp                  Major Opcode
                          MinOp                  Minor Opcode
                          RegType                Register Type
                          Parse                  Packet/Loop parse bits
                          d5                     Field to encode register d
                          s5                     Field to encode register s
                          t5                     Field to encode register t
                          x5                     Field to encode register x




80-N2040-36 B                                                               566

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                    Instruction Set



Multiply and use upper result
                Multiply two signed or unsigned 32-bit words. Take the upper 32-bits of this results store
                to a single destination register. Optional rounding is available.


                                            Rs


                                            Rt




                               32x32


                                   64




                                       Rd


                              Syntax                                       Behavior
                Rd=mpy(Rs,Rt.H):<<1:rnd:sat          Rd = sat32(((Rs * Rt.h[1])<<1+0x8000)>>16);
                Rd=mpy(Rs,Rt.H):<<1:sat              Rd = sat32(((Rs * Rt.h[1])<<1)>>16);
                Rd=mpy(Rs,Rt.L):<<1:rnd:sat          Rd = sat32(((Rs * Rt.h[0])<<1+0x8000)>>16);
                Rd=mpy(Rs,Rt.L):<<1:sat              Rd = sat32(((Rs * Rt.h[0])<<1)>>16);
                Rd=mpy(Rs,Rt)                        Rd=(Rs * Rt)>>32;
                Rd=mpy(Rs,Rt):<<1                    Rd=(Rs * Rt)>>31;
                Rd=mpy(Rs,Rt):<<1:sat                Rd=sat32((Rs * Rt)>>31);
                Rd=mpy(Rs,Rt):rnd                    Rd=((Rs * Rt)+0x80000000)>>32;
                Rd=mpysu(Rs,Rt)                      Rd=(Rs * Rt.uw[0])>>32;
                Rd=mpyu(Rs,Rt)                       Rd=(Rs.uw[0] * Rt.uw[0])>>32;
                Rx+=mpy(Rs,Rt):<<1:sat               Rx=sat32((Rx) + ((Rs * Rt)>>31));
                Rx-=mpy(Rs,Rt):<<1:sat               Rx=sat32((Rx) - ((Rs * Rt)>>31));


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), then the OVF bit in the Status Register is
                        set. OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                      567

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Intrinsics

                          Rd=mpy(Rs,Rt.H):<<1:rnd:sat                              Word32 Q6_R_mpy_RRh_s1_rnd_sat(Word32 Rs,
                                                                                   Word32 Rt)
                          Rd=mpy(Rs,Rt.H):<<1:sat                                  Word32 Q6_R_mpy_RRh_s1_sat(Word32 Rs,
                                                                                   Word32 Rt)
                          Rd=mpy(Rs,Rt.L):<<1:rnd:sat                              Word32 Q6_R_mpy_RRl_s1_rnd_sat(Word32 Rs,
                                                                                   Word32 Rt)
                          Rd=mpy(Rs,Rt.L):<<1:sat                                  Word32 Q6_R_mpy_RRl_s1_sat(Word32 Rs,
                                                                                   Word32 Rt)
                          Rd=mpy(Rs,Rt)                                            Word32 Q6_R_mpy_RR(Word32 Rs, Word32 Rt)
                          Rd=mpy(Rs,Rt):<<1                                        Word32 Q6_R_mpy_RR_s1(Word32 Rs, Word32 Rt)
                          Rd=mpy(Rs,Rt):<<1:sat                                    Word32 Q6_R_mpy_RR_s1_sat(Word32 Rs, Word32
                                                                                   Rt)
                          Rd=mpy(Rs,Rt):rnd                                        Word32 Q6_R_mpy_RR_rnd(Word32 Rs, Word32
                                                                                   Rt)
                          Rd=mpysu(Rs,Rt)                                          Word32 Q6_R_mpysu_RR(Word32 Rs, Word32 Rt)
                          Rd=mpyu(Rs,Rt)                                           UWord32 Q6_R_mpyu_RR(Word32 Rs, Word32 Rt)
                          Rx+=mpy(Rs,Rt):<<1:sat                                   Word32 Q6_R_mpyacc_RR_s1_sat(Word32 Rx,
                                                                                   Word32 Rs, Word32 Rt)
                          Rx-=mpy(Rs,Rt):<<1:sat                                   Word32 Q6_R_mpynac_RR_s1_sat(Word32 Rx,
                                                                                   Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   1    1   0    1   0    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rd=mpy(Rs,Rt):rnd
1   1   1    0   1    1   0    1   0    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rd=mpyu(Rs,Rt)
1   1   1    0   1    1   0    1   0    1   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rd=mpysu(Rs,Rt)
1   1   1    0   1    1   0    1   1    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   0   d   d   d    d   d Rd=mpy(Rs,Rt.H):<<1:sat
1   1   1    0   1    1   0    1   1    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rd=mpy(Rs,Rt.L):<<1:sat
1   1   1    0   1    1   0    1   1    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    0   0   d   d   d    d   d Rd=mpy(Rs,Rt.H):<<1:rnd:sat
1   1   1    0   1    1   0    1   1    1   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   0   d   d   d    d   d Rd=mpy(Rs,Rt):<<1:sat
1   1   1    0   1    1   0    1   1    1   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    0   0   d   d   d    d   d Rd=mpy(Rs,Rt.L):<<1:rnd:sat
1   1   1    0   1    1   0    1   N 0      N   s   s   s    s   s   P   P 0   t     t   t    t   t   0    N N     d   d   d    d   d Rd=mpy(Rs,Rt)[:<<N]
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   1    1   1    1   0    1   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   0   x   x   x    x   x Rx+=mpy(Rs,Rt):<<1:sat
1   1   1    0   1    1   1    1   0    1   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rx-=mpy(Rs,Rt):<<1:sat




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type



80-N2040-36 B                                                                  568

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                x5             Field to encode register x




80-N2040-36 B                                       569

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



Multiply and use full result
                Multiply two signed or unsigned 32-bit words. Optionally, add or subtract this value from
                the 64-bit accumulator. The result is a full-precision 64-bit value.


                                         Rs


                                         Rt




                        32x32


                             64

                      64-bit Add/Sub



                                                          Rxx


                                Syntax                                    Behavior
                Rdd=mpy(Rs,Rt)                      Rdd=(Rs * Rt);
                Rdd=mpyu(Rs,Rt)                     Rdd=(Rs.uw[0] * Rt.uw[0]);
                Rxx[+-]=mpy(Rs,Rt)                  Rxx= Rxx[+-](Rs * Rt);
                Rxx[+-]=mpyu(Rs,Rt)                 Rxx= Rxx[+-](Rs.uw[0] * Rt.uw[0]);


                Class: XTYPE (slots 2,3)

                Intrinsics


                Rdd=mpy(Rs,Rt)                      Word64 Q6_P_mpy_RR(Word32 Rs, Word32 Rt)
                Rdd=mpyu(Rs,Rt)                     UWord64 Q6_P_mpyu_RR(Word32 Rs, Word32 Rt)
                Rxx+=mpy(Rs,Rt)                     Word64 Q6_P_mpyacc_RR(Word64 Rxx, Word32
                                                    Rs, Word32 Rt)
                Rxx+=mpyu(Rs,Rt)                    Word64 Q6_P_mpyuacc_RR(Word64 Rxx, Word32
                                                    Rs, Word32 Rt)
                Rxx-=mpy(Rs,Rt)                     Word64 Q6_P_mpynac_RR(Word64 Rxx, Word32
                                                    Rs, Word32 Rt)
                Rxx-=mpyu(Rs,Rt)                    Word64 Q6_P_mpyunac_RR(Word64 Rxx, Word32
                                                    Rs, Word32 Rt)




80-N2040-36 B                                      570

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            d5
1   1   1    0   0    1   0    1   0    0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   d   d   d    d   d Rdd=mpy(Rs,Rt)
1   1   1    0   0    1   0    1   0    1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   d   d   d    d   d Rdd=mpyu(Rs,Rt)
    ICLASS           RegType           MajOp            s5           Parse             t5               MinOp            x5
1   1   1    0   0    1   1    1   0    0   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   x   x   x    x   x Rxx+=mpy(Rs,Rt)
1   1   1    0   0    1   1    1   0    0   1   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   x   x   x    x   x Rxx-=mpy(Rs,Rt)
1   1   1    0   0    1   1    1   0    1   0   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   x   x   x    x   x Rxx+=mpyu(Rs,Rt)
1   1   1    0   0    1   1    1   0    1   1   s   s   s    s   s   P   P 0   t   t   t    t   t   0    0   0   x   x   x    x   x Rxx-=mpyu(Rs,Rt)




                            Field name                                                          Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  571

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Vector dual multiply
                Multiply four 16-bit halfwords in Rss by the corresponding 16-bit halfwords in Rtt. The
                two lower results are scaled and added. The lower word of the accumulator is optionally
                added. This result is saturated to 32-bits and stored in the lower word of the accumulator.
                The same operation is performed on the upper two products using the upper word of the
                accumulator.

                                       Rxx+=vdmpy(Rss,Rtt):sat

                                                                                         Rss


                                                                                         Rtt




                              *                *              *                *
                                32               32             32               32


                            <<0-1             <<0-1          <<0-1            <<0-1




                                      Add                             Add


                                     Sat_32                          Sat_32                    32



                   32



                            High Accumulation               Low Accumulation

                                                      Rxx




80-N2040-36 B                                         572

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set




                                               Syntax                                                                Behavior
                          Rdd=vdmpy(Rss,Rtt):<<1:sat                              Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0])<<1 +
                                                                                  (Rss.h[1] * Rtt.h[1])<<1);
                                                                                  Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2])<<1 +
                                                                                  (Rss.h[3] * Rtt.h[3])<<1);
                          Rdd=vdmpy(Rss,Rtt):sat                                  Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0])<<0 +
                                                                                  (Rss.h[1] * Rtt.h[1])<<0);
                                                                                  Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2])<<0 +
                                                                                  (Rss.h[3] * Rtt.h[3])<<0);
                          Rxx+=vdmpy(Rss,Rtt):<<1:sat                             Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *
                                                                                  Rtt.h[0])<<1 + (Rss.h[1] * Rtt.h[1])<<1);
                                                                                  Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[2] *
                                                                                  Rtt.h[2])<<1 + (Rss.h[3] * Rtt.h[3])<<1);
                          Rxx+=vdmpy(Rss,Rtt):sat                                 Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *
                                                                                  Rtt.h[0])<<0 + (Rss.h[1] * Rtt.h[1])<<0);
                                                                                  Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[2] *
                                                                                  Rtt.h[2])<<0 + (Rss.h[3] * Rtt.h[3])<<0);


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), then the OVF bit in the Status Register is
                                        set. OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vdmpy(Rss,Rtt):<<1:sat                              Word64 Q6_P_vdmpy_PP_s1_sat(Word64 Rss,
                                                                                  Word64 Rtt)
                          Rdd=vdmpy(Rss,Rtt):sat                                  Word64 Q6_P_vdmpy_PP_sat(Word64 Rss, Word64
                                                                                  Rtt)
                          Rxx+=vdmpy(Rss,Rtt):<<1:sat                             Word64 Q6_P_vdmpyacc_PP_s1_sat(Word64 Rxx,
                                                                                  Word64 Rss, Word64 Rtt)
                          Rxx+=vdmpy(Rss,Rtt):sat                                 Word64 Q6_P_vdmpyacc_PP_sat(Word64 Rxx,
                                                                                  Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp           s5           Parse              t5               MinOp            d5

1   1   1    0   1    0   0    0   N 0     0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   d   d   d    d   d Rdd=vdmpy(Rss,Rtt)[:<<N]:sat
    ICLASS           RegType           MajOp           s5           Parse              t5               MinOp            x5

1   1   1    0   1    0   1    0   N 0     0   s   s   s    s   s   P   P 0   t    t   t    t   t   1    0   0   x   x   x    x   x Rxx+=vdmpy(Rss,Rtt)[:<<N]:sat




80-N2040-36 B                                                                 573

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                x5             Field to encode register x




80-N2040-36 B                                       574

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



Vector dual multiply with round and pack
                  Multiply four 16-bit halfwords in Rss by the corresponding 16-bit halfwords in Rtt. The
                  two lower results are scaled and added together with a rounding constant. This result is
                  saturated to 32-bits, and the upper 16-bits of this result are stored in the lower 16-bits of
                  the destination register. The same operation is performed on the upper two products and
                  the result is stored in the upper 16-bit halfword of the destination.


                                            Rd=vdmpy(Rss,Rtt):rnd:sat

                                                                                                 Rss


                                                                                                 Rtt




                                   *                   *              *                *
                                     32                  32             32                 32


                   0x8000        <<0-1                <<0-1         <<0-1             <<0-1      0x8000



                                           Add                                Add



                                          Sat_32                             Sat_32

                                                   High 16bits         High 16bits


                                                                                 Rd


                               Syntax                                           Behavior
                Rd=vdmpy(Rss,Rtt)[:<<1]:rnd:sat Rd.h[0]=(sat32((Rss.h[0] * Rtt.h[0])[<<1] +
                                                (Rss.h[1] * Rtt.h[1])[<<1] + 0x8000)).h[1];
                                                Rd.h[1]=(sat32((Rss.h[2] * Rtt.h[2])[<<1] +
                                                (Rss.h[3] * Rtt.h[3])[<<1] + 0x8000)).h[1];




80-N2040-36 B                                              575

                   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), the OVF bit in the Status Register is set.
                                        OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=vdmpy(Rss,Rtt):<<1:rnd:sat Word32 Q6_R_vdmpy_PP_s1_rnd_sat(Word64 Rss,
                                                        Word64 Rtt)
                          Rd=vdmpy(Rss,Rtt):rnd:sat                                   Word32 Q6_R_vdmpy_PP_rnd_sat(Word64 Rss,
                                                                                      Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp               s5           Parse               t5               MinOp            d5
1   1   1    0   1    0   0    1   N     -     -   s   s   s    s   s   P   P 0   t     t   t    t   t   -    0   0   d   d   d    d   d Rd=vdmpy(Rss,Rtt)[:<<N]:rnd:sat




                            Field name                                                               Description
                          ICLASS                       Instruction Class
                          MajOp                        Major Opcode
                          MinOp                        Minor Opcode
                          RegType                      Register Type
                          Parse                        Packet/Loop parse bits
                          d5                           Field to encode register d
                          s5                           Field to encode register s
                          t5                           Field to encode register t




80-N2040-36 B                                                                     576

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                          Instruction Set



Vector reduce multiply bytes
                Multiply eight 8-bit bytes in Rss by the corresponding 8-bit bytes in Rtt. The four lower
                results are accumulated. The lower word of the accumulator is optionally added. This
                result is stored in the lower 32-bits of the accumulator. The same operation is performed
                on the upper four products using the upper word of the accumulator. The eight bytes of
                Rss can be treated as either signed or unsigned.

                                                                                             Rss

                                                                                             Rtt




                        *          *         *    *             *        *         *    *
                            16      16       16      16             16    16       16   16


                                       Add                                   Add
                   32                                                                                32



                                 High Accumulation                   Low Accumulation

                                                          Rxx




80-N2040-36 B                                         577

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set




                                                Syntax                                                                 Behavior
                          Rdd=vrmpybsu(Rss,Rtt)                                    Rdd.w[0]=((Rss.b[0] * Rtt.ub[0]) +
                                                                                   (Rss.b[1] * Rtt.ub[1]) + (Rss.b[2] *
                                                                                   Rtt.ub[2]) + (Rss.b[3] * Rtt.ub[3]));
                                                                                   Rdd.w[1]=((Rss.b[4] * Rtt.ub[4]) +
                                                                                   (Rss.b[5] * Rtt.ub[5]) + (Rss.b[6] *
                                                                                   Rtt.ub[6]) + (Rss.b[7] * Rtt.ub[7]));
                          Rdd=vrmpybu(Rss,Rtt)                                     Rdd.w[0]=((Rss.ub[0] * Rtt.ub[0]) +
                                                                                   (Rss.ub[1] * Rtt.ub[1]) + (Rss.ub[2] *
                                                                                   Rtt.ub[2]) + (Rss.ub[3] * Rtt.ub[3]));
                                                                                   Rdd.w[1]=((Rss.ub[4] * Rtt.ub[4]) +
                                                                                   (Rss.ub[5] * Rtt.ub[5]) + (Rss.ub[6] *
                                                                                   Rtt.ub[6]) + (Rss.ub[7] * Rtt.ub[7]));
                          Rxx+=vrmpybsu(Rss,Rtt)                                   Rxx.w[0]=(Rxx.w[0] + (Rss.b[0] * Rtt.ub[0])
                                                                                   + (Rss.b[1] * Rtt.ub[1]) + (Rss.b[2] *
                                                                                   Rtt.ub[2]) + (Rss.b[3] * Rtt.ub[3]));
                                                                                   Rxx.w[1]=(Rxx.w[1] + (Rss.b[4] * Rtt.ub[4])
                                                                                   + (Rss.b[5] * Rtt.ub[5]) + (Rss.b[6] *
                                                                                   Rtt.ub[6]) + (Rss.b[7] * Rtt.ub[7]));
                          Rxx+=vrmpybu(Rss,Rtt)                                    Rxx.w[0]=(Rxx.w[0] + (Rss.ub[0] *
                                                                                   Rtt.ub[0]) + (Rss.ub[1] * Rtt.ub[1])                              +
                                                                                   (Rss.ub[2] * Rtt.ub[2]) + (Rss.ub[3]                              *
                                                                                   Rtt.ub[3]));
                                                                                   Rxx.w[1]=(Rxx.w[1] + (Rss.ub[4] *
                                                                                   Rtt.ub[4]) + (Rss.ub[5] * Rtt.ub[5])                              +
                                                                                   (Rss.ub[6] * Rtt.ub[6]) + (Rss.ub[7]                              *
                                                                                   Rtt.ub[7]));


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vrmpybsu(Rss,Rtt)                                    Word64 Q6_P_vrmpybsu_PP(Word64 Rss, Word64
                                                                                   Rtt)
                          Rdd=vrmpybu(Rss,Rtt)                                     Word64 Q6_P_vrmpybu_PP(Word64 Rss, Word64
                                                                                   Rtt)
                          Rxx+=vrmpybsu(Rss,Rtt)                                   Word64 Q6_P_vrmpybsuacc_PP(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)
                          Rxx+=vrmpybu(Rss,Rtt)                                    Word64 Q6_P_vrmpybuacc_PP(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   1    0   0    0   1    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rdd=vrmpybu(Rss,Rtt)
1   1   1    0   1    0   0    0   1    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rdd=vrmpybsu(Rss,Rtt)
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   1    0   1    0   1    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vrmpybu(Rss,Rtt)
1   1   1    0   1    0   1    0   1    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vrmpybsu(Rss,Rtt)




80-N2040-36 B                                                                  578

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                x5             Field to encode register x




80-N2040-36 B                                       579

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                               Instruction Set



Vector dual multiply signed by unsigned bytes
                Multiply eight 8-bit signed bytes in Rss by the corresponding 8-bit unsigned bytes in Rtt.
                Add the results in pairs, and optionally add the accumulator. The results are saturated to
                signed 16-bits and stored in the four halfwords of the destination register.


                                                                                                  Rss

                                                                                                  Rtt




                      *          *        *          *          *          *    *          *
                          16     16       16         16             16     16   16         16


                           Add                 Add                   Add             Add


                          Sat_16              Sat_16            Sat_16              Sat_16


                                                                                                         Rxx


                                 Syntax                                             Behavior
                Rdd=vdmpybsu(Rss,Rtt):sat                  Rdd.h[0]=sat16(((Rss.b[0]            * Rtt.ub[0]) +
                                                           (Rss.b[1] * Rtt.ub[1])));
                                                           Rdd.h[1]=sat16(((Rss.b[2]            * Rtt.ub[2]) +
                                                           (Rss.b[3] * Rtt.ub[3])));
                                                           Rdd.h[2]=sat16(((Rss.b[4]            * Rtt.ub[4]) +
                                                           (Rss.b[5] * Rtt.ub[5])));
                                                           Rdd.h[3]=sat16(((Rss.b[6]            * Rtt.ub[6]) +
                                                           (Rss.b[7] * Rtt.ub[7])));
                Rxx+=vdmpybsu(Rss,Rtt):sat                 Rxx.h[0]=sat16((Rxx.h[0]            + (Rss.b[0] *
                                                           Rtt.ub[0]) + (Rss.b[1] *            Rtt.ub[1])));
                                                           Rxx.h[1]=sat16((Rxx.h[1]            + (Rss.b[2] *
                                                           Rtt.ub[2]) + (Rss.b[3] *            Rtt.ub[3])));
                                                           Rxx.h[2]=sat16((Rxx.h[2]            + (Rss.b[4] *
                                                           Rtt.ub[4]) + (Rss.b[5] *            Rtt.ub[5])));
                                                           Rxx.h[3]=sat16((Rxx.h[3]            + (Rss.b[6] *
                                                           Rtt.ub[6]) + (Rss.b[7] *            Rtt.ub[7])));


                Class: XTYPE (slots 2,3)

                Notes

                    ï®     If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF will remain set until explicitly cleared by a transfer to SR.



80-N2040-36 B                                             580

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Intrinsics

                          Rdd=vdmpybsu(Rss,Rtt):sat                                Word64 Q6_P_vdmpybsu_PP_sat(Word64 Rss,
                                                                                   Word64 Rtt)
                          Rxx+=vdmpybsu(Rss,Rtt):sat                               Word64 Q6_P_vdmpybsuacc_PP_sat(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   1    0   0    0   1    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rdd=vdmpybsu(Rss,Rtt):sat
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5

1   1   1    0   1    0   1    0   0    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vdmpybsu(Rss,Rtt):sat




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  581

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                  Instruction Set



Vector multiply even halfwords
                Multiply the even 16-bit halfwords from Rss and Rtt separately. Optionally accumulate
                with the low and high words of the destination register pair and optionally saturate.


                                            Rxx+=vmpyeh(Rss,Rtt):sat

                                                                                    Rss


                                                                                    Rtt




                                            *                            *
                                              32                           32

                                         <<0-1                          <<0-1




                                        Add                             Add


                                       Sat_32                          Sat_32                    32
                         32



                                High Accumulation               Low Accumulation

                                                         Rxx


                              Syntax                                     Behavior
                Rdd=vmpyeh(Rss,Rtt):<<1:sat          Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0])<<1);
                                                     Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2])<<1);
                Rdd=vmpyeh(Rss,Rtt):sat              Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0])<<0);
                                                     Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2])<<0);
                Rxx+=vmpyeh(Rss,Rtt)                 Rxx.w[0]=Rxx.w[0] + (Rss.h[0] * Rtt.h[0]);
                                                     Rxx.w[1]=Rxx.w[1] + (Rss.h[2] * Rtt.h[2]);
                Rxx+=vmpyeh(Rss,Rtt):<<1:sat Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *
                                             Rtt.h[0])<<1);
                                             Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[2] *
                                             Rtt.h[2])<<1);
                Rxx+=vmpyeh(Rss,Rtt):sat             Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *
                                                     Rtt.h[0])<<0);
                                                     Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[2] *
                                                     Rtt.h[2])<<0);




80-N2040-36 B                                      582

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), the OVF bit in the Status Register is set.
                                        OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vmpyeh(Rss,Rtt):<<1:sat                              Word64 Q6_P_vmpyeh_PP_s1_sat(Word64 Rss,
                                                                                   Word64 Rtt)
                          Rdd=vmpyeh(Rss,Rtt):sat                                  Word64 Q6_P_vmpyeh_PP_sat(Word64 Rss,
                                                                                   Word64 Rtt)
                          Rxx+=vmpyeh(Rss,Rtt)                                     Word64 Q6_P_vmpyehacc_PP(Word64 Rxx, Word64
                                                                                   Rss, Word64 Rtt)
                          Rxx+=vmpyeh(Rss,Rtt):<<1:sat Word64 Q6_P_vmpyehacc_PP_s1_sat(Word64 Rxx,
                                                       Word64 Rss, Word64 Rtt)
                          Rxx+=vmpyeh(Rss,Rtt):sat                                 Word64 Q6_P_vmpyehacc_PP_sat(Word64 Rxx,
                                                                                   Word64 Rss, Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5

1   1   1    0   1    0   0    0   N 0      0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   0   d   d   d    d   d Rdd=vmpyeh(Rss,Rtt)[:<<N]:sat
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   1    0   1    0   0    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    1   0   x   x   x    x   x Rxx+=vmpyeh(Rss,Rtt)
1   1   1    0   1    0   1    0   N 0      0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   0   x   x   x    x   x Rxx+=vmpyeh(Rss,Rtt)[:<<N]:sat




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  583

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



Vector multiply halfwords
                Multiply two 16-bit halfwords separately, and optionally accumulate with the low and
                high words of the destination. Optionally saturate, and store the results back to the
                destination register pair.


                                            Rxx+=vmpyh(Rs,Rt):sat

                                                                           Rs


                                                                             Rt




                                             *               *
                                               32              32

                                            <<0-1          <<0-1




                                   Add                               Add


                                  Sat_32                            Sat_32                  32
                    32



                           High Accumulation               Low Accumulation

                                                    Rxx


                              Syntax                                         Behavior
                Rdd=vmpyh(Rs,Rt)[:<<1]:sat           Rdd.w[0]=sat32((Rs.h[0] * Rt.h[0])[<<1]);
                                                     Rdd.w[1]=sat32((Rs.h[1] * Rt.h[1])[<<1]);
                Rxx+=vmpyh(Rs,Rt)                    Rxx.w[0]=Rxx.w[0] + (Rs.h[0] * Rt.h[0]);
                                                     Rxx.w[1]=Rxx.w[1] + (Rs.h[1] * Rt.h[1]);
                Rxx+=vmpyh(Rs,Rt)[:<<1]:sat          Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] *
                                                     Rt.h[0])[<<1]);
                                                     Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] *
                                                     Rt.h[1])[<<1]);




80-N2040-36 B                                       584

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), the OVF bit in the Status Register is set.
                                        OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vmpyh(Rs,Rt):<<1:sat                                 Word64 Q6_P_vmpyh_RR_s1_sat(Word32 Rs,
                                                                                   Word32 Rt)
                          Rdd=vmpyh(Rs,Rt):sat                                     Word64 Q6_P_vmpyh_RR_sat(Word32 Rs, Word32
                                                                                   Rt)
                          Rxx+=vmpyh(Rs,Rt)                                        Word64 Q6_P_vmpyhacc_RR(Word64 Rxx, Word32
                                                                                   Rs, Word32 Rt)
                          Rxx+=vmpyh(Rs,Rt):<<1:sat                                Word64 Q6_P_vmpyhacc_RR_s1_sat(Word64 Rxx,
                                                                                   Word32 Rs, Word32 Rt)
                          Rxx+=vmpyh(Rs,Rt):sat                                    Word64 Q6_P_vmpyhacc_RR_sat(Word64 Rxx,
                                                                                   Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5

1   1   1    0   0    1   0    1   N 0      0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    0   1   d   d   d    d   d Rdd=vmpyh(Rs,Rt)[:<<N]:sat
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   0    1   1    1   0    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vmpyh(Rs,Rt)
1   1   1    0   0    1   1    1   N 0      0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    0   1   x   x   x    x   x Rxx+=vmpyh(Rs,Rt)[:<<N]:sat




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  585

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector multiply halfwords with round and pack
                Multiply two 16-bit halfwords separately. Round the results, and store the high halfwords
                packed in a single register destination.


                                        Rd=vmpyh(Rs,Rt):rnd:sat

                                                                           Rs


                                                                            Rt




                                          *                *
                                            32               32
                 0x8000                 <<0-1             <<0-1                   0x8000



                               Add                                   Add


                             Sat_32                                Sat_32


                                     High 16-bits
                                                                  High 16-bits


                                                                             Rd


                              Syntax                                              Behavior
                Rd=vmpyh(Rs,Rt)[:<<1]:rnd:sat Rd.h[1]=(sat32((Rs.h[1] * Rt.h[1])[<<1] +
                                              0x8000)).h[1];
                                              Rd.h[0]=(sat32((Rs.h[0] * Rt.h[0])[<<1] +
                                              0x8000)).h[1];


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                       586

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Intrinsics

                          Rd=vmpyh(Rs,Rt):<<1:rnd:sat                           Word32 Q6_R_vmpyh_RR_s1_rnd_sat(Word32 Rs,
                                                                                Word32 Rt)
                          Rd=vmpyh(Rs,Rt):rnd:sat                               Word32 Q6_R_vmpyh_RR_rnd_sat(Word32 Rs,
                                                                                Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                            8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp             s5           Parse               t5               MinOp            d5
1   1   1    0   1    1   0    1   N 0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   1   d   d   d    d   d Rd=vmpyh(Rs,Rt)[:<<N]:rnd:sat




                            Field name                                                         Description
                          ICLASS                 Instruction Class
                          MajOp                  Major Opcode
                          MinOp                  Minor Opcode
                          RegType                Register Type
                          Parse                  Packet/Loop parse bits
                          d5                     Field to encode register d
                          s5                     Field to encode register s
                          t5                     Field to encode register t




80-N2040-36 B                                                               587

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



Vector multiply halfwords, signed by unsigned
                          Multiply two 16-bit halfwords. Rs is considered signed, Ru unsigned.

                                               Syntax                                                                 Behavior
                          Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat  Rdd.w[0]=sat32((Rs.h[0] * Rt.uh[0])[<<1]);
                                                        Rdd.w[1]=sat32((Rs.h[1] * Rt.uh[1])[<<1]);
                          Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] * Rt.uh[0])[<<1]);
                                                        Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] * Rt.uh[1])[<<1]);


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®    If saturation occurs during execution of this instruction (a result is clamped to
                                        either maximum or minimum values), the OVF bit in the Status Register is set.
                                        OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vmpyhsu(Rs,Rt):<<1:sat                              Word64 Q6_P_vmpyhsu_RR_s1_sat(Word32 Rs,
                                                                                  Word32 Rt)
                          Rdd=vmpyhsu(Rs,Rt):sat                                  Word64 Q6_P_vmpyhsu_RR_sat(Word32 Rs,
                                                                                  Word32 Rt)
                          Rxx+=vmpyhsu(Rs,Rt):<<1:sat                             Word64 Q6_P_vmpyhsuacc_RR_s1_sat(Word64
                                                                                  Rxx, Word32 Rs, Word32 Rt)
                          Rxx+=vmpyhsu(Rs,Rt):sat                                 Word64 Q6_P_vmpyhsuacc_RR_sat(Word64 Rxx,
                                                                                  Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp           s5           Parse               t5               MinOp            d5
1   1   1    0   0    1   0    1   N 0     0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   1   d   d   d    d   d Rdd=vmpyhsu(Rs,Rt)[:<<N]:sat
    ICLASS           RegType           MajOp           s5           Parse               t5               MinOp            x5

1   1   1    0   0    1   1    1   N 1     1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    0   1   x   x   x    x   x Rxx+=vmpyhsu(Rs,Rt)[:<<N]:sat




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d



80-N2040-36 B                                                                 588

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                s5             Field to encode register s
                t5             Field to encode register t
                x5             Field to encode register x




80-N2040-36 B                                       589

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector reduce multiply halfwords
                Multiply each halfword of Rss by the corresponding halfword in Rtt. Add the intermediate
                products together and then optionally add the accumulator. Store the full 64-bit result in
                the destination register pair.

                This instruction is known as "big mac".


                                                                                       Rss


                                                                                        Rtt




                           *                *                *              *
                               32                                          32
                                                32           32




                                                     Add

                                                                                                64

                                                                                       Rdd
                                            64-bit Register Pair


                               Syntax                                     Behavior
                Rdd=vrmpyh(Rss,Rtt)                   Rdd = (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
                                                      Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) +
                                                      (Rss.h[3] * Rtt.h[3]);
                Rxx+=vrmpyh(Rss,Rtt)                  Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) +
                                                      (Rss.h[1] * Rtt.h[1]) + (Rss.h[2] *
                                                      Rtt.h[2]) + (Rss.h[3] * Rtt.h[3]);


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rdd=vrmpyh(Rss,Rtt)                   Word64 Q6_P_vrmpyh_PP(Word64 Rss, Word64
                                                      Rtt)
                Rxx+=vrmpyh(Rss,Rtt)                  Word64 Q6_P_vrmpyhacc_PP(Word64 Rxx, Word64
                                                      Rss, Word64 Rtt)




80-N2040-36 B                                        590

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   1    0   0    0   0    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    1   0   d   d   d    d   d Rdd=vrmpyh(Rss,Rtt)
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   1    0   1    0   0    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    1   0   x   x   x    x   x Rxx+=vrmpyh(Rss,Rtt)




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  591

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Vector multiply bytes
                Four 8-bit bytes from register Rs are multiplied by four 8-bit bytes from Rt. The product is
                optionally accumulated with the 16-bit value from the destination register. The 16-bit
                results are packed in the destination register pair. The bytes of Rs can be treated as either
                signed or unsigned.


                                                                      Rs

                                                                      Rt




                                     *       *        *       *


                        Add              Add              Add              Add




                                                                                        Rxx


                               Syntax                                       Behavior
                Rdd=vmpybsu(Rs,Rt)                    Rdd.h[0]=((Rs.b[0]      *   Rt.ub[0]));
                                                      Rdd.h[1]=((Rs.b[1]      *   Rt.ub[1]));
                                                      Rdd.h[2]=((Rs.b[2]      *   Rt.ub[2]));
                                                      Rdd.h[3]=((Rs.b[3]      *   Rt.ub[3]));
                Rdd=vmpybu(Rs,Rt)                     Rdd.h[0]=((Rs.ub[0]      *   Rt.ub[0]));
                                                      Rdd.h[1]=((Rs.ub[1]      *   Rt.ub[1]));
                                                      Rdd.h[2]=((Rs.ub[2]      *   Rt.ub[2]));
                                                      Rdd.h[3]=((Rs.ub[3]      *   Rt.ub[3]));
                Rxx+=vmpybsu(Rs,Rt)                   Rxx.h[0]=(Rxx.h[0]+(Rs.b[0]        *   Rt.ub[0]));
                                                      Rxx.h[1]=(Rxx.h[1]+(Rs.b[1]        *   Rt.ub[1]));
                                                      Rxx.h[2]=(Rxx.h[2]+(Rs.b[2]        *   Rt.ub[2]));
                                                      Rxx.h[3]=(Rxx.h[3]+(Rs.b[3]        *   Rt.ub[3]));
                Rxx+=vmpybu(Rs,Rt)                    Rxx.h[0]=(Rxx.h[0]+(Rs.ub[0]         *   Rt.ub[0]));
                                                      Rxx.h[1]=(Rxx.h[1]+(Rs.ub[1]         *   Rt.ub[1]));
                                                      Rxx.h[2]=(Rxx.h[2]+(Rs.ub[2]         *   Rt.ub[2]));
                                                      Rxx.h[3]=(Rxx.h[3]+(Rs.ub[3]         *   Rt.ub[3]));




80-N2040-36 B                                       592

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=vmpybsu(Rs,Rt)                                       Word64 Q6_P_vmpybsu_RR(Word32 Rs, Word32
                                                                                   Rt)
                          Rdd=vmpybu(Rs,Rt)                                        Word64 Q6_P_vmpybu_RR(Word32 Rs, Word32 Rt)
                          Rxx+=vmpybsu(Rs,Rt)                                      Word64 Q6_P_vmpybsuacc_RR(Word64 Rxx,
                                                                                   Word32 Rs, Word32 Rt)
                          Rxx+=vmpybu(Rs,Rt)                                       Word64 Q6_P_vmpybuacc_RR(Word64 Rxx, Word32
                                                                                   Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   0    1   0    1   0    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rdd=vmpybsu(Rs,Rt)
1   1   1    0   0    1   0    1   1    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   d   d   d    d   d Rdd=vmpybu(Rs,Rt)
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   0    1   1    1   1    0   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vmpybu(Rs,Rt)
1   1   1    0   0    1   1    1   1    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   0    0   1   x   x   x    x   x Rxx+=vmpybsu(Rs,Rt)




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          x5                        Field to encode register x




80-N2040-36 B                                                                  593

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                   Instruction Set



Vector polynomial multiply halfwords
                Perform a vector 16x16 carryless polynomial multiply using 32-bit source registers Rs and
                Rt. The 64-bit result is stored in packed H,H,L,L format in the destination register. The
                destination register can also be optionally accumulated (XORâd). Finite field multiply
                instructions are useful for many algorithms including scramble code generation,
                cryptographic algorithms, convolutional, and Reed Solomon codes.
                            Rxx += vpmpyh(Rs,Rt)


                                Rs



                                Rt


                              16x16
                             Carryless                         16x16
                                                             Carryless
                            Polynomial
                               Mpy          *            *   Polynomial
                                                                Mpy




                                          XOR       XOR




                                                                      Rxx




80-N2040-36 B                                      594

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set




                                                Syntax                                                                 Behavior
                          Rdd=vpmpyh(Rs,Rt)                                        x0 = Rs.uh[0];
                                                                                   x1 = Rs.uh[1];
                                                                                   y0 = Rt.uh[0];
                                                                                   y1 = Rt.uh[1];
                                                                                   prod0 = prod1 = 0;
                                                                                   for(i=0; i < 16; i++) {
                                                                                       if((y0 >> i) & 1) prod0 ^= (x0 << i);
                                                                                       if((y1 >> i) & 1) prod1 ^= (x1 << i);
                                                                                   };
                                                                                   Rdd.h[0]=prod0.uh[0];
                                                                                   Rdd.h[1]=prod1.uh[0];
                                                                                   Rdd.h[2]=prod0.uh[1];
                                                                                   Rdd.h[3]=prod1.uh[1];
                          Rxx^=vpmpyh(Rs,Rt)                                       x0 = Rs.uh[0];
                                                                                   x1 = Rs.uh[1];
                                                                                   y0 = Rt.uh[0];
                                                                                   y1 = Rt.uh[1];
                                                                                   prod0 = prod1 = 0;
                                                                                   for(i=0; i < 16; i++) {
                                                                                       if((y0 >> i) & 1) prod0 ^= (x0 << i);
                                                                                       if((y1 >> i) & 1) prod1 ^= (x1 << i);
                                                                                   };
                                                                                   Rxx.h[0]=Rxx.uh[0] ^ prod0.uh[0];
                                                                                   Rxx.h[1]=Rxx.uh[1] ^ prod1.uh[0];
                                                                                   Rxx.h[2]=Rxx.uh[2] ^ prod0.uh[1];
                                                                                   Rxx.h[3]=Rxx.uh[3] ^ prod1.uh[1];


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vpmpyh(Rs,Rt)                                        Word64 Q6_P_vpmpyh_RR(Word32 Rs, Word32 Rt)
                          Rxx^=vpmpyh(Rs,Rt)                                       Word64 Q6_P_vpmpyhxacc_RR(Word64 Rxx,
                                                                                   Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            d5
1   1   1    0   0    1   0    1   1    1   0   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   1   d   d   d    d   d Rdd=vpmpyh(Rs,Rt)
    ICLASS           RegType           MajOp            s5           Parse               t5               MinOp            x5
1   1   1    0   0    1   1    1   1    0   1   s   s   s    s   s   P   P 0   t     t   t    t   t   1    1   1   x   x   x    x   x Rxx^=vpmpyh(Rs,Rt)




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d




80-N2040-36 B                                                                  595

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                s5             Field to encode register s
                t5             Field to encode register t
                x5             Field to encode register x




80-N2040-36 B                                       596

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



    11.10.6 XTYPE/PERM
                          The XTYPE/PERM instruction subclass includes instructions which perform
                          permutations.

CABAC decode bin
                          This is a special-purpose instruction to support H.264 Context Adaptive Binary
                          Arithmetic Coding (CABAC). See Section 4.8.1 for a complete description.

                                                 Syntax                                                                  Behavior
                          Rdd=decbin(Rss,Rtt)                                         state = Rtt.w[1][5:0];
                                                                                      valMPS = Rtt.w[1][8:8];
                                                                                      bitpos = Rtt.w[0][4:0];
                                                                                      range = Rss.w[0];
                                                                                      offset = Rss.w[1];
                                                                                      range <<= bitpos;
                                                                                      offset <<= bitpos;
                                                                                      rLPS = rLPS_table_64x4[state][ (range
                                                                                      >>29)&3];
                                                                                      rLPS = rLPS << 23;
                                                                                      rMPS= (range&0xff800000) - rLPS;
                                                                                      if (offset < rMPS) {
                                                                                          Rdd = AC_next_state_MPS_64[state];
                                                                                          Rdd[8:8]=valMPS;
                                                                                          Rdd[31:23]=(rMPS>>23);
                                                                                          Rdd.w[1]=offset;
                                                                                          P0=valMPS;
                                                                                      } else {
                                                                                          Rdd = AC_next_state_LPS_64[state];
                                                                                          Rdd[8:8]=((!state)?(1-
                                                                                      valMPS):(valMPS));
                                                                                          Rdd[31:23]=(rLPS>>23);
                                                                                          Rdd.w[1]=(offset-rMPS);
                                                                                          P0=(valMPS^1);
                                                                                      };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®     The predicate generated by this instruction can not be used as a .new predicate,
                                         nor can it be automatically ANDed with another predicate.

                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2    1   0
    ICLASS           RegType           Maj               s5           Parse                 t5           Min                 d5
1   1   0    0   0    0   0    1   1     1   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1   1   -   d   d   d    d   d Rdd=decbin(Rss,Rtt)




80-N2040-36 B                                                                     597

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       598

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Saturate
                Saturate a single scalar value.

                sath saturates a signed 32-bit number to a signed 16-bit number, which is sign-extended
                back to 32 bits and placed in the destination register. The minimum negative value of the
                result is 0xffff8000 and the maximum positive value is 0x00007fff.

                satuh saturates a signed 32-bit number to an unsigned 16-bit number, which is zero-
                extended back to 32 bits and placed in the destination register. The minimum value of the
                result is 0 and the maximum value is 0x0000ffff.

                satb saturates a signed 32-bit number to an signed 8-bit number, which is sign-extended
                back to 32 bits and placed in the destination register. The minimum value of the result is
                0xffffff80 and the maximum value is 0x0000007f.

                satub saturates a signed 32-bit number to an unsigned 8-bit number, which is zero-
                extended back to 32 bits and placed in the destination register. The minimum value of the
                result is 0 and the maximum value is 0x000000ff.

                               Syntax                                       Behavior
                Rd=sat(Rss)                           Rd = sat32(Rss);
                Rd=satb(Rs)                           Rd = sat8(Rs);
                Rd=sath(Rs)                           Rd = sat16(Rs);
                Rd=satub(Rs)                          Rd = usat8(Rs);
                Rd=satuh(Rs)                          Rd = usat16(Rs);


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), the OVF bit in the Status Register is set.
                         OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rd=sat(Rss)                           Word32 Q6_R_sat_P(Word64 Rss)
                Rd=satb(Rs)                           Word32 Q6_R_satb_R(Word32 Rs)
                Rd=sath(Rs)                           Word32 Q6_R_sath_R(Word32 Rs)
                Rd=satub(Rs)                          Word32 Q6_R_satub_R(Word32 Rs)
                Rd=satuh(Rs)                          Word32 Q6_R_satuh_R(Word32 Rs)




80-N2040-36 B                                       599

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   1    0   0    0   1   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   0    0   0   d   d   d    d   d Rd=sat(Rss)
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   0   d   d   d    d   d Rd=sath(Rs)
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   1   d   d   d    d   d Rd=satuh(Rs)
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   0   d   d   d    d   d Rd=satub(Rs)
1   0   0    0   1    1   0    0   1   1   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   1   d   d   d    d   d Rd=satb(Rs)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   600

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Swizzle bytes
                          Swizzle the bytes of a word. This instruction is useful in converting between little and big
                          endian formats.


                              Rd=swiz(Rs)
                                                                                    Rs



                                                                                    Rd


                                               Syntax                                                                  Behavior
                          Rd=swiz(Rs)                                               Rd.b[0]=Rs.b[3];
                                                                                    Rd.b[1]=Rs.b[2];
                                                                                    Rd.b[2]=Rs.b[1];
                                                                                    Rd.b[3]=Rs.b[0];


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=swiz(Rs)                                               Word32 Q6_R_swiz_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   1    1   0    0   1   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   1   d   d   d    d   d Rd=swiz(Rs)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   601

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                              Instruction Set



Vector align
                          Align a vector. Use the immediate amount, or the least significant 3 bits of a Predicate
                          register, as the number of bytes to align. Shift the Rss register pair right by this number of
                          bytes. Fill the vacated positions with the least significant elements from Rtt.


                                                                                                                                               #u3/P


                              Rtt                                                                                                                      Rss



                                                                                                                                     Rdd


                                                Syntax                                                                       Behavior
                          Rdd=valignb(Rtt,Rss,#u3)                                   Rdd = (Rss >>> #u*8)|(Rtt << ((8-#u)*8));
                          Rdd=valignb(Rtt,Rss,Pu)                                    Rdd = Rss >>> (Pu&0x7)*8|(Rtt << (8-
                                                                                     (Pu&0x7))*8);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=valignb(Rtt,Rss,#u3)                                   Word64 Q6_P_valignb_PPI(Word64 Rtt, Word64
                                                                                     Rss, Word32 Iu3)
                          Rdd=valignb(Rtt,Rss,Pu)                                    Word64 Q6_P_valignb_PPp(Word64 Rtt, Word64
                                                                                     Rss, Byte Pu)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6    5       4   3   2    1    0
    ICLASS           RegType        Maj                 s5           Parse                 t5           Min                      d5
1   1   0    0   0    0   0    0    0   -   -   s   s   s    s   s   P   P   -   t     t   t    t   t   i   i        i   d   d   d    d    d Rdd=valignb(Rtt,Rss,#u3)
    ICLASS           RegType        Maj                 s5           Parse                 t5                   u2               d5
1   1   0    0   0    0   1    0    0   -   -   s   s   s    s   s   P   P   -   t     t   t    t   t   -   u    u       d   d   d    d    d Rdd=valignb(Rtt,Rss,Pu)




                            Field name                                                              Description
                          ICLASS                    Instruction Class
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          u2                        Field to encode register u




80-N2040-36 B                                                                    602

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                  603

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector round and pack
                Add the constant 0x00008000 to each word in the 64-bit source vector Rss. Optionally
                saturate this addition to 32bits. Pack the high halfwords of the result into the
                corresponding halfword of the 32-bit destination register.


                             Rss.w[1]                               Rss.w[0]               Rss



                                        0x8000                                  0x8000

                             32-bit Add                              32-bit Add




                                          Rd.h[1]         Rd.h[0]              Rd


                              Syntax                                           Behavior
                Rd=vrndwh(Rss)                       for (i=0;i<2;i++) {
                                                         Rd.h[i]=(Rss.w[i]+0x08000).h[1];
                                                     };
                Rd=vrndwh(Rss):sat                   for (i=0;i<2;i++) {
                                                         Rd.h[i]=sat32(Rss.w[i]+0x08000).h[1];
                                                     };


                Class: XTYPE (slots 2,3)

                Notes

                    ï®   If saturation occurs during execution of this instruction (a result is clamped to
                        either maximum or minimum values), the OVF bit in the Status Register is set.
                        OVF will remain set until explicitly cleared by a transfer to SR.

                Intrinsics

                Rd=vrndwh(Rss)                       Word32 Q6_R_vrndwh_P(Word64 Rss)
                Rd=vrndwh(Rss):sat                   Word32 Q6_R_vrndwh_P_sat(Word64 Rss)




80-N2040-36 B                                       604

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   1    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    0   0   d   d   d    d   d Rd=vrndwh(Rss)
1   0   0    0   1    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   0   d   d   d    d   d Rd=vrndwh(Rss):sat




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   605

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                Instruction Set



Vector saturate and pack
                    For each element in the vector, saturate the value to the next smaller size. VSATHUB
                    saturates signed halfwords to unsigned bytes, while VSATHB saturates signed halfwords
                    to signed bytes.


        Rd=vsathub(Rss)                                                          Rd=vsathub(Rs)

            s16             s16              s16         s16                           s16              s16          Rs
                                                                    Rss

                                                                                    Sat_u8          Sat_u8
           Sat_u8          Sat_u8        Sat_u8          Sat_u8



                          u8      u8    u8         u8   Rd                         0         0     u8         u8     Rd


     Rd=vsathb(Rss)                                                               Rd=vsathb(Rs)
            s16             s16              s16         s16        Rss                  s16            s16              Rs


           Sat_s8          Sat_s8        Sat_s8          Sat_s8                        Sat_s8           Sat_s8



                          s8      s8    s8         s8   Rd                          0          0   s8         s8         Rd


                    VSATWH saturates signed words to signed halfwords, while VSATWUH saturates signed
                    words to unsigned halfwords. The resulting values are packed together into destination
                    register Rd.


 Rd=vsathwh(Rss)                                                      Rd=vsathwuh(Rss)
             s32                              s32             Rss                 s32                              s32        Rss

                Sat_s16                      Sat_s16                                                             Sat_u16
                                                                                Sat_u16

                        s16            s16         Rd                                     u16             u16        Rd




80-N2040-36 B                                                606

                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set




                                               Syntax                                                                  Behavior
                          Rd=vsathb(Rs)                                             Rd.b[0]=sat8(Rs.h[0]);
                                                                                    Rd.b[1]=sat8(Rs.h[1]);
                                                                                    Rd.b[2]=0;
                                                                                    Rd.b[3]=0;
                          Rd=vsathb(Rss)                                            for (i=0;i<4;i++) {
                                                                                        Rd.b[i]=sat8(Rss.h[i]);
                                                                                    };
                          Rd=vsathub(Rs)                                            Rd.b[0]=usat8(Rs.h[0]);
                                                                                    Rd.b[1]=usat8(Rs.h[1]);
                                                                                    Rd.b[2]=0;
                                                                                    Rd.b[3]=0;
                          Rd=vsathub(Rss)                                           for (i=0;i<4;i++) {
                                                                                        Rd.b[i]=usat8(Rss.h[i]);
                                                                                    };
                          Rd=vsatwh(Rss)                                            for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=sat16(Rss.w[i]);
                                                                                    };
                          Rd=vsatwuh(Rss)                                           for (i=0;i<2;i++) {
                                                                                        Rd.h[i]=usat16(Rss.w[i]);
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=vsathb(Rs)                                             Word32 Q6_R_vsathb_R(Word32 Rs)
                          Rd=vsathb(Rss)                                            Word32 Q6_R_vsathb_P(Word64 Rss)
                          Rd=vsathub(Rs)                                            Word32 Q6_R_vsathub_R(Word32 Rs)
                          Rd=vsathub(Rss)                                           Word32 Q6_R_vsathub_P(Word64 Rss)
                          Rd=vsatwh(Rss)                                            Word32 Q6_R_vsatwh_P(Word64 Rss)
                          Rd=vsatwuh(Rss)                                           Word32 Q6_R_vsatwuh_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   1    0   0    0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   0    0   0   d   d   d    d   d Rd=vsathub(Rss)




80-N2040-36 B                                                                   607

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                               Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                           8   7   6   5   4   3   2   1   0
1   0   0   0   1   0   0   0   0   0   0   s   s   s   s   s   P   P   -   -     -   -   -   -   0   1   0   d   d   d   d   d Rd=vsatwh(Rss)
1   0   0   0   1   0   0   0   0   0   0   s   s   s   s   s   P   P   -   -     -   -   -   -   1   0   0   d   d   d   d   d Rd=vsatwuh(Rss)
1   0   0   0   1   0   0   0   0   0   0   s   s   s   s   s   P   P   -   -     -   -   -   -   1   1   0   d   d   d   d   d Rd=vsathb(Rss)
1   0   0   0   1   1   0   0   1   0   -   s   s   s   s   s   P   P   -   -     -   -   -   -   0   0   -   d   d   d   d   d Rd=vsathb(Rs)
1   0   0   0   1   1   0   0   1   0   -   s   s   s   s   s   P   P   -   -     -   -   -   -   0   1   -   d   d   d   d   d Rd=vsathub(Rs)




                          Field name                                                          Description
                        ICLASS                  Instruction Class
                        Parse                   Packet/Loop parse bits
                        d5                      Field to encode register d
                        s5                      Field to encode register s
                        MajOp                   Major Opcode
                        MinOp                   Minor Opcode
                        RegType                 Register Type




80-N2040-36 B                                                               608

                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                               Instruction Set



Vector saturate without pack
                Saturate each element of source vector Rss to the next smaller size. VSATHUB saturates
                signed halfwords to unsigned bytes. VSATWH saturates signed words to signed
                halfwords, and VSATWUH saturates signed words to unsigned halfwords. The resulting
                values are placed in destination register Rdd in unpacked form.


                                                   Rdd=vsathub(Rss)

                          s16                    s16                 s16             s16          Rss



                         Sat_u8                 Sat_u8               Sat_u8          Sat_u8




                     0          u8          0          u8       0          u8   0          u8     Rdd




                                                   Rdd=vsathb(Rss)

                          s16                    s16                 s16             s16          Rss



                         Sat_s8                 Sat_s8               Sat_s8          Sat_s8




                    se                  se                      se              se
                                  s8                     s8                s8              s8     Rdd


                                   Syntax                                              Behavior
                Rdd=vsathb(Rss)                                for (i=0;i<4;i++) {
                                                                   Rdd.h[i]=sat8(Rss.h[i]);
                                                               };
                Rdd=vsathub(Rss)                               for (i=0;i<4;i++) {
                                                                   Rdd.h[i]=usat8(Rss.h[i]);
                                                               };
                Rdd=vsatwh(Rss)                                for (i=0;i<2;i++) {
                                                                   Rdd.w[i]=sat16(Rss.w[i]);
                                                               };
                Rdd=vsatwuh(Rss)                               for (i=0;i<2;i++) {
                                                                   Rdd.w[i]=usat16(Rss.w[i]);
                                                               };




80-N2040-36 B                                                 609

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rdd=vsathb(Rss)                                           Word64 Q6_P_vsathb_P(Word64 Rss)
                          Rdd=vsathub(Rss)                                          Word64 Q6_P_vsathub_P(Word64 Rss)
                          Rdd=vsatwh(Rss)                                           Word64 Q6_P_vsatwh_P(Word64 Rss)
                          Rdd=vsatwuh(Rss)                                          Word64 Q6_P_vsatwuh_P(Word64 Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   -   -    -    -   -   -   1    0   0   d   d   d    d   d Rdd=vsathub(Rss)
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   -   -    -    -   -   -   1    0   1   d   d   d    d   d Rdd=vsatwuh(Rss)
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   -   -    -    -   -   -   1    1   0   d   d   d    d   d Rdd=vsatwh(Rss)
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   -   -     -   -   -   -   1    1   1   d   d   d    d   d Rdd=vsathb(Rss)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   610

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                  Instruction Set



Vector shuffle
                Shuffle odd halfwords (shuffoh) takes the odd halfwords from Rtt and the odd halfwords
                from Rss and merges them together into vector Rdd. Shuffle even halfwords (shuffeh)
                performs the same operation on every even halfword in Rss and Rtt. The same operation is
                available for odd and even bytes.

                             shuffoh                                         shuffeh
                                                   Rtt                                              Rss


                                                   Rss                                              Rtt




                                                   Rdd                                              Rdd



                             shuffob                                         shuffeb
                                                   Rtt                                              Rss


                                                   Rss                                              Rtt




                                                   Rdd                                             Rdd


                              Syntax                                     Behavior
                Rdd=shuffeb(Rss,Rtt)                for (i=0;i<4;i++) {
                                                        Rdd.b[i*2]=Rtt.b[i*2];
                                                        Rdd.b[i*2+1]=Rss.b[i*2];
                                                    };
                Rdd=shuffeh(Rss,Rtt)                for (i=0;i<2;i++) {
                                                        Rdd.h[i*2]=Rtt.h[i*2];
                                                        Rdd.h[i*2+1]=Rss.h[i*2];
                                                    };
                Rdd=shuffob(Rtt,Rss)                for (i=0;i<4;i++) {
                                                        Rdd.b[i*2]=Rss.b[i*2+1];
                                                        Rdd.b[i*2+1]=Rtt.b[i*2+1];
                                                    };
                Rdd=shuffoh(Rtt,Rss)                for (i=0;i<2;i++) {
                                                        Rdd.h[i*2]=Rss.h[i*2+1];
                                                        Rdd.h[i*2+1]=Rtt.h[i*2+1];
                                                    };




80-N2040-36 B                                     611

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=shuffeb(Rss,Rtt)                                      Word64 Q6_P_shuffeb_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=shuffeh(Rss,Rtt)                                      Word64 Q6_P_shuffeh_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=shuffob(Rtt,Rss)                                      Word64 Q6_P_shuffob_PP(Word64 Rtt, Word64
                                                                                    Rss)
                          Rdd=shuffoh(Rtt,Rss)                                      Word64 Q6_P_shuffoh_PP(Word64 Rtt, Word64
                                                                                    Rss)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse                t5           Min                 d5
1   1   0    0   0    0   0    1   0   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   d   d   d    d   d Rdd=shuffeb(Rss,Rtt)
1   1   0    0   0    0   0    1   0   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   -   d   d   d    d   d Rdd=shuffob(Rtt,Rss)
1   1   0    0   0    0   0    1   0   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   -   d   d   d    d   d Rdd=shuffeh(Rss,Rtt)
1   1   0    0   0    0   0    1   1   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   0   d   d   d    d   d Rdd=shuffoh(Rtt,Rss)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   612

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                         Instruction Set



Vector splat bytes
                          Replicate the low 8-bits from register Rs into each of the four bytes of destination register
                          Rd.


                                       Rd=vsplatb(Rs)

                                                                                     Rs



                                                                                     Rd

                                                Syntax                                                                    Behavior
                          Rd=vsplatb(Rs)                                             for (i=0;i<4;i++) {
                                                                                         Rd.b[i]=Rs.b[0];
                                                                                     };
                          Rdd=vsplatb(Rs)                                            for (i=0;i<8;i++) {
                                                                                         Rdd.b[i]=Rs.b[0];
                                                                                     };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=vsplatb(Rs)                                             Word32 Q6_R_vsplatb_R(Word32 Rs)
                          Rdd=vsplatb(Rs)                                            Word64 Q6_P_vsplatb_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5      4   3   2    1   0
    ICLASS           RegType       MajOp                s5           Parse                                MinOp               d5
1   0   0    0   0    1   0    0   0    1   -   s   s   s    s   s   P   P   -   -    -   -   -   -   1    0      -   d   d   d    d   d Rdd=vsplatb(Rs)
1   0   0    0   1    1   0    0   0    1   0   s   s   s    s   s   P   P   -   -    -   -   -   -   1    1   1      d   d   d    d   d Rd=vsplatb(Rs)




                            Field name                                                            Description
                          ICLASS                    Instruction Class
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          MajOp                     Major Opcode
                          MinOp                     Minor Opcode
                          RegType                   Register Type




80-N2040-36 B                                                                    613

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Vector splat halfwords
                          Replicate the low 16-bits from register Rs into each of the four halfwords of destination
                          Rdd.


                                                                                     Rdd=vsplath(Rs)

                                                                                                                                          Rs



                                                                                                                                          Rdd

                                               Syntax                                                                    Behavior
                          Rdd=vsplath(Rs)                                           for (i=0;i<4;i++) {
                                                                                        Rdd.h[i]=Rs.h[0];
                                                                                    };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vsplath(Rs)                                           Word64 Q6_P_vsplath_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7    6   5      4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                MinOp               d5
1   0   0    0   0    1   0    0   0   1   -   s   s   s    s   s   P   P   -   -    -   -   -   -   0    1      -   d   d   d    d   d Rdd=vsplath(Rs)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   614

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



Vector splice
                          Concatenate the low (8-N) bytes of vector Rtt with the low N bytes of vector Rss. This
                          instruction is helpful to vectorize unaligned stores.


                                                                                                                                #u3/P

                              Rtt                                                                                                                       Rss




                                                                                                                                 Rdd


                                                Syntax                                                                      Behavior
                          Rdd=vspliceb(Rss,Rtt,#u3)                                  Rdd = Rtt << #u*8 | zxt#u*8->64(Rss);
                          Rdd=vspliceb(Rss,Rtt,Pu)                                   Rdd = Rtt << (Pu&7)*8 | zxt(Pu&7)*8->64(Rss);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vspliceb(Rss,Rtt,#u3)                                  Word64 Q6_P_vspliceb_PPI(Word64 Rss, Word64
                                                                                     Rtt, Word32 Iu3)
                          Rdd=vspliceb(Rss,Rtt,Pu)                                   Word64 Q6_P_vspliceb_PPp(Word64 Rss, Word64
                                                                                     Rtt, Byte Pu)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6    5       4   3   2    1   0
    ICLASS           RegType        Maj                 s5           Parse                t5           Min                      d5
1   1   0    0   0    0   0    0    1   -   -   s   s   s    s   s   P   P   -   t    t   t    t   t   i   i        i   d   d   d    d   d Rdd=vspliceb(Rss,Rtt,#u3)
    ICLASS           RegType        Maj                 s5           Parse                t5                   u2               d5
1   1   0    0   0    0   1    0    1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   -   u    u       d   d   d    d   d Rdd=vspliceb(Rss,Rtt,Pu)




                            Field name                                                             Description
                          ICLASS                    Instruction Class
                          Parse                     Packet/Loop parse bits
                          d5                        Field to encode register d
                          s5                        Field to encode register s
                          t5                        Field to encode register t
                          u2                        Field to encode register u
                          Maj                       Major Opcode
                          Min                       Minor Opcode
                          RegType                   Register Type




80-N2040-36 B                                                                    615

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                               Instruction Set



Vector sign extend
                          vsxtbh sign-extends each byte of a single register source to halfwords, and places the
                          result in the destination register pair.

                          vsxthw sign-extends each halfword of a single register source to words, and places the
                          result in the destination register pair.


                                     Rdd=vsxtbh(Rs)                                                                                               Rs


                                   sign                       sign                       sign                         sign                        Rdd




                                                                                                                                                  Rs
                                   Rdd=vsxthw(Rs)


                                          sign                                                sign                                                Rdd


                                                  Syntax                                                                         Behavior
                          Rdd=vsxtbh(Rs)                                                 for (i=0;i<4;i++) {
                                                                                             Rdd.h[i]=Rs.b[i];
                                                                                         };
                          Rdd=vsxthw(Rs)                                                 for (i=0;i<2;i++) {
                                                                                             Rdd.w[i]=Rs.h[i];
                                                                                         };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vsxtbh(Rs)                                                 Word64 Q6_P_vsxtbh_R(Word32 Rs)
                          Rdd=vsxthw(Rs)                                                 Word64 Q6_P_vsxthw_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7    6    5     4   3   2    1   0
    ICLASS           RegType        MajOp                 s5             Parse                                   MinOp               d5
1   0   0    0   0    1   0    0    0     0   -   s   s   s    s     s   P   P   -   -    -     -    -   -   0    0      -   d   d   d    d   d Rdd=vsxtbh(Rs)
1   0   0    0   0    1   0    0    0     0   -   s   s   s    s     s   P   P   -   -    -     -    -   -   1    0      -   d   d   d    d   d Rdd=vsxthw(Rs)




80-N2040-36 B                                                                        616

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       617

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector truncate
                In vtrunehb, for each halfword in a vector, take the even (lower) byte and ignore the other
                byte. The resulting values are packed into destination register Rd.

                vtrunohb takes each odd byte of the source vector.

                vtrunewh uses two source register pairs, Rss and Rtt. The even (lower) halfwords of Rss
                are packed in the upper word of Rdd, while the lower halfwords of Rtt are packed in the
                lower word of Rdd.

                vtrunowh performs the same operation as vtrunewh, but uses the odd (upper) halfwords of
                the source vectors instead.


  Rd=vtrunehb(Rss)                                            Rdd=vtrunewh(Rss,Rtt)
                                                                                                                Rss
                                                Rss
                                                                                                                Rtt
                                                Rd
                                                                                                                Rdd


  Rd=vtrunohb(Rss)
                                                              Rdd=vtrunowh(Rss,Rtt)
                                                Rss                                                             Rss
                                                                                                                Rtt
                                                Rd

                                                                                                                Rdd


                              Syntax                                       Behavior
                Rd=vtrunehb(Rss)                       for (i=0;i<4;i++) {
                                                           Rd.b[i]=Rss.b[i*2];
                                                       };




80-N2040-36 B                                         618

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



                                               Syntax                                                                   Behavior
                          Rd=vtrunohb(Rss)                                          for (i=0;i<4;i++) {
                                                                                        Rd.b[i]=Rss.b[i*2+1];
                                                                                    };
                          Rdd=vtrunehb(Rss,Rtt)                                     for (i=0;i<4;i++) {
                                                                                        Rdd.b[i]=Rtt.b[i*2];
                                                                                        Rdd.b[i+4]=Rss.b[i*2];
                                                                                    };
                          Rdd=vtrunewh(Rss,Rtt)                                     Rdd.h[0]=Rtt.h[0];
                                                                                    Rdd.h[1]=Rtt.h[2];
                                                                                    Rdd.h[2]=Rss.h[0];
                                                                                    Rdd.h[3]=Rss.h[2];
                          Rdd=vtrunohb(Rss,Rtt)                                     for (i=0;i<4;i++) {
                                                                                        Rdd.b[i]=Rtt.b[i*2+1];
                                                                                        Rdd.b[i+4]=Rss.b[i*2+1];
                                                                                    };
                          Rdd=vtrunowh(Rss,Rtt)                                     Rdd.h[0]=Rtt.h[1];
                                                                                    Rdd.h[1]=Rtt.h[3];
                                                                                    Rdd.h[2]=Rss.h[1];
                                                                                    Rdd.h[3]=Rss.h[3];


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=vtrunehb(Rss)                                          Word32 Q6_R_vtrunehb_P(Word64 Rss)
                          Rd=vtrunohb(Rss)                                          Word32 Q6_R_vtrunohb_P(Word64 Rss)
                          Rdd=vtrunehb(Rss,Rtt)                                     Word64 Q6_P_vtrunehb_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vtrunewh(Rss,Rtt)                                     Word64 Q6_P_vtrunewh_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vtrunohb(Rss,Rtt)                                     Word64 Q6_P_vtrunohb_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Rdd=vtrunowh(Rss,Rtt)                                     Word64 Q6_P_vtrunowh_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                  MinOp            d5
1   0   0    0   1    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -    -    -   -   0    0   0   d   d   d    d   d Rd=vtrunohb(Rss)
1   0   0    0   1    0   0    0   1   0   0   s   s   s    s   s   P   P   -   -    -    -    -   -   0    1   0   d   d   d    d   d Rd=vtrunehb(Rss)
    ICLASS           RegType        Maj                s5           Parse                 t5           Min                  d5
1   1   0    0   0    0   0    1   1   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0    1   0   d   d   d    d   d Rdd=vtrunewh(Rss,Rtt)
1   1   0    0   0    0   0    1   1   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   0    1   1   d   d   d    d   d Rdd=vtrunehb(Rss,Rtt)
1   1   0    0   0    0   0    1   1   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0   0   d   d   d    d   d Rdd=vtrunowh(Rss,Rtt)
1   1   0    0   0    0   0    1   1   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1    0   1   d   d   d    d   d Rdd=vtrunohb(Rss,Rtt)




80-N2040-36 B                                                                   619

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                MajOp          Major Opcode
                MinOp          Minor Opcode
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type
                RegType        Register Type




80-N2040-36 B                                       620

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                              Instruction Set



Vector zero extend
                          vzxtbh zero-extends each byte of a single register source to halfwords, and places the
                          result in the destination register pair.

                          vzxthw zero-extends each halfword of a single register source to words, and places the
                          result in the destination register pair.


                                        Rdd=vzxtbh(Rs)                                                                                           Rs


                                   zero                       zero                       zero                        zero                        Rdd




                                     Rdd=vzxthw(Rs)                                                                                              Rs


                                          zero                                                zero                                               Rdd


                                                  Syntax                                                                        Behavior
                          Rdd=vzxtbh(Rs)                                                 for (i=0;i<4;i++) {
                                                                                             Rdd.h[i]=Rs.ub[i];
                                                                                         };
                          Rdd=vzxthw(Rs)                                                 for (i=0;i<2;i++) {
                                                                                             Rdd.w[i]=Rs.uh[i];
                                                                                         };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vzxtbh(Rs)                                                 Word64 Q6_P_vzxtbh_R(Word32 Rs)
                          Rdd=vzxthw(Rs)                                                 Word64 Q6_P_vzxthw_R(Word32 Rs)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                     8   7    6    5     4   3   2    1   0
    ICLASS           RegType        MajOp                 s5             Parse                                  MinOp               d5
1   0   0    0   0    1   0    0    0     0   -   s   s   s    s     s   P   P   -   -    -     -   -   -   0    1      -   d   d   d    d   d Rdd=vzxtbh(Rs)
1   0   0    0   0    1   0    0    0     0   -   s   s   s    s     s   P   P   -   -    -     -   -   -   1    1      -   d   d   d    d   d Rdd=vzxthw(Rs)




80-N2040-36 B                                                                        621

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       622

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



    11.10.7 XTYPE/PRED
                          The XTYPE/PRED instruction subclass includes instructions which perform
                          miscellaneous operations on predicates, including mask generation, predicate transfers,
                          and the Viterbi pack operation.

Bounds check
                          Determine if Rs falls in the range defined by Rtt.

                          Rtt.w0 is set by the user to the lower bound, and Rtt.w1 is set by the user to the upper
                          bound.

                          All bits of the destination predicate are set if the value falls within the range, or all cleared
                          otherwise.

                                               Syntax                                                                Behavior
                       Pd=boundscheck(Rs,Rtt)                                     if ("Rs & 1") {
                                                                                      Assembler mapped to:
                                                                                  "Pd=boundscheck(Rss,Rtt):raw:hi";
                                                                                  } else {
                                                                                      Assembler mapped to:
                                                                                  "Pd=boundscheck(Rss,Rtt):raw:lo";
                                                                                  };
                       Pd=boundscheck(Rss,Rtt):raw:hi src = Rss.uw[1];
                                                      Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0]
                                                      < Rtt.uw[1]) ? 0xff : 0x00;
                       Pd=boundscheck(Rss,Rtt):raw:lo src = Rss.uw[0];
                                                      Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0]
                                                      < Rtt.uw[1]) ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Pd=boundscheck(Rs,Rtt)                                  Byte Q6_p_boundscheck_RP(Word32 Rs, Word64
                                                                                  Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3    2   1    0
    ICLASS           RegType                           s5           Parse              t5               MinOp                     d2
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 1   t    t   t    t   t   1    0   0   -    -   -   d    d   Pd=boundscheck(Rss,Rtt):raw:lo
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 1   t    t   t    t   t   1    0   1   -    -   -   d    d   Pd=boundscheck(Rss,Rtt):raw:hi




80-N2040-36 B                                                                 623

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                MinOp          Minor Opcode
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d2             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t




80-N2040-36 B                                       624

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Compare byte
                          These instructions sign- or zero-extend the low 8-bits of the source registers and perform
                          32-bit comparisons on the result. In the case of an extended 32-bit immediate operand, the
                          full 32 immediate bits are used for the comparison.

                                               Syntax                                                                  Behavior
                          Pd=cmpb.eq(Rs,#u8)                                        Pd=Rs.ub[0] == #u ? 0xff : 0x00;
                          Pd=cmpb.eq(Rs,Rt)                                         Pd=Rs.b[0] == Rt.b[0] ? 0xff : 0x00;
                          Pd=cmpb.gt(Rs,#s8)                                        Pd=Rs.b[0] > #s ? 0xff : 0x00;
                          Pd=cmpb.gt(Rs,Rt)                                         Pd=Rs.b[0] > Rt.b[0] ? 0xff : 0x00;
                          Pd=cmpb.gtu(Rs,#u7)                                       apply_extension(#u);
                                                                                    Pd=Rs.ub[0] > #u.uw[0] ? 0xff : 0x00;
                          Pd=cmpb.gtu(Rs,Rt)                                        Pd=Rs.ub[0] > Rt.ub[0] ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Pd=cmpb.eq(Rs,#u8)                                        Byte Q6_p_cmpb_eq_RI(Word32 Rs, Word32 Iu8)
                          Pd=cmpb.eq(Rs,Rt)                                         Byte Q6_p_cmpb_eq_RR(Word32 Rs, Word32 Rt)
                          Pd=cmpb.gt(Rs,#s8)                                        Byte Q6_p_cmpb_gt_RI(Word32 Rs, Word32 Is8)
                          Pd=cmpb.gt(Rs,Rt)                                         Byte Q6_p_cmpb_gt_RR(Word32 Rs, Word32 Rt)
                          Pd=cmpb.gtu(Rs,#u7)                                       Byte Q6_p_cmpb_gtu_RI(Word32 Rs, Word32
                                                                                    Iu7)
                          Pd=cmpb.gtu(Rs,Rt)                                        Byte Q6_p_cmpb_gtu_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1    0
    ICLASS           RegType       Maj                 s5           Parse                 t5           Min                          d2
1   1   0    0   0    1   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   0   1   0   -    -   -   d    d Pd=cmpb.gt(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   1   1   0   -    -   -   d    d Pd=cmpb.eq(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   1   1   1   -    -   -   d    d Pd=cmpb.gtu(Rs,Rt)
    ICLASS           RegType                           s5           Parse                                                           d2
1   1   0    1   1    1   0    1   -   0   0   s   s   s    s   s   P   P   -   i     i   i    i   i   i   i   i   0   0    -   d    d Pd=cmpb.eq(Rs,#u8)
1   1   0    1   1    1   0    1   -   0   1   s   s   s    s   s   P   P   -   i     i   i    i   i   i   i   i   0   0    -   d    d Pd=cmpb.gt(Rs,#s8)
1   1   0    1   1    1   0    1   -   1   0   s   s   s    s   s   P   P   -   0     i   i    i   i   i   i   i   0   0    -   d    d Pd=cmpb.gtu(Rs,#u7)




                            Field name                                                             Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          ICLASS                   Instruction Class




80-N2040-36 B                                                                   625

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                                Description
                Parse          Packet/Loop parse bits
                d2             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       626

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Compare half
                          These instructions sign- or zero-extend the low 16-bits of the source registers and perform
                          32-bit comparisons on the result. In the case of an extended 32-bit immediate operand, the
                          full 32 immediate bits are used for the comparison.

                                               Syntax                                                                  Behavior
                          Pd=cmph.eq(Rs,#s8)                                        apply_extension(#s);
                                                                                    Pd=Rs.h[0] == #s ? 0xff : 0x00;
                          Pd=cmph.eq(Rs,Rt)                                         Pd=Rs.h[0] == Rt.h[0] ? 0xff : 0x00;
                          Pd=cmph.gt(Rs,#s8)                                        apply_extension(#s);
                                                                                    Pd=Rs.h[0] > #s ? 0xff : 0x00;
                          Pd=cmph.gt(Rs,Rt)                                         Pd=Rs.h[0] > Rt.h[0] ? 0xff : 0x00;
                          Pd=cmph.gtu(Rs,#u7)                                       apply_extension(#u);
                                                                                    Pd=Rs.uh[0] > #u.uw[0] ? 0xff : 0x00;
                          Pd=cmph.gtu(Rs,Rt)                                        Pd=Rs.uh[0] > Rt.uh[0] ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Pd=cmph.eq(Rs,#s8)                                        Byte Q6_p_cmph_eq_RI(Word32 Rs, Word32 Is8)
                          Pd=cmph.eq(Rs,Rt)                                         Byte Q6_p_cmph_eq_RR(Word32 Rs, Word32 Rt)
                          Pd=cmph.gt(Rs,#s8)                                        Byte Q6_p_cmph_gt_RI(Word32 Rs, Word32 Is8)
                          Pd=cmph.gt(Rs,Rt)                                         Byte Q6_p_cmph_gt_RR(Word32 Rs, Word32 Rt)
                          Pd=cmph.gtu(Rs,#u7)                                       Byte Q6_p_cmph_gtu_RI(Word32 Rs, Word32
                                                                                    Iu7)
                          Pd=cmph.gtu(Rs,Rt)                                        Byte Q6_p_cmph_gtu_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1    0
    ICLASS           RegType       Maj                 s5           Parse                 t5           Min                          d2
1   1   0    0   0    1   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   0   1   1   -    -   -   d    d Pd=cmph.eq(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   1   0   0   -    -   -   d    d Pd=cmph.gt(Rs,Rt)
1   1   0    0   0    1   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   1   0   1   -    -   -   d    d Pd=cmph.gtu(Rs,Rt)
    ICLASS           RegType                           s5           Parse                                                           d2
1   1   0    1   1    1   0    1   -   0   0   s   s   s    s   s   P   P   -   i     i   i    i   i   i   i   i   0   1    -   d    d Pd=cmph.eq(Rs,#s8)
1   1   0    1   1    1   0    1   -   0   1   s   s   s    s   s   P   P   -   i     i   i    i   i   i   i   i   0   1    -   d    d Pd=cmph.gt(Rs,#s8)
1   1   0    1   1    1   0    1   -   1   0   s   s   s    s   s   P   P   -   0     i   i    i   i   i   i   i   0   1    -   d    d Pd=cmph.gtu(Rs,#u7)




80-N2040-36 B                                                                   627

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                RegType        Register Type
                MajOp          Major Opcode
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d2             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       628

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Compare doublewords
                          Compare two 64-bit register pairs for unsigned greater than, greater than, or equal. The 8-
                          bit predicate register Pd is set to all 1's or all 0's depending on the result.

                                               Syntax                                                                  Behavior
                          Pd=cmp.eq(Rss,Rtt)                                        Pd=Rss==Rtt ? 0xff : 0x00;
                          Pd=cmp.gt(Rss,Rtt)                                        Pd=Rss>Rtt ? 0xff : 0x00;
                          Pd=cmp.gtu(Rss,Rtt)                                       Pd=Rss.u64>Rtt.u64 ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=cmp.eq(Rss,Rtt)                                        Byte Q6_p_cmp_eq_PP(Word64 Rss, Word64 Rtt)
                          Pd=cmp.gt(Rss,Rtt)                                        Byte Q6_p_cmp_gt_PP(Word64 Rss, Word64 Rtt)
                          Pd=cmp.gtu(Rss,Rtt)                                       Byte Q6_p_cmp_gtu_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3    2   1    0
    ICLASS           RegType                           s5           Parse                t5               MinOp                     d2
1   1   0    1   0    0   1    0   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    0   0   -    -   -   d    d Pd=cmp.eq(Rss,Rtt)
1   1   0    1   0    0   1    0   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0    1   0   -    -   -   d    d Pd=cmp.gt(Rss,Rtt)
1   1   0    1   0    0   1    0   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1    0   0   -    -   -   d    d Pd=cmp.gtu(Rss,Rtt)




                            Field name                                                            Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   629

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Compare bit mask
                          If all the bits in the mask in Rt or a short immediate are set (BITSSET) or clear
                          (BITSCLEAR) in Rs, set the Pd to true. Otherwise, set the bits in Pd to false.

                                               Syntax                                                                  Behavior
                          Pd=[!]bitsclr(Rs,#u6)                                     Pd=(Rs&#u)[!]=0 ? 0xff : 0x00;
                          Pd=[!]bitsclr(Rs,Rt)                                      Pd=(Rs&Rt)[!]=0 ? 0xff : 0x00;
                          Pd=[!]bitsset(Rs,Rt)                                      Pd=(Rs&Rt)[!]=Rt ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=!bitsclr(Rs,#u6)                                       Byte Q6_p_not_bitsclr_RI(Word32 Rs, Word32
                                                                                    Iu6)
                          Pd=!bitsclr(Rs,Rt)                                        Byte Q6_p_not_bitsclr_RR(Word32 Rs, Word32
                                                                                    Rt)
                          Pd=!bitsset(Rs,Rt)                                        Byte Q6_p_not_bitsset_RR(Word32 Rs, Word32
                                                                                    Rt)
                          Pd=bitsclr(Rs,#u6)                                        Byte Q6_p_bitsclr_RI(Word32 Rs, Word32 Iu6)
                          Pd=bitsclr(Rs,Rt)                                         Byte Q6_p_bitsclr_RR(Word32 Rs, Word32 Rt)
                          Pd=bitsset(Rs,Rt)                                         Byte Q6_p_bitsset_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1    0
    ICLASS           RegType       MajOp               s5           Parse                                                           d2
1   0   0    0   0    1   0    1   1   0   0   s   s   s    s   s   P   P   i   i     i   i    i   i   -   -   -   -    -   -   d    d Pd=bitsclr(Rs,#u6)
1   0   0    0   0    1   0    1   1   0   1   s   s   s    s   s   P   P   i   i     i   i    i   i   -   -   -   -    -   -   d    d Pd=!bitsclr(Rs,#u6)
    ICLASS           RegType        Maj                s5           Parse                 t5                                        d2
1   1   0    0   0    1   1    1   0   1   0   s   s   s    s   s   P   P   -   t    t    t    t   t   -   -   -   -    -   -   d    d Pd=bitsset(Rs,Rt)
1   1   0    0   0    1   1    1   0   1   1   s   s   s    s   s   P   P   -   t    t    t    t   t   -   -   -   -    -   -   d    d Pd=!bitsset(Rs,Rt)
1   1   0    0   0    1   1    1   1   0   0   s   s   s    s   s   P   P   -   t    t    t    t   t   -   -   -   -    -   -   d    d Pd=bitsclr(Rs,Rt)
1   1   0    0   0    1   1    1   1   0   1   s   s   s    s   s   P   P   -   t     t   t    t   t   -   -   -   -    -   -   d    d Pd=!bitsclr(Rs,Rt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          MajOp                    Major Opcode




80-N2040-36 B                                                                   630

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Maj            Major Opcode
                RegType        Register Type
                RegType        Register Type




80-N2040-36 B                                  631

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                    Instruction Set



Mask generate from predicate
                          For each of the low 8 bits in predicate register Pt, if the bit is set then set the corresponding
                          byte in 64-bit register pair Rdd to 0xff, otherwise, set the corresponding byte to 0x00.


                                                           7                                                        0

                                                           1       0       1       0       1       0       1        0            Pt




                               0xFF        0x00        0xFF            0x00            0xFF                0x00             0xFF          0x00         Rdd


                                               Syntax                                                                                Behavior
                          Rdd=mask(Pt)                                                     for (i = 0; i < 8; i++) {
                                                                                               Rdd.b[i]=(Pt.i?(0xff):(0x00));
                                                                                           };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=mask(Pt)                                                     Word64 Q6_P_mask_p(Byte Pt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                             8   7   6    5   4    3    2   1   0
    ICLASS           RegType                                           Parse                               t2                             d5
1   0   0    0   0    1   1    0   -   -   -   -   -   -       -   -   P       P   -   -       -   -   t        t   -   -    -   d    d    d   d   d Rdd=mask(Pt)




                            Field name                                                                          Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          t2                       Field to encode register t
                          RegType                  Register Type




80-N2040-36 B                                                                          632

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Check for TLB match
                          Determine if the TLB entry in Rss matches the ASID:PPN in Rt.

                                               Syntax                                                                Behavior
                          Pd=tlbmatch(Rss,Rt)                                     MASK = 0x07ffffff;
                                                                                  TLBLO = Rss.uw[0];
                                                                                  TLBHI = Rss.uw[1];
                                                                                  SIZE =
                                                                                  min(6,count_leading_ones(~reverse_bits(TLB
                                                                                  LO)));
                                                                                  MASK &= (0xffffffff << 2*SIZE);
                                                                                  Pd = TLBHI.31 && ((TLBHI & MASK) == (Rt &
                                                                                  MASK)) ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   The predicate generated by this instruction can not be used as a .new predicate,
                                       nor can it be automatically ANDed with another predicate.

                          Intrinsics


                          Pd=tlbmatch(Rss,Rt)                                     Byte Q6_p_tlbmatch_PR(Word64 Rss, Word32
                                                                                  Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3    2   1    0
    ICLASS           RegType                           s5           Parse              t5               MinOp                     d2
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 1   t    t   t    t   t   0    1   1   -    -   -   d    d Pd=tlbmatch(Rss,Rt)




                            Field name                                                          Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                 633

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



Predicate transfer
                          Pd=Rs transfers a predicate to the 8 least-significant bits of a general register and zeros the
                          other bits.

                          Rd=Ps transfers the 8 least-significant bits of a general register to a predicate.

                                               Syntax                                                                     Behavior
                          Pd=Rs                                                          Pd = Rs.ub[0];
                          Rd=Ps                                                          Rd = zxt8->32(Ps);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Pd=Rs                                                          Byte Q6_p_equals_R(Word32 Rs)
                          Rd=Ps                                                          Word32 Q6_R_equals_p(Byte Ps)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                   8   7   6   5   4   3    2    1    0
    ICLASS           RegType       MajOp               s5                Parse                                                          d2
1   0   0    0   0    1   0    1   0   1   0   s   s   s    s        s   P   P   -   -    -   -   -   -   -   -   -   -    -   -    d    d Pd=Rs
    ICLASS           RegType       MajOp                        s2       Parse                                                 d5
1   0   0    0   1    0   0    1   -   1   -   -   -   -    s        s   P   P   -   -    -   -   -   -   -   -   -   d   d    d    d    d Rd=Ps




                            Field name                                                                Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          d5                       Field to encode register d
                          s2                       Field to encode register s
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                        634

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Test bit
                          Extract a bit from a register. If the bit is true (1), set all the bits of the predicate register
                          destination to 1. If the bit is false (0), set all the bits of the predicate register destination to
                          0. The bit to be tested can be indicated using an immediate or register value.

                          If a register is used to indicate the bit to test, and the value specified is out of range, the
                          predicate result is zero.

                                               Syntax                                                                  Behavior
                          Pd=[!]tstbit(Rs,#u5)                                      Pd = (Rs & (1<<#u)) == 0 ? 0xff : 0x00;
                          Pd=[!]tstbit(Rs,Rt)                                       Pd = (zxt32->64(Rs) & (sxt7->32(Rt)>0)?(zxt32-
                                                                                    >64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7-
                                                                                    >32(Rt))) == 0 ? 0xff : 0x00;


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=!tstbit(Rs,#u5)                                        Byte Q6_p_not_tstbit_RI(Word32 Rs, Word32
                                                                                    Iu5)
                          Pd=!tstbit(Rs,Rt)                                         Byte Q6_p_not_tstbit_RR(Word32 Rs, Word32
                                                                                    Rt)
                          Pd=tstbit(Rs,#u5)                                         Byte Q6_p_tstbit_RI(Word32 Rs, Word32 Iu5)
                          Pd=tstbit(Rs,Rt)                                          Byte Q6_p_tstbit_RR(Word32 Rs, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3    2   1    0
    ICLASS           RegType       MajOp               s5           Parse                                                           d2
1   0   0    0   0    1   0    1   0   0   0   s   s   s    s   s   P   P 0     i     i   i    i   i   -   -   -   -    -   -   d    d Pd=tstbit(Rs,#u5)
1   0   0    0   0    1   0    1   0   0   1   s   s   s    s   s   P   P 0     i     i   i    i   i   -   -   -   -    -   -   d    d Pd=!tstbit(Rs,#u5)
    ICLASS           RegType        Maj                s5           Parse                 t5                                        d2
1   1   0    0   0    1   1    1   0   0   0   s   s   s    s   s   P   P   -   t    t    t    t   t   -   -   -   -    -   -   d    d Pd=tstbit(Rs,Rt)
1   1   0    0   0    1   1    1   0   0   1   s   s   s    s   s   P   P   -   t    t    t    t   t   -   -   -   -    -   -   d    d Pd=!tstbit(Rs,Rt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          MajOp                    Major Opcode
                          Maj                      Major Opcode
                          RegType                  Register Type
                          RegType                  Register Type



80-N2040-36 B                                                                   635

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector compare halfwords
                Compare each of four 16-bit halfwords in two 64-bit vectors and set the corresponding bits
                in a predicate destination to '11' if true, '00' if false.

                Halfword comparisons can be for equal, signed greater than, or unsigned greater than.


                                                                                        Rss


                                                                                        Rtt




                          cmp                cmp               cmp          cmp




                                         1   1   0   0     1   1   0   0     Pd
                                         7                             0


                                Syntax                                     Behavior
                Pd=vcmph.eq(Rss,#s8)                      for (i = 0; i < 4; i++) {
                                                              Pd.i*2 = (Rss.h[i] == #s);
                                                              Pd.i*2+1 = (Rss.h[i] == #s);
                                                          };
                Pd=vcmph.eq(Rss,Rtt)                      for (i = 0; i < 4; i++) {
                                                              Pd.i*2 = (Rss.h[i] == Rtt.h[i]);
                                                              Pd.i*2+1 = (Rss.h[i] == Rtt.h[i]);
                                                          };
                Pd=vcmph.gt(Rss,#s8)                      for (i = 0; i < 4; i++) {
                                                              Pd.i*2 = (Rss.h[i] > #s);
                                                              Pd.i*2+1 = (Rss.h[i] > #s);
                                                          };
                Pd=vcmph.gt(Rss,Rtt)                      for (i = 0; i < 4; i++) {
                                                              Pd.i*2 = (Rss.h[i] > Rtt.h[i]);
                                                              Pd.i*2+1 = (Rss.h[i] > Rtt.h[i]);
                                                          };
                Pd=vcmph.gtu(Rss,#u7)                     for (i = 0; i < 4; i++) {
                                                              Pd.i*2 = (Rss.uh[i] > #u);
                                                              Pd.i*2+1 = (Rss.uh[i] > #u);
                                                          };
                Pd=vcmph.gtu(Rss,Rtt)                     for (i = 0; i < 4; i++) {
                                                              Pd.i*2 = (Rss.uh[i] > Rtt.uh[i]);
                                                              Pd.i*2+1 = (Rss.uh[i] > Rtt.uh[i]);
                                                          };




80-N2040-36 B                                            636

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=vcmph.eq(Rss,#s8)                                      Byte Q6_p_vcmph_eq_PI(Word64 Rss, Word32
                                                                                    Is8)
                          Pd=vcmph.eq(Rss,Rtt)                                      Byte Q6_p_vcmph_eq_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=vcmph.gt(Rss,#s8)                                      Byte Q6_p_vcmph_gt_PI(Word64 Rss, Word32
                                                                                    Is8)
                          Pd=vcmph.gt(Rss,Rtt)                                      Byte Q6_p_vcmph_gt_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=vcmph.gtu(Rss,#u7)                                     Byte Q6_p_vcmph_gtu_PI(Word64 Rss, Word32
                                                                                    Iu7)
                          Pd=vcmph.gtu(Rss,Rtt)                                     Byte Q6_p_vcmph_gtu_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6    5     4   3   2   1    0
    ICLASS           RegType                           s5           Parse                 t5               MinOp                       d2
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    1     -   -   -   d    d Pd=vcmph.eq(Rss,Rtt)
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   1    0    0     -   -   -   d    d Pd=vcmph.gt(Rss,Rtt)
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   1    0    1     -   -   -   d    d Pd=vcmph.gtu(Rss,Rtt)
    ICLASS           RegType                           s5           Parse                                                              d2
1   1   0    1   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   i     i   i    i   i   i     i     i   0   1   -   d    d Pd=vcmph.eq(Rss,#s8)
1   1   0    1   1    1   0    0   0   0   1   s   s   s    s   s   P   P   -   i     i   i    i   i   i     i     i   0   1   -   d    d Pd=vcmph.gt(Rss,#s8)
1   1   0    1   1    1   0    0   0   1   0   s   s   s    s   s   P   P   -   0     i   i    i   i   i     i     i   0   1   -   d    d Pd=vcmph.gtu(Rss,#u7)




                            Field name                                                             Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   637

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



Vector compare bytes for any match
                          Compare each byte in two 64-bit source vectors and set a predicate if any of the 8 bytes are
                          equal.

                          This instruction can be used to quickly find the null terminator in a string.

                                               Syntax                                                                Behavior
                          Pd=any8(vcmpb.eq(Rss,Rtt))                              Pd = 0;
                                                                                  for (i = 0; i < 8; i++) {
                                                                                      if (Rss.b[i] == Rtt.b[i]) Pd = 0xff;
                                                                                  };


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=any8(vcmpb.eq(Rss,Rtt))                              Byte Q6_p_any8_vcmpb_eq_PP(Word64 Rss,
                                                                                  Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3    2   1    0
    ICLASS           RegType                           s5           Parse              t5               MinOp                     d2
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 1   t    t   t    t   t   0    0   0   -    -   -   d    d Pd=any8(vcmpb.eq(Rss,Rtt))




                            Field name                                                          Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                 638

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                     Instruction Set



Vector compare bytes
                Compare each of eight bytes in two 64-bit vectors and set the corresponding bit in a
                predicate destination to 1 if true, 0 if false.

                Byte comparisons can be for equal or for unsigned greater than.

                In the following example, every other comparison is true.


                                                                                        Rss


                                                                                        Rtt


                    cmp     cmp     cmp     cmp      cmp      cmp     cmp      cmp




                                   1   0    1   0   1     0   1   0     Pd
                                   7                              0


                              Syntax                                         Behavior
                Pd=vcmpb.eq(Rss,#u8)                 for (i = 0; i < 8; i++) {
                                                         Pd.i = (Rss.ub[i] == #u);
                                                     };
                Pd=vcmpb.eq(Rss,Rtt)                 for (i = 0; i < 8; i++) {
                                                         Pd.i = (Rss.b[i] == Rtt.b[i]);
                                                     };
                Pd=vcmpb.gt(Rss,#s8)                 for (i = 0; i < 8; i++) {
                                                         Pd.i = (Rss.b[i] > #s);
                                                     };
                Pd=vcmpb.gt(Rss,Rtt)                 for (i = 0; i < 8; i++) {
                                                         Pd.i = (Rss.b[i] > Rtt.b[i]);
                                                     };
                Pd=vcmpb.gtu(Rss,#u7)                for (i = 0; i < 8; i++) {
                                                         Pd.i = (Rss.ub[i] > #u);
                                                     };
                Pd=vcmpb.gtu(Rss,Rtt)                for (i = 0; i < 8; i++) {
                                                         Pd.i = (Rss.ub[i] > Rtt.ub[i]);
                                                     };




80-N2040-36 B                                       639

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=vcmpb.eq(Rss,#u8)                                      Byte Q6_p_vcmpb_eq_PI(Word64 Rss, Word32
                                                                                    Iu8)
                          Pd=vcmpb.eq(Rss,Rtt)                                      Byte Q6_p_vcmpb_eq_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=vcmpb.gt(Rss,#s8)                                      Byte Q6_p_vcmpb_gt_PI(Word64 Rss, Word32
                                                                                    Is8)
                          Pd=vcmpb.gt(Rss,Rtt)                                      Byte Q6_p_vcmpb_gt_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=vcmpb.gtu(Rss,#u7)                                     Byte Q6_p_vcmpb_gtu_PI(Word64 Rss, Word32
                                                                                    Iu7)
                          Pd=vcmpb.gtu(Rss,Rtt)                                     Byte Q6_p_vcmpb_gtu_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6    5     4   3   2   1    0
    ICLASS           RegType                           s5           Parse                 t5               MinOp                       d2
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   1    1    0     -   -   -   d    d Pd=vcmpb.eq(Rss,Rtt)
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   1    1    1     -   -   -   d    d Pd=vcmpb.gtu(Rss,Rtt)
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 1     t    t    t    t   t   0    1    0     -   -   -   d    d Pd=vcmpb.gt(Rss,Rtt)
    ICLASS           RegType                           s5           Parse                                                              d2
1   1   0    1   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   i     i   i    i   i   i     i     i   0   0   -   d    d Pd=vcmpb.eq(Rss,#u8)
1   1   0    1   1    1   0    0   0   0   1   s   s   s    s   s   P   P   -   i     i   i    i   i   i     i     i   0   0   -   d    d Pd=vcmpb.gt(Rss,#s8)
1   1   0    1   1    1   0    0   0   1   0   s   s   s    s   s   P   P   -   0     i   i    i   i   i     i     i   0   0   -   d    d Pd=vcmpb.gtu(Rss,#u7)




                            Field name                                                             Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   640

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Vector compare words
                Compare each of two 32-bit words in two 64-bit vectors and set the corresponding bits in a
                predicate destination to '1111' if true, '0000' if false.

                Word comparisons can be for equal, signed greater than, or unsigned greater than.


                                                                                         Rss


                                                                                         Rtt




                                          cmp                                cmp




                                                   1     1   1   1   0   0    0    0    Pd
                                                    7                              0


                              Syntax                                         Behavior
                Pd=vcmpw.eq(Rss,#s8)                Pd[3:0] = (Rss.w[0]==#s);
                                                    Pd[7:4] = (Rss.w[1]==#s);
                Pd=vcmpw.eq(Rss,Rtt)                Pd[3:0] = (Rss.w[0]==Rtt.w[0]);
                                                    Pd[7:4] = (Rss.w[1]==Rtt.w[1]);
                Pd=vcmpw.gt(Rss,#s8)                Pd[3:0] = (Rss.w[0]>#s);
                                                    Pd[7:4] = (Rss.w[1]>#s);
                Pd=vcmpw.gt(Rss,Rtt)                Pd[3:0] = (Rss.w[0]>Rtt.w[0]);
                                                    Pd[7:4] = (Rss.w[1]>Rtt.w[1]);
                Pd=vcmpw.gtu(Rss,#u7)               Pd[3:0] = (Rss.uw[0]>#u);
                                                    Pd[7:4] = (Rss.uw[1]>#u);
                Pd=vcmpw.gtu(Rss,Rtt)               Pd[3:0] = (Rss.uw[0]>Rtt.uw[0]);
                                                    Pd[7:4] = (Rss.uw[1]>Rtt.uw[1]);




80-N2040-36 B                                      641

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                          Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Pd=vcmpw.eq(Rss,#s8)                                      Byte Q6_p_vcmpw_eq_PI(Word64 Rss, Word32
                                                                                    Is8)
                          Pd=vcmpw.eq(Rss,Rtt)                                      Byte Q6_p_vcmpw_eq_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=vcmpw.gt(Rss,#s8)                                      Byte Q6_p_vcmpw_gt_PI(Word64 Rss, Word32
                                                                                    Is8)
                          Pd=vcmpw.gt(Rss,Rtt)                                      Byte Q6_p_vcmpw_gt_PP(Word64 Rss, Word64
                                                                                    Rtt)
                          Pd=vcmpw.gtu(Rss,#u7)                                     Byte Q6_p_vcmpw_gtu_PI(Word64 Rss, Word32
                                                                                    Iu7)
                          Pd=vcmpw.gtu(Rss,Rtt)                                     Byte Q6_p_vcmpw_gtu_PP(Word64 Rss, Word64
                                                                                    Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7    6    5     4   3   2   1    0
    ICLASS           RegType                           s5           Parse                 t5               MinOp                       d2
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    0     -   -   -   d    d Pd=vcmpw.eq(Rss,Rtt)
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   0    0    1     -   -   -   d    d Pd=vcmpw.gt(Rss,Rtt)
1   1   0    1   0    0   1    0   0   -   -   s   s   s    s   s   P   P 0     t    t    t    t   t   0    1    0     -   -   -   d    d Pd=vcmpw.gtu(Rss,Rtt)
    ICLASS           RegType                           s5           Parse                                                              d2
1   1   0    1   1    1   0    0   0   0   0   s   s   s    s   s   P   P   -   i     i   i    i   i   i     i     i   1   0   -   d    d Pd=vcmpw.eq(Rss,#s8)
1   1   0    1   1    1   0    0   0   0   1   s   s   s    s   s   P   P   -   i     i   i    i   i   i     i     i   1   0   -   d    d Pd=vcmpw.gt(Rss,#s8)
1   1   0    1   1    1   0    0   0   1   0   s   s   s    s   s   P   P   -   0     i   i    i   i   i     i     i   1   0   -   d    d Pd=vcmpw.gtu(Rss,#u7)




                            Field name                                                             Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d2                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t




80-N2040-36 B                                                                   642

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                             Instruction Set



Viterbi pack even and odd predicate bits
                          Pack the even and odd bits of two predicate registers into a single destination register. A
                          variant of this instruction is the R3:2 |= vitpack(P1,P0). This places the packed predicate
                          bits into the lower 8bits of the register pair which has been preshifted by 8bits.

                          This instruction is useful in Viterbi decoding. Repeated use of the push version enables a
                          history to be stored for traceback, purposes.


                                                                                         7                                                 0
                                                                                                                                               Ps


                                                                                                                                               Pt




                                                       0                                                                                        Rd
                              31                                                    8 7                                                    0


                                               Syntax                                                                         Behavior
                          Rd=vitpack(Ps,Pt)                                             Rd = (Ps&0x55) | (Pt&0xAA);


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=vitpack(Ps,Pt)                                             Word32 Q6_R_vitpack_pp(Byte Ps, Byte Pt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                       8   7   6   5   4   3   2    1   0
    ICLASS           RegType       MajOp                       s2       Parse                        t2                           d5
1   0   0    0   1    0   0    1   -   0   0   -   -   -   s        s   P   P   -   -    -   -   t        t   -   -   -   d   d   d    d   d Rd=vitpack(Ps,Pt)




                            Field name                                                                    Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s2                       Field to encode register s
                          t2                       Field to encode register t
                          MajOp                    Major Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                       643

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                        Instruction Set



Vector mux
                          Perform an element-wise byte selection between two vectors.

                          For each of the low 8 bits of predicate register Pu, if the bit is set, then the corresponding
                          byte in Rdd is set to the corresponding byte from Rss. Otherwise, set the byte in Rdd to the
                          byte from Rtt.


                                                                                                                                           Rss


                                                                                                                                           Rtt


                                  mux     mux     mux                   mux           mux     mux     mux     mux
                              P[7]    P[6]    P[5]                  P[4]          P[3]    P[2]    P[1]    P[0]


                                                                                                                                          Rdd


                                               Syntax                                                                    Behavior
                          Rdd=vmux(Pu,Rss,Rtt)                                         for (i = 0; i < 8; i++) {
                                                                                           Rdd.b[i]=(Pu.i?(Rss.b[i]):(Rtt.b[i]));
                                                                                       };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vmux(Pu,Rss,Rtt)                                         Word64 Q6_P_vmux_pPP(Byte Pu, Word64 Rss,
                                                                                       Word64 Rtt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7   6   5   4   3   2    1   0
    ICLASS           RegType                           s5           Parse                   t5               u2              d5
1   1   0    1   0    0   0    1   -   -   -   s   s   s    s   s    P   P    -    t    t   t    t   t   -   u   u   d   d   d    d   d Rdd=vmux(Pu,Rss,Rtt)




                            Field name                                                               Description
                          RegType                  Register Type
                          MinOp                    Minor Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          u2                       Field to encode register u




80-N2040-36 B                                                                     644

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                        Instruction Set



   11.10.8 XTYPE/SHIFT
                The XTYPE/SHIFT instruction subclass includes instructions which perform shifts.

Shift by immediate
                Shift the source register value right or left based on the type of instruction. In these
                instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
                shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.

                Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
                logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
                vacated bits.


                                ASR                                              LSR

                                           Lost       Rs                                  Lost       Rs



                   Sign-ext                           Rd           Zero-fill                         Rd

                                ASL

                      Lost                           Rs


                                         Zero-fill   Rd


                               Syntax                                          Behavior
                Rd=asl(Rs,#u5)                        Rd = Rs << #u;
                Rd=asr(Rs,#u5)                        Rd = Rs >> #u;
                Rd=lsr(Rs,#u5)                        Rd = Rs >>> #u;
                Rd=rol(Rs,#u5)                        Rd = Rs <<R #u;
                Rdd=asl(Rss,#u6)                      Rdd = Rss << #u;
                Rdd=asr(Rss,#u6)                      Rdd = Rss >> #u;
                Rdd=lsr(Rss,#u6)                      Rdd = Rss >>> #u;
                Rdd=rol(Rss,#u6)                      Rdd = Rss <<R #u;




80-N2040-36 B                                        645

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rd=asl(Rs,#u5)                                            Word32 Q6_R_asl_RI(Word32 Rs, Word32 Iu5)
                          Rd=asr(Rs,#u5)                                            Word32 Q6_R_asr_RI(Word32 Rs, Word32 Iu5)
                          Rd=lsr(Rs,#u5)                                            Word32 Q6_R_lsr_RI(Word32 Rs, Word32 Iu5)
                          Rd=rol(Rs,#u5)                                            Word32 Q6_R_rol_RI(Word32 Rs, Word32 Iu5)
                          Rdd=asl(Rss,#u6)                                          Word64 Q6_P_asl_PI(Word64 Rss, Word32 Iu6)
                          Rdd=asr(Rss,#u6)                                          Word64 Q6_P_asr_PI(Word64 Rss, Word32 Iu6)
                          Rdd=lsr(Rss,#u6)                                          Word64 Q6_P_lsr_PI(Word64 Rss, Word32 Iu6)
                          Rdd=rol(Rss,#u6)                                          Word64 Q6_P_rol_PI(Word64 Rss, Word32 Iu6)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0   0   d   d   d    d   d Rdd=asr(Rss,#u6)
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0   1   d   d   d    d   d Rdd=lsr(Rss,#u6)
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   0   d   d   d    d   d Rdd=asl(Rss,#u6)
1   0   0    0   0    0   0    0   0   0   0   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   1   d   d   d    d   d Rdd=rol(Rss,#u6)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0   0   d   d   d    d   d Rd=asr(Rs,#u5)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0   1   d   d   d    d   d Rd=lsr(Rs,#u5)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1   0   d   d   d    d   d Rd=asl(Rs,#u5)
1   0   0    0   1    1   0    0   0   0   0   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1   1   d   d   d    d   d Rd=rol(Rs,#u5)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   646

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                   Instruction Set



Shift by immediate and accumulate
                      Shift the source register value right or left based on the type of instruction. In these
                      instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
                      shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.

                      Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
                      logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
                      vacated bits.

                      After shifting, add or subtract the shifted value from the destination register or register
                      pair.


                Rss                             # / Rt                        Rs                             # / Rt
      64-bit Shift Value                   Shift Amt                   32-bit Shift Value               Shift Amt




                        64-bit Shift                                                32-bit Shift



                      64-bit Add/Sub                                               32-bit Add/Sub




                               64 bit result             Rxx                                32 bit result             Rx


                                       Syntax                                        Behavior
                      Rx=add(#u8,asl(Rx,#U5))                   Rx=apply_extension(#u)+(Rx<<#U);
                      Rx=add(#u8,lsr(Rx,#U5))                   Rx=apply_extension(#u)+(((unsigned
                                                                int)Rx)>>#U);
                      Rx=sub(#u8,asl(Rx,#U5))                   Rx=apply_extension(#u)-(Rx<<#U);
                      Rx=sub(#u8,lsr(Rx,#U5))                   Rx=apply_extension(#u)-(((unsigned
                                                                int)Rx)>>#U);
                      Rx[+-]=asl(Rs,#u5)                        Rx = Rx [+-] Rs << #u;
                      Rx[+-]=asr(Rs,#u5)                        Rx = Rx [+-] Rs >> #u;
                      Rx[+-]=lsr(Rs,#u5)                        Rx = Rx [+-] Rs >>> #u;
                      Rx[+-]=rol(Rs,#u5)                        Rx = Rx [+-] Rs <<R #u;
                      Rxx[+-]=asl(Rss,#u6)                      Rxx = Rxx [+-] Rss << #u;
                      Rxx[+-]=asr(Rss,#u6)                      Rxx = Rxx [+-] Rss >> #u;
                      Rxx[+-]=lsr(Rss,#u6)                      Rxx = Rxx [+-] Rss >>> #u;
                      Rxx[+-]=rol(Rss,#u6)                      Rxx = Rxx [+-] Rss <<R #u;




80-N2040-36 B                                                  647

                       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                Class: XTYPE (slots 2,3)

                Intrinsics


                Rx+=asl(Rs,#u5)                Word32 Q6_R_aslacc_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx+=asr(Rs,#u5)                Word32 Q6_R_asracc_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx+=lsr(Rs,#u5)                Word32 Q6_R_lsracc_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx+=rol(Rs,#u5)                Word32 Q6_R_rolacc_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx-=asl(Rs,#u5)                Word32 Q6_R_aslnac_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx-=asr(Rs,#u5)                Word32 Q6_R_asrnac_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx-=lsr(Rs,#u5)                Word32 Q6_R_lsrnac_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx-=rol(Rs,#u5)                Word32 Q6_R_rolnac_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx=add(#u8,asl(Rx,#U5))        Word32 Q6_R_add_asl_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx=add(#u8,lsr(Rx,#U5))        Word32 Q6_R_add_lsr_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx=sub(#u8,asl(Rx,#U5))        Word32 Q6_R_sub_asl_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx=sub(#u8,lsr(Rx,#U5))        Word32 Q6_R_sub_lsr_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rxx+=asl(Rss,#u6)              Word64 Q6_P_aslacc_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx+=asr(Rss,#u6)              Word64 Q6_P_asracc_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx+=lsr(Rss,#u6)              Word64 Q6_P_lsracc_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx+=rol(Rss,#u6)              Word64 Q6_P_rolacc_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx-=asl(Rss,#u6)              Word64 Q6_P_aslnac_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx-=asr(Rss,#u6)              Word64 Q6_P_asrnac_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx-=lsr(Rss,#u6)              Word64 Q6_P_lsrnac_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)
                Rxx-=rol(Rss,#u6)              Word64 Q6_P_rolnac_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)




80-N2040-36 B                                 648

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                           Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6    5     4   3    2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp                x5
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0    0     x   x     x   x   x Rxx-=asr(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0    1     x   x     x   x   x Rxx-=lsr(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1    0     x   x     x   x   x Rxx-=asl(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1    1     x   x     x   x   x Rxx-=rol(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    0    0     x   x     x   x   x Rxx+=asr(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    0    1     x   x     x   x   x Rxx+=lsr(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    1    0     x   x     x   x   x Rxx+=asl(Rss,#u6)
1   0   0    0   0    0   1    0   0   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    1    1     x   x     x   x   x Rxx+=rol(Rss,#u6)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0    0     x   x     x   x   x Rx-=asr(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0    1     x   x     x   x   x Rx-=lsr(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1    0     x   x     x   x   x Rx-=asl(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1    1     x   x     x   x   x Rx-=rol(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    0    0     x   x     x   x   x Rx+=asr(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    0    1     x   x     x   x   x Rx+=lsr(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    1    0     x   x     x   x   x Rx+=asl(Rs,#u5)
1   0   0    0   1    1   1    0   0   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    1    1     x   x     x   x   x Rx+=rol(Rs,#u5)
    ICLASS           RegType                           x5           Parse                                                     MajOp
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i     i     i   0   i    1    0   -   Rx=add(#u8,asl(Rx,#U5))
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i     i     i   0   i    1    1   -   Rx=sub(#u8,asl(Rx,#U5))
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i     i     i   1   i    1    0   -   Rx=add(#u8,lsr(Rx,#U5))
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i     i     i   1   i    1    1   -   Rx=sub(#u8,lsr(Rx,#U5))




                            Field name                                                            Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          x5                       Field to encode register x
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   649

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                   Instruction Set



Shift by immediate and add
                          Shift Rs left by 0-7 bits, add to Rt, and place the result in Rd.

                          This instruction is useful for calculating array pointers, where destruction of the base
                          pointer is undesirable.

                                               Syntax                                                               Behavior
                          Rd=addasl(Rt,Rs,#u3)                                    Rd = Rt + Rs << #u;


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rd=addasl(Rt,Rs,#u3)                                    Word32 Q6_R_addasl_RRI(Word32 Rt, Word32
                                                                                  Rs, Word32 Iu3)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse              t5           Min                 d5
1   1   0    0   0    1   0    0   0   0   0   s   s   s    s   s   P   P 0   t    t   t    t   t   i   i   i   d   d   d    d   d Rd=addasl(Rt,Rs,#u3)




                            Field name                                                          Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                 650

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                   Instruction Set



Shift by immediate and logical
                      Shift the source register value right or left based on the type of instruction. In these
                      instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
                      shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.

                      Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
                      logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
                      vacated bits.

                      After shifting, take the logical AND, OR, or XOR of the shifted amount and the
                      destination register or register pair, and place the result back in the destination register or
                      register pair.

                      Saturation is not available for these instructions.


                Rss                             # / Rt                        Rs                             # / Rt
      64-bit Shift Value                   Shift Amt                   32-bit Shift Value               Shift Amt




                        64-bit Shift                                                32-bit Shift



                      64-bit AND/OR                                                32-bit AND/OR




                               64 bit result             Rxx                                32 bit result             Rx


                                       Syntax                                        Behavior
                      Rx=and(#u8,asl(Rx,#U5))                   Rx=apply_extension(#u)&(Rx<<#U);
                      Rx=and(#u8,lsr(Rx,#U5))                   Rx=apply_extension(#u)&(((unsigned
                                                                int)Rx)>>#U);
                      Rx=or(#u8,asl(Rx,#U5))                    Rx=apply_extension(#u)|(Rx<<#U);
                      Rx=or(#u8,lsr(Rx,#U5))                    Rx=apply_extension(#u)|(((unsigned
                                                                int)Rx)>>#U);
                      Rx[&|]=asl(Rs,#u5)                        Rx = Rx [|&] Rs << #u;
                      Rx[&|]=asr(Rs,#u5)                        Rx = Rx [|&] Rs >> #u;
                      Rx[&|]=lsr(Rs,#u5)                        Rx = Rx [|&] Rs >>> #u;
                      Rx[&|]=rol(Rs,#u5)                        Rx = Rx [|&] Rs <<R #u;
                      Rx^=asl(Rs,#u5)                           Rx = Rx ^ Rs << #u;
                      Rx^=lsr(Rs,#u5)                           Rx = Rx ^ Rs >>> #u;
                      Rx^=rol(Rs,#u5)                           Rx = Rx ^ Rs <<R #u;




80-N2040-36 B                                                  651

                       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                             Syntax                                Behavior
                Rxx[&|]=asl(Rss,#u6)           Rxx = Rxx [|&] Rss << #u;
                Rxx[&|]=asr(Rss,#u6)           Rxx = Rxx [|&] Rss >> #u;
                Rxx[&|]=lsr(Rss,#u6)           Rxx = Rxx [|&] Rss >>> #u;
                Rxx[&|]=rol(Rss,#u6)           Rxx = Rxx [|&] Rss <<R #u;
                Rxx^=asl(Rss,#u6)              Rxx = Rxx ^ Rss << #u;
                Rxx^=lsr(Rss,#u6)              Rxx = Rxx ^ Rss >>> #u;
                Rxx^=rol(Rss,#u6)              Rxx = Rxx ^ Rss <<R #u;


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rx&=asl(Rs,#u5)                Word32 Q6_R_asland_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx&=asr(Rs,#u5)                Word32 Q6_R_asrand_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx&=lsr(Rs,#u5)                Word32 Q6_R_lsrand_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx&=rol(Rs,#u5)                Word32 Q6_R_roland_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx=and(#u8,asl(Rx,#U5))        Word32 Q6_R_and_asl_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx=and(#u8,lsr(Rx,#U5))        Word32 Q6_R_and_lsr_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx=or(#u8,asl(Rx,#U5))         Word32 Q6_R_or_asl_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx=or(#u8,lsr(Rx,#U5))         Word32 Q6_R_or_lsr_IRI(Word32 Iu8, Word32
                                               Rx, Word32 IU5)
                Rx^=asl(Rs,#u5)                Word32 Q6_R_aslxacc_RI(Word32 Rx, Word32
                                               Rs, Word32 Iu5)
                Rx^=lsr(Rs,#u5)                Word32 Q6_R_lsrxacc_RI(Word32 Rx, Word32
                                               Rs, Word32 Iu5)
                Rx^=rol(Rs,#u5)                Word32 Q6_R_rolxacc_RI(Word32 Rx, Word32
                                               Rs, Word32 Iu5)
                Rx|=asl(Rs,#u5)                Word32 Q6_R_aslor_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx|=asr(Rs,#u5)                Word32 Q6_R_asror_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx|=lsr(Rs,#u5)                Word32 Q6_R_lsror_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rx|=rol(Rs,#u5)                Word32 Q6_R_rolor_RI(Word32 Rx, Word32 Rs,
                                               Word32 Iu5)
                Rxx&=asl(Rss,#u6)              Word64 Q6_P_asland_PI(Word64 Rxx, Word64
                                               Rss, Word32 Iu6)




80-N2040-36 B                                 652

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Rxx&=asr(Rss,#u6)                                         Word64 Q6_P_asrand_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx&=lsr(Rss,#u6)                                         Word64 Q6_P_lsrand_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx&=rol(Rss,#u6)                                         Word64 Q6_P_roland_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx^=asl(Rss,#u6)                                         Word64 Q6_P_aslxacc_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx^=lsr(Rss,#u6)                                         Word64 Q6_P_lsrxacc_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx^=rol(Rss,#u6)                                         Word64 Q6_P_rolxacc_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx|=asl(Rss,#u6)                                         Word64 Q6_P_aslor_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx|=asr(Rss,#u6)                                         Word64 Q6_P_asror_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx|=lsr(Rss,#u6)                                         Word64 Q6_P_lsror_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)
                          Rxx|=rol(Rss,#u6)                                         Word64 Q6_P_rolor_PI(Word64 Rxx, Word64
                                                                                    Rss, Word32 Iu6)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            x5
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0   0   x   x   x    x   x Rxx&=asr(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0   1   x   x   x    x   x Rxx&=lsr(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   0   x   x   x    x   x Rxx&=asl(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   1   x   x   x    x   x Rxx&=rol(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    0   0   x   x   x    x   x Rxx|=asr(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    0   1   x   x   x    x   x Rxx|=lsr(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    1   0   x   x   x    x   x Rxx|=asl(Rss,#u6)
1   0   0    0   0    0   1    0   0   1   -   s   s   s    s   s   P   P   i   i     i   i   i   i   1    1   1   x   x   x    x   x Rxx|=rol(Rss,#u6)
1   0   0    0   0    0   1    0   1   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    0   1   x   x   x    x   x Rxx^=lsr(Rss,#u6)
1   0   0    0   0    0   1    0   1   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   0   x   x   x    x   x Rxx^=asl(Rss,#u6)
1   0   0    0   0    0   1    0   1   0   -   s   s   s    s   s   P   P   i   i     i   i   i   i   0    1   1   x   x   x    x   x Rxx^=rol(Rss,#u6)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0   0   x   x   x    x   x Rx&=asr(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0   1   x   x   x    x   x Rx&=lsr(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1   0   x   x   x    x   x Rx&=asl(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1   1   x   x   x    x   x Rx&=rol(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    0   0   x   x   x    x   x Rx|=asr(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    0   1   x   x   x    x   x Rx|=lsr(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    1   0   x   x   x    x   x Rx|=asl(Rs,#u5)
1   0   0    0   1    1   1    0   0   1   -   s   s   s    s   s   P   P 0     i     i   i   i   i   1    1   1   x   x   x    x   x Rx|=rol(Rs,#u5)
1   0   0    0   1    1   1    0   1   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0   1   x   x   x    x   x Rx^=lsr(Rs,#u5)
1   0   0    0   1    1   1    0   1   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1   0   x   x   x    x   x Rx^=asl(Rs,#u5)
1   0   0    0   1    1   1    0   1   0   -   s   s   s    s   s   P   P 0     i     i   i   i   i   0    1   1   x   x   x    x   x Rx^=rol(Rs,#u5)




80-N2040-36 B                                                                   653

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3    2   1   0
    ICLASS           RegType                           x5           Parse                                                 MajOp
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i   i   i   0   i    0   0   -   Rx=and(#u8,asl(Rx,#U5))
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i   i   i   0   i    0   1   -   Rx=or(#u8,asl(Rx,#U5))
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i   i   i   1   i    0   0   -   Rx=and(#u8,lsr(Rx,#U5))
1   1   0    1   1    1   1    0   i   i   i   x   x   x    x   x   P   P   i   I     I   I   I   I   i   i   i   1   i    0   1   -   Rx=or(#u8,lsr(Rx,#U5))




                            Field name                                                            Description
                          RegType                  Register Type
                          MajOp                    Major Opcode
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          x5                       Field to encode register x
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   654

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                       Instruction Set



Shift right by immediate with rounding
                Perform an arithmetic right shift by an immediate amount, and then round the result. This
                instruction works by first shifting right, then adding the value +1 to the result, and finally
                shifting right again by one bit. The right shifts always inserts the sign-bit in the vacated
                position.

                When using asrrnd, the assembler adjusts the immediate appropriately.


                                           Lost       Rs



                   Sign-ext



                              +1


                              32-bit Add




                                                     Rd


                               Syntax                                        Behavior
                Rd=asr(Rs,#u5):rnd                    Rd = ((Rs >> #u)+1) >> 1;
                Rd=asrrnd(Rs,#u5)                     if ("#u5==0") {
                                                          Assembler mapped to: "Rd=Rs";
                                                      } else {
                                                          Assembler mapped to: "Rd=asr(Rs,#u5-
                                                      1):rnd";
                                                      };
                Rdd=asr(Rss,#u6):rnd                  tmp = Rss >> #u;
                                                      rnd = tmp & 1;
                                                      Rdd = tmp >> 1 + rnd;
                Rdd=asrrnd(Rss,#u6)                   if ("#u6==0") {
                                                          Assembler mapped to: "Rdd=Rss";
                                                      } else {
                                                          Assembler mapped to: "Rdd=asr(Rss,#u6-
                                                      1):rnd";
                                                      };




80-N2040-36 B                                        655

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rd=asr(Rs,#u5):rnd                                        Word32 Q6_R_asr_RI_rnd(Word32 Rs, Word32
                                                                                    Iu5)
                          Rd=asrrnd(Rs,#u5)                                         Word32 Q6_R_asrrnd_RI(Word32 Rs, Word32
                                                                                    Iu5)
                          Rdd=asr(Rss,#u6):rnd                                      Word64 Q6_P_asr_PI_rnd(Word64 Rss, Word32
                                                                                    Iu6)
                          Rdd=asrrnd(Rss,#u6)                                       Word64 Q6_P_asrrnd_PI(Word64 Rss, Word32
                                                                                    Iu6)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                                 MinOp            d5
1   0   0    0   0    0   0    0   1   1   0   s   s   s    s   s   P   P   i   i     i   i   i   i   1    1   1   d   d   d    d   d Rdd=asr(Rss,#u6):rnd
1   0   0    0   1    1   0    0   0   1   0   s   s   s    s   s   P   P 0     i     i   i   i   i   0    0   0   d   d   d    d   d Rd=asr(Rs,#u5):rnd




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   656

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



Shift left by immediate with saturation
                          Perform a left shift of the 32-bit source register value by an immediate amount and
                          saturate.

                          Saturation works by first sign-extending the 32-bit Rs register to 64 bits. It is then left
                          shifted by the immediate amount. If this 64-bit value cannot fit in a signed 32-bit number
                          (the upper word is not the sign-extension of bit 31), then saturation is performed based on
                          the sign of the original value. Saturation clamps the 32-bit result to the range
                          0x8000_0000 to 0x7fff_ffff.

                                               Syntax                                                                Behavior
                          Rd=asl(Rs,#u5):sat                                      Rd = sat32(sxt32->64(Rs) << #u);


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®   If saturation occurs during execution of this instruction (a result is clamped to
                                       either maximum or minimum values), the OVF bit in the Status Register is set.
                                       OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=asl(Rs,#u5):sat                                      Word32 Q6_R_asl_RI_sat(Word32 Rs, Word32
                                                                                  Iu5)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                               MinOp            d5
1   0   0    0   1    1   0    0   0   1   0   s   s   s    s   s   P   P 0   i     i   i   i   i   0    1   0   d   d   d    d   d Rd=asl(Rs,#u5):sat




                            Field name                                                          Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                 657

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                           Instruction Set



Shift by register
                The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                opcode is reversed (see Figure).

                The source data to be shifted is always performed as a 64-bit shift. When the Rs source
                register is a 32-bit register, this register is first sign or zero-extended to 64-bits. Arithmetic
                shifts sign-extend the 32-bit source to 64-bits, while logical shifts zero extend.

                The 64-bit source value is then right or left shifted based on the shift amount and the type
                of instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
                positions. Logical right shifts place zeros in the vacated positions.


                       ASR w/ Positive Rt                                   LSR w/ Positive Rt
                       ASL w/ Negative Rt                                   LSL w/ Negative Rt

                                            Lost       Rs                                    Lost       Rs



                    Sign-ext                           Rd            Zero-fill                          Rd


                        ASL w/ Positive Rt
                        LSL w/ Positive Rt
                        ASR w/ Negative Rt
                        LSR w/ Negative Rt

                      Lost                            Rs


                                          Zero-fill   Rd


                                Syntax                                           Behavior
                Rd=asl(Rs,Rt)                           shamt=sxt7->32(Rt);
                                                        Rd = (shamt>0)?(sxt32-
                                                        >64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);

                Rd=asr(Rs,Rt)                           shamt=sxt7->32(Rt);
                                                        Rd = (shamt>0)?(sxt32-
                                                        >64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);

                Rd=lsl(#s6,Rt)                          shamt = sxt7->32(Rt);
                                                        Rd = (shamt>0)?(zxt32-
                                                        >64(#s)<<shamt):(zxt32->64(#s)>>>shamt);

                Rd=lsl(Rs,Rt)                           shamt=sxt7->32(Rt);
                                                        Rd = (shamt>0)?(zxt32-
                                                        >64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);




80-N2040-36 B                                         658

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                                               Syntax                                                                  Behavior
                          Rd=lsr(Rs,Rt)                                             shamt=sxt7->32(Rt);
                                                                                    Rd = (shamt>0)?(zxt32-
                                                                                    >64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);

                          Rdd=asl(Rss,Rt)                                           shamt=sxt7->32(Rt);
                                                                                    Rdd = (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                          Rdd=asr(Rss,Rt)                                           shamt=sxt7->32(Rt);
                                                                                    Rdd = (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                          Rdd=lsl(Rss,Rt)                                           shamt=sxt7->32(Rt);
                                                                                    Rdd = (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                          Rdd=lsr(Rss,Rt)                                           shamt=sxt7->32(Rt);
                                                                                    Rdd = (shamt>0)?(Rss>>>shamt):(Rss<<shamt);


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rd=asl(Rs,Rt)                                             Word32 Q6_R_asl_RR(Word32 Rs, Word32 Rt)
                          Rd=asr(Rs,Rt)                                             Word32 Q6_R_asr_RR(Word32 Rs, Word32 Rt)
                          Rd=lsl(#s6,Rt)                                            Word32 Q6_R_lsl_IR(Word32 Is6, Word32 Rt)
                          Rd=lsl(Rs,Rt)                                             Word32 Q6_R_lsl_RR(Word32 Rs, Word32 Rt)
                          Rd=lsr(Rs,Rt)                                             Word32 Q6_R_lsr_RR(Word32 Rs, Word32 Rt)
                          Rdd=asl(Rss,Rt)                                           Word64 Q6_P_asl_PR(Word64 Rss, Word32 Rt)
                          Rdd=asr(Rss,Rt)                                           Word64 Q6_P_asr_PR(Word64 Rss, Word32 Rt)
                          Rdd=lsl(Rss,Rt)                                           Word64 Q6_P_lsl_PR(Word64 Rss, Word32 Rt)
                          Rdd=lsr(Rss,Rt)                                           Word64 Q6_P_lsr_PR(Word64 Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse                 t5           Min                 d5
1   1   0    0   0    0   1    1   1   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0   0   -   d   d   d    d   d Rdd=asr(Rss,Rt)
1   1   0    0   0    0   1    1   1   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0   1   -   d   d   d    d   d Rdd=lsr(Rss,Rt)
1   1   0    0   0    0   1    1   1   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   1   0   -   d   d   d    d   d Rdd=asl(Rss,Rt)
1   1   0    0   0    0   1    1   1   0   -   s   s   s    s   s   P   P   -   t    t    t    t   t   1   1   -   d   d   d    d   d Rdd=lsl(Rss,Rt)
1   1   0    0   0    1   1    0   0   1   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0   0   -   d   d   d    d   d Rd=asr(Rs,Rt)
1   1   0    0   0    1   1    0   0   1   -   s   s   s    s   s   P   P   -   t    t    t    t   t   0   1   -   d   d   d    d   d Rd=lsr(Rs,Rt)
1   1   0    0   0    1   1    0   0   1   -   s   s   s    s   s   P   P   -   t    t    t    t   t   1   0   -   d   d   d    d   d Rd=asl(Rs,Rt)
1   1   0    0   0    1   1    0   0   1   -   s   s   s    s   s   P   P   -   t    t    t    t   t   1   1   -   d   d   d    d   d Rd=lsl(Rs,Rt)
    ICLASS           RegType       Maj                              Parse                 t5           Min                 d5
1   1   0    0   0    1   1    0   1   0   -   i   i   i    i   i   P   P   -   t     t   t    t   t   1   1   i   d   d   d    d   d Rd=lsl(#s6,Rt)




80-N2040-36 B                                                                   659

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       660

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                   Instruction Set



Shift by register and accumulate
                      The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                      If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                      opcode is reversed.

                      Shift the source register value right or left based on the shift amount and the type of
                      instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
                      positions. Logical right shifts place zeros in the vacated positions.

                      The shift operation is always performed as a 64-bit shift. When Rs is a 32-bit register, this
                      register is first sign- or zero-extended to 64-bits. Arithmetic shifts sign-extend the 32-bit
                      source to 64-bits, while logical shifts zero extend.

                      After shifting, add or subtract the 64-bit shifted amount from the destination register or
                      register pair.


                Rss                             # / Rt                        Rs                             # / Rt
      64-bit Shift Value                   Shift Amt                   32-bit Shift Value               Shift Amt




                        64-bit Shift                                                32-bit Shift



                      64-bit Add/Sub                                               32-bit Add/Sub




                               64 bit result             Rxx                                32 bit result             Rx


                                       Syntax                                        Behavior
                      Rx[+-]=asl(Rs,Rt)                         shamt=sxt7->32(Rt);
                                                                Rx = Rx [+-] (shamt>0)?(sxt32-
                                                                >64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);

                      Rx[+-]=asr(Rs,Rt)                         shamt=sxt7->32(Rt);
                                                                Rx = Rx [+-] (shamt>0)?(sxt32-
                                                                >64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);

                      Rx[+-]=lsl(Rs,Rt)                         shamt=sxt7->32(Rt);
                                                                Rx = Rx [+-] (shamt>0)?(zxt32-
                                                                >64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);




80-N2040-36 B                                                  661

                       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                             Syntax                                Behavior
                Rx[+-]=lsr(Rs,Rt)              shamt=sxt7->32(Rt);
                                               Rx = Rx [+-] (shamt>0)?(zxt32-
                                               >64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);

                Rxx[+-]=asl(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [+-]
                                               (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                Rxx[+-]=asr(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [+-]
                                               (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                Rxx[+-]=lsl(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [+-]
                                               (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                Rxx[+-]=lsr(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [+-]
                                               (shamt>0)?(Rss>>>shamt):(Rss<<shamt);


                Class: XTYPE (slots 2,3)

                Intrinsics

                Rx+=asl(Rs,Rt)                 Word32 Q6_R_aslacc_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx+=asr(Rs,Rt)                 Word32 Q6_R_asracc_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx+=lsl(Rs,Rt)                 Word32 Q6_R_lslacc_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx+=lsr(Rs,Rt)                 Word32 Q6_R_lsracc_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx-=asl(Rs,Rt)                 Word32 Q6_R_aslnac_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx-=asr(Rs,Rt)                 Word32 Q6_R_asrnac_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx-=lsl(Rs,Rt)                 Word32 Q6_R_lslnac_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx-=lsr(Rs,Rt)                 Word32 Q6_R_lsrnac_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rxx+=asl(Rss,Rt)               Word64 Q6_P_aslacc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx+=asr(Rss,Rt)               Word64 Q6_P_asracc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx+=lsl(Rss,Rt)               Word64 Q6_P_lslacc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)




80-N2040-36 B                                 662

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Rxx+=lsr(Rss,Rt)                                          Word64 Q6_P_lsracc_PR(Word64 Rxx, Word64
                                                                                    Rss, Word32 Rt)
                          Rxx-=asl(Rss,Rt)                                          Word64 Q6_P_aslnac_PR(Word64 Rxx, Word64
                                                                                    Rss, Word32 Rt)
                          Rxx-=asr(Rss,Rt)                                          Word64 Q6_P_asrnac_PR(Word64 Rxx, Word64
                                                                                    Rss, Word32 Rt)
                          Rxx-=lsl(Rss,Rt)                                          Word64 Q6_P_lslnac_PR(Word64 Rxx, Word64
                                                                                    Rss, Word32 Rt)
                          Rxx-=lsr(Rss,Rt)                                          Word64 Q6_P_lsrnac_PR(Word64 Rxx, Word64
                                                                                    Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                               8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse                t5           Min                 x5
1   1   0    0   1    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   x   x   x    x   x Rxx-=asr(Rss,Rt)
1   1   0    0   1    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   x   x   x    x   x Rxx-=lsr(Rss,Rt)
1   1   0    0   1    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   -   x   x   x    x   x Rxx-=asl(Rss,Rt)
1   1   0    0   1    0   1    1   1   0   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   -   x   x   x    x   x Rxx-=lsl(Rss,Rt)
1   1   0    0   1    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   x   x   x    x   x Rxx+=asr(Rss,Rt)
1   1   0    0   1    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   x   x   x    x   x Rxx+=lsr(Rss,Rt)
1   1   0    0   1    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   -   x   x   x    x   x Rxx+=asl(Rss,Rt)
1   1   0    0   1    0   1    1   1   1   0   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   -   x   x   x    x   x Rxx+=lsl(Rss,Rt)
1   1   0    0   1    1   0    0   1   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   x   x   x    x   x Rx-=asr(Rs,Rt)
1   1   0    0   1    1   0    0   1   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   x   x   x    x   x Rx-=lsr(Rs,Rt)
1   1   0    0   1    1   0    0   1   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   -   x   x   x    x   x Rx-=asl(Rs,Rt)
1   1   0    0   1    1   0    0   1   0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   -   x   x   x    x   x Rx-=lsl(Rs,Rt)
1   1   0    0   1    1   0    0   1   1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   x   x   x    x   x Rx+=asr(Rs,Rt)
1   1   0    0   1    1   0    0   1   1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   1   -   x   x   x    x   x Rx+=lsr(Rs,Rt)
1   1   0    0   1    1   0    0   1   1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   -   x   x   x    x   x Rx+=asl(Rs,Rt)
1   1   0    0   1    1   0    0   1   1   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   1   -   x   x   x    x   x Rx+=lsl(Rs,Rt)




                            Field name                                                            Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          x5                       Field to encode register x
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   663

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                   Instruction Set



Shift by register and logical
                      The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                      If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                      opcode is reversed.

                      Shift the source register value right or left based on the shift amount and the type of
                      instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
                      positions. Logical right shifts place zeros in the vacated positions.

                      The shift operation is always performed as a 64-bit shift. When the Rs source register is a
                      32-bit register, this register is first sign or zero-extended to 64-bits. Arithmetic shifts sign-
                      extend the 32-bit source to 64-bits, while logical shifts zero extend.

                      After shifting, take the logical AND or OR of the shifted amount and the destination
                      register or register pair, and place the result back in the destination register or register pair.

                      Saturation is not available for these instructions.


                Rss                            # / Rt                          Rs                            # / Rt
      64-bit Shift Value                   Shift Amt                   32-bit Shift Value               Shift Amt




                        64-bit Shift                                                 32-bit Shift



                      64-bit AND/OR                                                 32-bit AND/OR




                               64 bit result            Rxx                                 32 bit result             Rx




80-N2040-36 B                                                 664

                       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                             Syntax                                Behavior
                Rx[&|]=asl(Rs,Rt)              shamt=sxt7->32(Rt);
                                               Rx = Rx [|&] (shamt>0)?(sxt32-
                                               >64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);

                Rx[&|]=asr(Rs,Rt)              shamt=sxt7->32(Rt);
                                               Rx = Rx [|&] (shamt>0)?(sxt32-
                                               >64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);

                Rx[&|]=lsl(Rs,Rt)              shamt=sxt7->32(Rt);
                                               Rx = Rx [|&] (shamt>0)?(zxt32-
                                               >64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);

                Rx[&|]=lsr(Rs,Rt)              shamt=sxt7->32(Rt);
                                               Rx = Rx [|&] (shamt>0)?(zxt32-
                                               >64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);

                Rxx[&|]=asl(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [|&]
                                               (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                Rxx[&|]=asr(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [|&]
                                               (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                Rxx[&|]=lsl(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [|&]
                                               (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                Rxx[&|]=lsr(Rss,Rt)            shamt=sxt7->32(Rt);
                                               Rxx = Rxx [|&]
                                               (shamt>0)?(Rss>>>shamt):(Rss<<shamt);
                Rxx^=asl(Rss,Rt)               shamt=sxt7->32(Rt);
                                               Rxx = Rxx ^
                                               (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                Rxx^=asr(Rss,Rt)               shamt=sxt7->32(Rt);
                                               Rxx = Rxx ^
                                               (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                Rxx^=lsl(Rss,Rt)               shamt=sxt7->32(Rt);
                                               Rxx = Rxx ^
                                               (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                Rxx^=lsr(Rss,Rt)               shamt=sxt7->32(Rt);
                                               Rxx = Rxx ^
                                               (shamt>0)?(Rss>>>shamt):(Rss<<shamt);




80-N2040-36 B                                 665

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                Class: XTYPE (slots 2,3)

                Intrinsics


                Rx&=asl(Rs,Rt)                 Word32 Q6_R_asland_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx&=asr(Rs,Rt)                 Word32 Q6_R_asrand_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx&=lsl(Rs,Rt)                 Word32 Q6_R_lsland_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx&=lsr(Rs,Rt)                 Word32 Q6_R_lsrand_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx|=asl(Rs,Rt)                 Word32 Q6_R_aslor_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx|=asr(Rs,Rt)                 Word32 Q6_R_asror_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx|=lsl(Rs,Rt)                 Word32 Q6_R_lslor_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rx|=lsr(Rs,Rt)                 Word32 Q6_R_lsror_RR(Word32 Rx, Word32 Rs,
                                               Word32 Rt)
                Rxx&=asl(Rss,Rt)               Word64 Q6_P_asland_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx&=asr(Rss,Rt)               Word64 Q6_P_asrand_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx&=lsl(Rss,Rt)               Word64 Q6_P_lsland_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx&=lsr(Rss,Rt)               Word64 Q6_P_lsrand_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx^=asl(Rss,Rt)               Word64 Q6_P_aslxacc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx^=asr(Rss,Rt)               Word64 Q6_P_asrxacc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx^=lsl(Rss,Rt)               Word64 Q6_P_lslxacc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx^=lsr(Rss,Rt)               Word64 Q6_P_lsrxacc_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx|=asl(Rss,Rt)               Word64 Q6_P_aslor_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx|=asr(Rss,Rt)               Word64 Q6_P_asror_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx|=lsl(Rss,Rt)               Word64 Q6_P_lslor_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)
                Rxx|=lsr(Rss,Rt)               Word64 Q6_P_lsror_PR(Word64 Rxx, Word64
                                               Rss, Word32 Rt)




80-N2040-36 B                                 666

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                     Instruction Set



                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                              8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse               t5           Min                 x5
1   1   0    0   1    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   -   x   x   x    x   x Rxx|=asr(Rss,Rt)
1   1   0    0   1    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   -   x   x   x    x   x Rxx|=lsr(Rss,Rt)
1   1   0    0   1    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   -   x   x   x    x   x Rxx|=asl(Rss,Rt)
1   1   0    0   1    0   1    1   0   0   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   -   x   x   x    x   x Rxx|=lsl(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   -   x   x   x    x   x Rxx&=asr(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   -   x   x   x    x   x Rxx&=lsr(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   -   x   x   x    x   x Rxx&=asl(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   0   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   -   x   x   x    x   x Rxx&=lsl(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   -   x   x   x    x   x Rxx^=asr(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   -   x   x   x    x   x Rxx^=lsr(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   -   x   x   x    x   x Rxx^=asl(Rss,Rt)
1   1   0    0   1    0   1    1   0   1   1   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   -   x   x   x    x   x Rxx^=lsl(Rss,Rt)
1   1   0    0   1    1   0    0   0   0   -   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   -   x   x   x    x   x Rx|=asr(Rs,Rt)
1   1   0    0   1    1   0    0   0   0   -   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   -   x   x   x    x   x Rx|=lsr(Rs,Rt)
1   1   0    0   1    1   0    0   0   0   -   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   -   x   x   x    x   x Rx|=asl(Rs,Rt)
1   1   0    0   1    1   0    0   0   0   -   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   -   x   x   x    x   x Rx|=lsl(Rs,Rt)
1   1   0    0   1    1   0    0   0   1   -   s   s   s    s   s   P   P   -   t   t   t    t   t   0   0   -   x   x   x    x   x Rx&=asr(Rs,Rt)
1   1   0    0   1    1   0    0   0   1   -   s   s   s    s   s   P   P   -   t   t   t    t   t   0   1   -   x   x   x    x   x Rx&=lsr(Rs,Rt)
1   1   0    0   1    1   0    0   0   1   -   s   s   s    s   s   P   P   -   t   t   t    t   t   1   0   -   x   x   x    x   x Rx&=asl(Rs,Rt)
1   1   0    0   1    1   0    0   0   1   -   s   s   s    s   s   P   P   -   t   t   t    t   t   1   1   -   x   x   x    x   x Rx&=lsl(Rs,Rt)




                            Field name                                                           Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          x5                       Field to encode register x
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   667

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                       Instruction Set



Shift by register with saturation
                          The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                          If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                          opcode is reversed.

                          Saturation is available for 32-bit arithmetic left shifts. This can be either an ASL
                          instruction with positive Rt, or an ASR instruction with negative Rt. Saturation works by
                          first sign-extending the 32-bit Rs register to 64 bits. It is then shifted by the shift amount.
                          If this 64-bit value cannot fit in a signed 32-bit number (the upper word is not the sign-
                          extension of bit 31), then saturation is performed based on the sign of the original value.
                          Saturation clamps the 32-bit result to the range 0x80000000 to 0x7fffffff.

                                                 Syntax                                                                 Behavior
                          Rd=asl(Rs,Rt):sat                                           shamt=sxt7->32(Rt);
                                                                                      Rd = bidir_shiftl(Rs,shamt);
                          Rd=asr(Rs,Rt):sat                                           shamt=sxt7->32(Rt);
                                                                                      Rd = bidir_shiftr(Rs,shamt);


                          Class: XTYPE (slots 2,3)

                          Notes

                                   ï®     If saturation occurs during execution of this instruction (a result is clamped to
                                         either maximum or minimum values), then the OVF bit in the Status Register is
                                         set. OVF will remain set until explicitly cleared by a transfer to SR.

                          Intrinsics

                          Rd=asl(Rs,Rt):sat                                           Word32 Q6_R_asl_RR_sat(Word32 Rs, Word32
                                                                                      Rt)
                          Rd=asr(Rs,Rt):sat                                           Word32 Q6_R_asr_RR_sat(Word32 Rs, Word32
                                                                                      Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                 8   7   6   5   4   3   2    1   0
    ICLASS           RegType           Maj               s5           Parse                t5           Min                 d5
1   1   0    0   0    1   1    0   0     0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   0   0   -   d   d   d    d   d Rd=asr(Rs,Rt):sat
1   1   0    0   0    1   1    0   0     0   -   s   s   s    s   s   P   P   -   t    t   t    t   t   1   0   -   d   d   d    d   d Rd=asl(Rs,Rt):sat




                            Field name                                                              Description
                          ICLASS                     Instruction Class
                          Parse                      Packet/Loop parse bits
                          d5                         Field to encode register d
                          s5                         Field to encode register s
                          t5                         Field to encode register t



80-N2040-36 B                                                                     668

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set



                  Field name                            Description
                Maj            Major Opcode
                Min            Minor Opcode
                RegType        Register Type




80-N2040-36 B                                  669

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                      Instruction Set



Vector shift halfwords by immediate
                          Shift individual halfwords of the source vector. Arithmetic right shifts place the sign bit of
                          the source values in the vacated positions. Logical right shifts place zeros in the vacated
                          positions.


                                                           Rdd = vaslh(Rss,#)                                                    Shift Amount           Rt/#u4

                               lost                             lost                         lost                               lost                    Rss



                                                   0                               0                                0                               0
                                                                                                                                                           Rdd


                                               Syntax                                                                                  Behavior
                          Rdd=vaslh(Rss,#u4)                                               for (i=0;i<4;i++) {
                                                                                               Rdd.h[i]=(Rss.h[i]<<#u);
                                                                                           };
                          Rdd=vasrh(Rss,#u4)                                               for (i=0;i<4;i++) {
                                                                                               Rdd.h[i]=(Rss.h[i]>>#u);
                                                                                           };
                          Rdd=vlsrh(Rss,#u4)                                               for (i=0;i<4;i++) {
                                                                                               Rdd.h[i]=(Rss.uh[i]>>#u);
                                                                                           };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vaslh(Rss,#u4)                                               Word64 Q6_P_vaslh_PI(Word64 Rss, Word32
                                                                                           Iu4)
                          Rdd=vasrh(Rss,#u4)                                               Word64 Q6_P_vasrh_PI(Word64 Rss, Word32
                                                                                           Iu4)
                          Rdd=vlsrh(Rss,#u4)                                               Word64 Q6_P_vlsrh_PI(Word64 Rss, Word32
                                                                                           Iu4)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                         8   7       6   5     4    3   2    1   0
    ICLASS           RegType       MajOp                   s5              Parse                                    MinOp                  d5
1   0   0    0   0    0   0    0   1   0   0   s       s   s     s     s   P   P 0     0     i      i   i   i   0       0   0     d    d   d    d   d Rdd=vasrh(Rss,#u4)
1   0   0    0   0    0   0    0   1   0   0   s       s   s     s     s   P   P 0     0     i      i   i   i   0       0   1     d    d   d    d   d Rdd=vlsrh(Rss,#u4)
1   0   0    0   0    0   0    0   1   0   0   s       s   s     s     s   P   P 0     0     i      i   i   i   0       1   0     d    d   d    d   d Rdd=vaslh(Rss,#u4)




80-N2040-36 B                                                                          670

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       671

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                 Instruction Set



Vector arithmetic shift halfwords with round
                          For each halfword in the vector, round then arithmetic shift right by an immediate amount.
                          The results are stored in the destination register.


                                                           Rdd = vasrh(Rss,#u):rnd




                                       1<<(#u-1)                      1<<(#u-1)                  1<<(#u-1)                1<<(#u-1)


                                       +                              +                          +                     +
                                               lost                           lost                    lost                      lost




                              Sign-                       Sign-                      Sign-                    Sign-
                               ext                         ext                        ext                      ext


                                                 Syntax                                                                         Behavior
                          Rdd=vasrh(Rss,#u4):raw                                           for (i=0;i<4;i++) {
                                                                                               Rdd.h[i]=( ((Rss.h[i] >> #u)+1)>>1 );
                                                                                           };
                          Rdd=vasrh(Rss,#u4):rnd                                           if ("#u4==0") {
                                                                                               Assembler mapped to: "Rdd=Rss";
                                                                                           } else {
                                                                                               Assembler mapped to:
                                                                                           "Rdd=vasrh(Rss,#u4-1):raw";
                                                                                           };


                          Class: XTYPE (slots 2,3)

                          Intrinsics


                          Rdd=vasrh(Rss,#u4):rnd                                           Word64 Q6_P_vasrh_PI_rnd(Word64 Rss, Word32
                                                                                           Iu4)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                       8   7    6   5    4   3      2   1   0
    ICLASS           RegType       MajOp                   s5             Parse                                   MinOp             d5
1   0   0    0   0    0   0    0   0   0   1    s     s    s      s   s   P     P 0    0     i    i   i   i   0    0   0    d   d      d   d   d Rdd=vasrh(Rss,#u4):raw




80-N2040-36 B                                                                          672

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       673

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                      Instruction Set



Vector arithmetic shift halfwords with saturate and pack
                For each halfword in the vector, optionally round, then arithmetic shift right by an
                immediate amount. The results are saturated to unsigned [0-255] and then packed in the
                destination register.


                                        Rd = vasrhub(Rss,#u):rnd:sat




                          1<<(#u-1)           1<<(#u-1)           1<<(#u-1)     1<<(#u-1)


                         +                   +                    +             +
                                 lost                lost             lost          lost




                        Sat_u8              Sat_u8           Sat_u8           Sat_u8




                                   Syntax                                           Behavior
                Rd=vasrhub(Rss,#u4):raw                      for (i=0;i<4;i++) {
                                                                 Rd.b[i]=usat8(((Rss.h[i] >> #u
                                                             )+1)>>1);
                                                             };
                Rd=vasrhub(Rss,#u4):rnd:sat                  if ("#u4==0") {
                                                                 Assembler mapped to: "Rd=vsathub(Rss)";
                                                             } else {
                                                                 Assembler mapped to:
                                                             "Rd=vasrhub(Rss,#u4-1):raw";
                                                             };
                Rd=vasrhub(Rss,#u4):sat                      for (i=0;i<4;i++) {
                                                                 Rd.b[i]=usat8(Rss.h[i] >> #u);
                                                             };


                Class: XTYPE (slots 2,3)

                Notes

                    ï®    If saturation occurs during execution of this instruction (a result is clamped to
                         either maximum or minimum values), then the OVF bit in the Status Register is
                         set. OVF will remain set until explicitly cleared by a transfer to SR.




80-N2040-36 B                                               674

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                    Instruction Set



                          Intrinsics

                          Rd=vasrhub(Rss,#u4):rnd:sat                             Word32 Q6_R_vasrhub_PI_rnd_sat(Word64 Rss,
                                                                                  Word32 Iu4)
                          Rd=vasrhub(Rss,#u4):sat                                 Word32 Q6_R_vasrhub_PI_sat(Word64 Rss,
                                                                                  Word32 Iu4)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                             8   7    6   5   4   3   2    1   0
    ICLASS           RegType       MajOp               s5           Parse                               MinOp            d5
1   0   0    0   1    0   0    0   0   1   1   s   s   s    s   s   P   P 0   0     i   i   i   i   1    0   0   d   d   d    d   d Rd=vasrhub(Rss,#u4):raw
1   0   0    0   1    0   0    0   0   1   1   s   s   s    s   s   P   P 0   0     i   i   i   i   1    0   1   d   d   d    d   d Rd=vasrhub(Rss,#u4):sat




                            Field name                                                          Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          MajOp                    Major Opcode
                          MinOp                    Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                 675

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                  Instruction Set



Vector shift halfwords by register
                The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                If the shift amount is negative, the direction of the shift is reversed. Shift the source values
                right or left based on the shift amount and the type of instruction. Arithmetic right shifts
                place the sign bit of the source value in the vacated positions. Logical right shifts place
                zeros in the vacated positions.


                                      Rdd = vaslh(Rss,#)                        Shift Amount         Rt/#u4

                    lost                 lost                   lost           lost                  Rss



                                  0                   0                  0                       0
                                                                                                       Rdd


                                  Syntax                                              Behavior
                Rdd=vaslh(Rss,Rt)                          for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16-
                                                           >64 (Rss.h[i])<<sxt7->32(Rt)):(sxt16-
                                                           >64(Rss.h[i])>>sxt7->32(Rt));
                                                           };
                Rdd=vasrh(Rss,Rt)                          for (i=0;i<4;i++) {
                                                                Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16-
                                                           >64(Rss.h[i])>>sxt7->32(Rt)):(sxt16-
                                                           >64(Rss.h[i])<<sxt7->32(Rt));
                                                           };
                Rdd=vlslh(Rss,Rt)                          for (i=0;i<4;i++) {
                                                                Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16-
                                                           >64(Rss.uh[i])<<sxt7->32(Rt)):(zxt16-
                                                           >64(Rss.uh[i])>>>sxt7->32(Rt));
                                                           };
                Rdd=vlsrh(Rss,Rt)                          for (i=0;i<4;i++) {
                                                                Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16-
                                                           >64(Rss.uh[i])>>>sxt7->32(Rt)):(zxt16-
                                                           >64(Rss.uh[i])<<sxt7->32(Rt));
                                                           };


                Class: XTYPE (slots 2,3)

                Notes

                      ï®    If the number of bits to be shifted is greater than the width of the vector element,
                           the result is either all sign-bits (for arithmetic right shifts) or all zeros for logical
                           and left shifts.




80-N2040-36 B                                             676

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Intrinsics

                          Rdd=vaslh(Rss,Rt)                                         Word64 Q6_P_vaslh_PR(Word64 Rss, Word32 Rt)
                          Rdd=vasrh(Rss,Rt)                                         Word64 Q6_P_vasrh_PR(Word64 Rss, Word32 Rt)
                          Rdd=vlslh(Rss,Rt)                                         Word64 Q6_P_vlslh_PR(Word64 Rss, Word32 Rt)
                          Rdd=vlsrh(Rss,Rt)                                         Word64 Q6_P_vlsrh_PR(Word64 Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse                 t5           Min                 d5
1   1   0    0   0    0   1    1   0   1   -   s   s   s    s   s   P   P   -   t     t   t    t   t   0   0   -   d   d   d    d   d Rdd=vasrh(Rss,Rt)
1   1   0    0   0    0   1    1   0   1   -   s   s   s    s   s   P   P   -   t     t   t    t   t   0   1   -   d   d   d    d   d Rdd=vlsrh(Rss,Rt)
1   1   0    0   0    0   1    1   0   1   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1   0   -   d   d   d    d   d Rdd=vaslh(Rss,Rt)
1   1   0    0   0    0   1    1   0   1   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1   1   -   d   d   d    d   d Rdd=vlslh(Rss,Rt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   677

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                                 Instruction Set



Vector shift words by immediate
                          Shift individual words of the source vector. Arithmetic right shifts place the sign bit of the
                          source values in the vacated positions. Logical right shifts place zeros in the vacated
                          positions.


                                   Rdd = vaslw(Rss,{Rt/#})                                           Shift Amount                     Rt/#u5


                                   lost                                           lost                                                 Rss



                                                                    0                                                 0       0        Rdd


                                               Syntax                                                                         Behavior
                          Rdd=vaslw(Rss,#u5)                                          for (i=0;i<2;i++) {
                                                                                          Rdd.w[i]=(Rss.w[i]<<#u);
                                                                                      };
                          Rdd=vasrw(Rss,#u5)                                          for (i=0;i<2;i++) {
                                                                                          Rdd.w[i]=(Rss.w[i]>>#u);
                                                                                      };
                          Rdd=vlsrw(Rss,#u5)                                          for (i=0;i<2;i++) {
                                                                                          Rdd.w[i]=(Rss.uw[i]>>#u);
                                                                                      };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rdd=vaslw(Rss,#u5)                                          Word64 Q6_P_vaslw_PI(Word64 Rss, Word32
                                                                                      Iu5)
                          Rdd=vasrw(Rss,#u5)                                          Word64 Q6_P_vasrw_PI(Word64 Rss, Word32
                                                                                      Iu5)
                          Rdd=vlsrw(Rss,#u5)                                          Word64 Q6_P_vlsrw_PI(Word64 Rss, Word32
                                                                                      Iu5)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                  8   7    6   5       4       3   2    1   0
    ICLASS           RegType       MajOp               s5               Parse                                MinOp                    d5
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s       P   P 0   i      i   i   i   i   0    0   0       d       d   d    d   d Rdd=vasrw(Rss,#u5)
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s       P   P 0   i      i   i   i   i   0    0   1       d       d   d    d   d Rdd=vlsrw(Rss,#u5)
1   0   0    0   0    0   0    0   0   1   0   s   s   s    s   s       P   P 0   i      i   i   i   i   0    1   0       d       d   d    d   d Rdd=vaslw(Rss,#u5)




80-N2040-36 B                                                                     678

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                MajOp          Major Opcode
                MinOp          Minor Opcode
                RegType        Register Type




80-N2040-36 B                                       679

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                           Instruction Set



Vector shift words by register
                The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                If the shift amount is negative, the direction of the shift is reversed. Shift the source values
                right or left based on the shift amount and the type of instruction. Arithmetic right shifts
                place the sign bit of the source value in the vacated positions. Logical right shifts place
                zeros in the vacated positions.


                     Rdd = vaslw(Rss,{Rt/#})                       Shift Amount       Rt/#u5


                      lost                            lost                             Rss



                                            0                                0    0    Rdd


                                Syntax                                            Behavior
                Rdd=vaslw(Rss,Rt)                       for (i=0;i<2;i++) {
                                                             Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32-
                                                        >64(Rss.w[i])<<sxt7->32(Rt)):(sxt32-
                                                        >64(Rss.w[i])>>sxt7->32(Rt));
                                                        };
                Rdd=vasrw(Rss,Rt)                       for (i=0;i<2;i++) {
                                                             Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32-
                                                        >64(Rss.w[i])>>sxt7->32(Rt)):(sxt32-
                                                        >64(Rss.w[i])<<sxt7->32(Rt));
                                                        };
                Rdd=vlslw(Rss,Rt)                       for (i=0;i<2;i++) {
                                                             Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32-
                                                        >64(Rss.uw[i])<<sxt7->32(Rt)):(zxt32-
                                                        >64(Rss.uw[i])>>>sxt7->32(Rt));
                                                        };
                Rdd=vlsrw(Rss,Rt)                       for (i=0;i<2;i++) {
                                                             Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32-
                                                        >64(Rss.uw[i])>>>sxt7->32(Rt)):(zxt32-
                                                        >64(Rss.uw[i])<<sxt7->32(Rt));
                                                        };


                Class: XTYPE (slots 2,3)

                Notes

                     ï®   If the number of bits to be shifted is greater than the width of the vector element,
                         the result is either all sign-bits (for arithmetic right shifts) or all zeros for logical
                         and left shifts.




80-N2040-36 B                                         680

                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                      Instruction Set



                          Intrinsics

                          Rdd=vaslw(Rss,Rt)                                         Word64 Q6_P_vaslw_PR(Word64 Rss, Word32 Rt)
                          Rdd=vasrw(Rss,Rt)                                         Word64 Q6_P_vasrw_PR(Word64 Rss, Word32 Rt)
                          Rdd=vlslw(Rss,Rt)                                         Word64 Q6_P_vlslw_PR(Word64 Rss, Word32 Rt)
                          Rdd=vlsrw(Rss,Rt)                                         Word64 Q6_P_vlsrw_PR(Word64 Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                8   7   6   5   4   3   2    1   0
    ICLASS           RegType       Maj                 s5           Parse                 t5           Min                 d5
1   1   0    0   0    0   1    1   0   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   0   0   -   d   d   d    d   d Rdd=vasrw(Rss,Rt)
1   1   0    0   0    0   1    1   0   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   0   1   -   d   d   d    d   d Rdd=vlsrw(Rss,Rt)
1   1   0    0   0    0   1    1   0   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1   0   -   d   d   d    d   d Rdd=vaslw(Rss,Rt)
1   1   0    0   0    0   1    1   0   0   -   s   s   s    s   s   P   P   -   t     t   t    t   t   1   1   -   d   d   d    d   d Rdd=vlslw(Rss,Rt)




                            Field name                                                             Description
                          ICLASS                   Instruction Class
                          Parse                    Packet/Loop parse bits
                          d5                       Field to encode register d
                          s5                       Field to encode register s
                          t5                       Field to encode register t
                          Maj                      Major Opcode
                          Min                      Minor Opcode
                          RegType                  Register Type




80-N2040-36 B                                                                   681

                          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                                                                                             Instruction Set



Vector shift words with truncate and pack
                          Shift individual words of the source vector Rss right by a register or immediate amount.
                          The low 16-bits of each word are packed into destination register Rd.


                                         Rd = vasrw(Rss,{Rt/#})                                          Shift Amount              Rt/#u5


                                                                  lost                                                lost          Rss




                                   sxt                                                sxt




                                                                                 Low 16bits                              Low 16bits


                                                                                                                                   Rd


                                                 Syntax                                                                        Behavior
                          Rd=vasrw(Rss,#u5)                                               for (i=0;i<2;i++) {
                                                                                              Rd.h[i]=(Rss.w[i]>>#u).h[0];
                                                                                          };
                          Rd=vasrw(Rss,Rt)                                                for (i=0;i<2;i++) {
                                                                                                Rd.h[i]=(sxt7->32(Rt)>0)?(sxt32-
                                                                                          >64 (Rss.w[i])>>sxt 7->32(Rt)):(sxt32-
                                                                                          >64(Rss.w[i])<<sxt7->32(Rt)).h[0];
                                                                                          };


                          Class: XTYPE (slots 2,3)

                          Intrinsics

                          Rd=vasrw(Rss,#u5)                                               Word32 Q6_R_vasrw_PI(Word64 Rss, Word32
                                                                                          Iu5)
                          Rd=vasrw(Rss,Rt)                                                Word32 Q6_R_vasrw_PR(Word64 Rss, Word32 Rt)


                          Encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                      8   7    6   5    4   3   2    1   0
    ICLASS           RegType       MajOp                 s5              Parse                                   MinOp             d5
1   0   0    0   1    0   0    0   1     1   0   s   s   s    s    s     P   P 0      i     i   i    i   i   0    1   0    d   d   d    d   d Rd=vasrw(Rss,#u5)
    ICLASS           RegType                             s5              Parse                  t5           Min                   d5
1   1   0    0   0    1   0    1    -    -   -   s   s   s    s    s     P   P    -   t     t   t    t   t   0    1   0    d   d   d    d   d Rd=vasrw(Rss,Rt)




80-N2040-36 B                                                                         682

                           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Hexagon V62 Programmer's Reference Manual                                          Instruction Set




                  Field name                                Description
                ICLASS         Instruction Class
                Parse          Packet/Loop parse bits
                d5             Field to encode register d
                s5             Field to encode register s
                t5             Field to encode register t
                MajOp          Major Opcode
                MinOp          Minor Opcode
                Min            Minor Opcode
                RegType        Register Type
                RegType        Register Type




80-N2040-36 B                                       683

                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
Instruction Index


A                                                             asl
                                                                    Rd=asl(Rs,#u5) 645
                                                                    Rd=asl(Rs,#u5):sat 657
abs
                                                                    Rd=asl(Rs,Rt) 658
      Rd=abs(Rs)[:sat]    389                                       Rd=asl(Rs,Rt):sat 668
      Rdd=abs(Rss) 388
                                                                    Rdd=asl(Rss,#u6) 645
                                                                    Rdd=asl(Rss,Rt) 659
add                                                                 Rx^=asl(Rs,#u5) 651
      if ([!]Pu[.new]) Rd=add(Rs,#s8) 196                           Rx[&|]=asl(Rs,#u5) 651
      if ([!]Pu[.new]) Rd=add(Rs,Rt) 196                            Rx[&|]=asl(Rs,Rt) 665
      Rd=add(#u6,mpyi(Rs,#U6)) 539                                  Rx[+-]=asl(Rs,#u5) 647
      Rd=add(#u6,mpyi(Rs,Rt)) 539                                   Rx[+-]=asl(Rs,Rt) 661
      Rd=add(Rs,#s16) 171                                           Rx=add(#u8,asl(Rx,#U5)) 647
      Rd=add(Rs,add(Ru,#s6)) 390                                    Rx=and(#u8,asl(Rx,#U5)) 651
      Rd=add(Rs,Rt) 171                                             Rx=or(#u8,asl(Rx,#U5)) 651
      Rd=add(Rs,Rt):sat 171                                         Rx=sub(#u8,asl(Rx,#U5)) 647
      Rd=add(Rs,Rt):sat:deprecated 392                              Rxx^=asl(Rss,#u6) 652
      Rd=add(Rt.[HL],Rs.[HL])[:sat]:<<16 394                        Rxx^=asl(Rss,Rt) 665
      Rd=add(Rt.L,Rs.[HL])[:sat] 394                                Rxx[&|]=asl(Rss,#u6) 652
      Rd=add(Ru,mpyi(#u6:2,Rs)) 539                                 Rxx[&|]=asl(Rss,Rt) 665
      Rd=add(Ru,mpyi(Rs,#u6)) 539                                   Rxx[+-]=asl(Rss,#u6) 647
      Rdd=add(Rs,Rtt) 392                                           Rxx[+-]=asl(Rss,Rt) 662
      Rdd=add(Rss,Rtt,Px):carry 397
      Rdd=add(Rss,Rtt) 392                                    aslh
      Rdd=add(Rss,Rtt):raw:hi 392
                                                                    if ([!]Pu[.new]) Rd=aslh(Rs)   198
      Rdd=add(Rss,Rtt):raw:lo 392
                                                                    Rd=aslh(Rs) 193
      Rdd=add(Rss,Rtt):sat 392
      Rx+=add(Rs,#s8) 390
      Rx+=add(Rs,Rt) 390                                      asr
      Rx-=add(Rs,#s8) 390                                           Rd=asr(Rs,#u5) 645
      Rx-=add(Rs,Rt) 390                                            Rd=asr(Rs,#u5):rnd 655
      Ry=add(Ru,mpyi(Ry,Rs)) 540                                    Rd=asr(Rs,Rt) 658
                                                                    Rd=asr(Rs,Rt):sat 668
                                                                    Rdd=asr(Rss,#u6) 645
addasl
                                                                    Rdd=asr(Rss,#u6):rnd 655
      Rd=addasl(Rt,Rs,#u3)      650                                 Rdd=asr(Rss,Rt) 659
                                                                    Rx[&|]=asr(Rs,#u5) 651
all8                                                                Rx[&|]=asr(Rs,Rt) 665
      Pd=all8(Ps)   215                                             Rx[+-]=asr(Rs,#u5) 647
                                                                    Rx[+-]=asr(Rs,Rt) 661
allocframe                                                          Rxx^=asr(Rss,Rt) 665
      allocframe(#u11:3)   329                                      Rxx[&|]=asr(Rss,#u6) 652
                                                                    Rxx[&|]=asr(Rss,Rt) 665
                                                                    Rxx[+-]=asr(Rss,#u6) 647
and
                                                                    Rxx[+-]=asr(Rss,Rt) 662
      if ([!]Pu[.new]) Rd=and(Rs,Rt)   201
      Pd=and(Ps,and(Pt,[!]Pu)) 221
      Pd=and(Pt,[!]Ps) 221                                    asrh
      Rd=and(Rs,#s10) 173                                           if ([!]Pu[.new]) Rd=asrh(Rs)   198
      Rd=and(Rs,Rt) 173                                             Rd=asrh(Rs) 193
      Rd=and(Rt,~Rs) 173
      Rdd=and(Rss,Rtt) 398                                    asrrnd
      Rdd=and(Rtt,~Rss) 398                                         Rd=asrrnd(Rs,#u5) 655
      Rx[&|^]=and(Rs,~Rt) 401                                       Rdd=asrrnd(Rss,#u6) 655
      Rx[&|^]=and(Rs,Rt) 401
      Rx|=and(Rs,#s10) 401                                    B
any8                                                          barrier
      Pd=any8(Ps)   215                                             barrier   375



80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             684
Hexagon V62 Programmer's Reference Manual                                                        Instruction Index


bitsclr                                                     cmp.eq
      Pd=[!]bitsclr(Rs,#u6) 630                                 if ([!]cmp.eq(Ns.new,#-1)) jump:<hint> #r9:2 289
      Pd=[!]bitsclr(Rs,Rt) 630                                  if ([!]cmp.eq(Ns.new,#U5)) jump:<hint> #r9:2 289
                                                                if ([!]cmp.eq(Ns.new,Rt)) jump:<hint> #r9:2 289
bitsplit                                                        p[01]=cmp.eq(Rs,#-1) 231
      Rdd=bitsplit(Rs,#u5) 478                                  p[01]=cmp.eq(Rs,#U5) 231
      Rdd=bitsplit(Rs,Rt) 478                                   p[01]=cmp.eq(Rs,Rt) 231
                                                                Pd=[!]cmp.eq(Rs,#s10) 209
                                                                Pd=[!]cmp.eq(Rs,Rt) 209
bitsset                                                         Pd=cmp.eq(Rss,Rtt) 629
      Pd=[!]bitsset(Rs,Rt)   630                                Rd=[!]cmp.eq(Rs,#s8) 211
                                                                Rd=[!]cmp.eq(Rs,Rt) 211
boundscheck
      Pd=boundscheck(Rs,Rtt) 623                            cmp.ge
      Pd=boundscheck(Rss,Rtt):raw:hi       623                  Pd=cmp.ge(Rs,#s8)   209
      Pd=boundscheck(Rss,Rtt):raw:lo       623
                                                            cmp.geu
brev                                                            Pd=cmp.geu(Rs,#u8)   209
      Rd=brev(Rs) 475
      Rdd=brev(Rss) 475
                                                            cmp.gt
                                                                if ([!]cmp.gt(Ns.new,#-1)) jump:<hint> #r9:2 289
brkpt                                                           if ([!]cmp.gt(Ns.new,#U5)) jump:<hint> #r9:2 289
      brkpt   376                                               if ([!]cmp.gt(Ns.new,Rt)) jump:<hint> #r9:2 290
                                                                if ([!]cmp.gt(Rt,Ns.new)) jump:<hint> #r9:2 290
C                                                               p[01]=cmp.gt(Rs,#-1) 231
                                                                p[01]=cmp.gt(Rs,#U5) 232
call                                                            p[01]=cmp.gt(Rs,Rt) 232
      call #r22:2 229                                           Pd=[!]cmp.gt(Rs,#s10) 209
      if ([!]Pu) call #r15:2   229                              Pd=[!]cmp.gt(Rs,Rt) 209
                                                                Pd=cmp.gt(Rss,Rtt) 629
callr
      callr Rs 225                                          cmp.gtu
      if ([!]Pu) callr Rs   225                                 if ([!]cmp.gtu(Ns.new,#U5)) jump:<hint> #r9:2 290
                                                                if ([!]cmp.gtu(Ns.new,Rt)) jump:<hint> #r9:2 290
ciad                                                            if ([!]cmp.gtu(Rt,Ns.new)) jump:<hint> #r9:2 290
                                                                p[01]=cmp.gtu(Rs,#U5) 232
      ciad(Rs)   333
                                                                p[01]=cmp.gtu(Rs,Rt) 232
                                                                Pd=[!]cmp.gtu(Rs,#u9) 209
cl0                                                             Pd=[!]cmp.gtu(Rs,Rt) 209
      Rd=cl0(Rs) 462                                            Pd=cmp.gtu(Rss,Rtt) 629
      Rd=cl0(Rss) 462
                                                            cmp.lt
cl1                                                             Pd=cmp.lt(Rs,Rt)   209
      Rd=cl1(Rs) 462
      Rd=cl1(Rss) 463
                                                            cmp.ltu
                                                                Pd=cmp.ltu(Rs,Rt)   209
clb
      Rd=add(clb(Rs),#s6) 462
                                                            cmpb.eq
      Rd=add(clb(Rss),#s6) 462
                                                                Pd=cmpb.eq(Rs,#u8) 625
      Rd=clb(Rs) 463
                                                                Pd=cmpb.eq(Rs,Rt) 625
      Rd=clb(Rss) 463

clrbit                                                      cmpb.gt
                                                                Pd=cmpb.gt(Rs,#s8) 625
      memb(Rs+#u6:0)=clrbit(#U5)     286
                                                                Pd=cmpb.gt(Rs,Rt) 625
      memh(Rs+#u6:1)=clrbit(#U5)     287
      memw(Rs+#u6:2)=clrbit(#U5)     288
      Rd=clrbit(Rs,#u5) 476                                 cmpb.gtu
      Rd=clrbit(Rs,Rt) 476                                      Pd=cmpb.gtu(Rs,#u7) 625
                                                                Pd=cmpb.gtu(Rs,Rt) 625

                                                            cmph.eq
                                                                Pd=cmph.eq(Rs,#s8) 627
                                                                Pd=cmph.eq(Rs,Rt) 627

                                                            cmph.gt
                                                                Pd=cmph.gt(Rs,#s8) 627
                                                                Pd=cmph.gt(Rs,Rt) 627




80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    685
Hexagon V62 Programmer's Reference Manual                                                                Instruction Index


cmph.gtu                                                 convert_sf2df
    Pd=cmph.gtu(Rs,#u7) 627                                    Rdd=convert_sf2df(Rs)        521
    Pd=cmph.gtu(Rs,Rt) 627
                                                         convert_sf2ud
cmpy                                                           Rdd=convert_sf2ud(Rs) 524
    Rd=cmpy(Rs,Rt)[:<<1]:rnd:sat 493                           Rdd=convert_sf2ud(Rs):chop          524
    Rd=cmpy(Rs,Rt*)[:<<1]:rnd:sat 493
    Rdd=cmpy(Rs,Rt)[:<<1]:sat 489                        convert_sf2uw
    Rdd=cmpy(Rs,Rt*)[:<<1]:sat 489                             Rd=convert_sf2uw(Rs) 524
    Rxx+=cmpy(Rs,Rt)[:<<1]:sat 489                             Rd=convert_sf2uw(Rs):chop          524
    Rxx+=cmpy(Rs,Rt*)[:<<1]:sat 489
    Rxx-=cmpy(Rs,Rt)[:<<1]:sat 489
    Rxx-=cmpy(Rs,Rt*)[:<<1]:sat 489
                                                         convert_sf2w
                                                               Rd=convert_sf2w(Rs) 524
                                                               Rd=convert_sf2w(Rs):chop           524
cmpyi
    Rdd=cmpyi(Rs,Rt) 491
    Rxx+=cmpyi(Rs,Rt) 491
                                                         convert_ud2df
                                                               Rdd=convert_ud2df(Rss)        522
cmpyiwh
    Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat 495
                                                         convert_ud2sf
    Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat 495                        Rd=convert_ud2sf(Rss)        522

cmpyr                                                    convert_uw2df
    Rdd=cmpyr(Rs,Rt) 491                                       Rdd=convert_uw2df(Rs)        522
    Rxx+=cmpyr(Rs,Rt) 491
                                                         convert_uw2sf
cmpyrwh                                                        Rd=convert_uw2sf(Rs)         522
    Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat 495
    Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat 495                  convert_w2df
                                                               Rdd=convert_w2df(Rs)         522
combine
    if ([!]Pu[.new]) Rdd=combine(Rs,Rt)   200            convert_w2sf
    Rd=combine(Rt.[HL],Rs.[HL]) 188                            Rd=convert_w2sf(Rs)      522
    Rdd=combine(#s8,#S8) 189
    Rdd=combine(#s8,#U6) 189                             cround
    Rdd=combine(#s8,Rs) 189                                    Rd=cround(Rs,#u5) 409
    Rdd=combine(Rs,#s8) 189                                    Rd=cround(Rs,Rt) 409
    Rdd=combine(Rs,Rt) 189

                                                         cswi
convert_d2df                                                   cswi(Rs)   335
    Rdd=convert_d2df(Rss)   522
                                                         ct0
convert_d2sf                                                   Rd=ct0(Rs) 466
    Rd=convert_d2sf(Rss)   522                                 Rd=ct0(Rss) 466

convert_df2d                                             ct1
    Rdd=convert_df2d(Rss) 524                                  Rd=ct1(Rs) 466
    Rdd=convert_df2d(Rss):chop    524                          Rd=ct1(Rss) 466

convert_df2sf                                            ctlbw
    Rd=convert_df2sf(Rss)   521                                Rd=ctlbw(Rss,Rt)       366
convert_df2ud                                            D
    Rdd=convert_df2ud(Rss) 524
    Rdd=convert_df2ud(Rss):chop    524                   dccleana
                                                               dccleana(Rs)     378
convert_df2uw
    Rd=convert_df2uw(Rss) 524                            dccleanidx
    Rd=convert_df2uw(Rss):chop    524                          dccleanidx(Rs)    337
convert_df2w                                             dccleaninva
    Rd=convert_df2w(Rss) 524
                                                               dccleaninva(Rs)    378
    Rd=convert_df2w(Rss):chop     524
                                                         dccleaninvidx
convert_sf2d
                                                               dccleaninvidx(Rs)      337
    Rdd=convert_sf2d(Rs) 524
    Rdd=convert_sf2d(Rs):chop     524



80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                               686
Hexagon V62 Programmer's Reference Manual                                                          Instruction Index


dcfetch                                                       endloop1
    dcfetch(Rs) 377                                               endloop1   212
    dcfetch(Rs+#u11:3)      377
                                                              extract
dcinva                                                            Rd=extract(Rs,#u5,#U5) 468
    dcinva(Rs)     378                                            Rd=extract(Rs,Rtt) 468
                                                                  Rdd=extract(Rss,#u6,#U6) 468
dcinvidx                                                          Rdd=extract(Rss,Rtt) 468
    dcinvidx(Rs)     337
                                                              extractu
dckill                                                            Rd=extractu(Rs,#u5,#U5) 468
    dckill   336                                                  Rd=extractu(Rs,Rtt) 468
                                                                  Rdd=extractu(Rss,#u6,#U6) 468
                                                                  Rdd=extractu(Rss,Rtt) 468
dctagr
    Rd=dctagr(Rs)     337                                     F
dctagw                                                        fastcorner9
    dctagw(Rs,Rt)     337                                         Pd=[!]fastcorner9(Ps,Pt)   214
dczeroa                                                       G
    dczeroa(Rs)    374
                                                              getimask
dealloc_return                                                    Rd=getimask(Rs)      339
    dealloc_return 274
    if ([!]Ps) dealloc_return 274                             H
    nt
        if ([!]Ps.new) dealloc_return:nt 274
    t                                                         hintjr
        if ([!]Ps.new) dealloc_return:t 274                       hintjr(Rs)     227

deallocframe                                                  I
    deallocframe     272
                                                              iassignr
decbin                                                            Rd=iassignr(Rs)      342
    Rdd=decbin(Rss,Rtt)     597
                                                              iassignw
deinterleave                                                      iassignw(Rs)     344
    Rdd=deinterleave(Rss)     472
                                                              icdatar
dfclass                                                           Rd=icdatar(Rs)       346
    Pd=dfclass(Rss,#u5)     517
                                                              icinva
dfcmp.eq                                                          icinva(Rs)     379
    Pd=dfcmp.eq(Rss,Rtt)     519
                                                              icinvidx
dfcmp.ge                                                          icinvidx(Rs)     346
    Pd=dfcmp.ge(Rss,Rtt)     519
                                                              ickill
dfcmp.gt                                                          ickill   347
    Pd=dfcmp.gt(Rss,Rtt)     519
                                                              ictagr
dfcmp.uo                                                          Rd=ictagr(Rs)    346
    Pd=dfcmp.uo(Rss,Rtt)     519
                                                              ictagw
dfmake                                                            ictagw(Rs,Rt)    347
    Rdd=dfmake(#u10):neg     533
    Rdd=dfmake(#u10):pos     533                              if ([!]p[01].new) jump:<hint> #r9:2 231, 231,
                                                              231, 231, 232, 232, 232, 232, 232
E
                                                              insert
endloop0                                                          Rx=insert(Rs,#u5,#U5) 470
    endloop0   212                                                Rx=insert(Rs,Rtt) 470
                                                                  Rxx=insert(Rss,#u6,#U6) 470
endloop01                                                         Rxx=insert(Rss,Rtt) 470
    endloop01   212




80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    687
Hexagon V62 Programmer's Reference Manual                                                            Instruction Index


interleave                                                       l2kill
    Rdd=interleave(Rss)        472                                     l2kill   349

isync                                                            l2locka
    isync   380                                                        Pd=l2locka(Rs)   351
J                                                                l2tagr
                                                                       Rd=l2tagr(Rs)   353
jump
    if ([!]Pu.new) jump:<hint> #r15:2 238                        l2tagw
    if ([!]Pu) jump #r15:2 236                                         l2tagw(Rs,Rt)   353
    if ([!]Pu) jump:<hint> #r15:2 236
    jump #r22:2 236
                                                                 l2unlocka
    nt
        if (Rs!=#0) jump:nt #r13:2 239
                                                                       l2unlocka(Rs)   351
        if (Rs<=#0) jump:nt #r13:2 239
        if (Rs==#0) jump:nt #r13:2 239                           lfs
        if (Rs>=#0) jump:nt #r13:2 239                                 Rdd=lfs(Rss,Rtt)     473
    Rd=#U6 241
    Rd=Rs 241
    t
                                                                 loop0
        if (Rs!=#0) jump:t #r13:2 239                                  loop0(#r7:2,#U10) 216
        if (Rs<=#0) jump:t #r13:2 239                                  loop0(#r7:2,Rs) 216
        if (Rs==#0) jump:t #r13:2 239
        if (Rs>=#0) jump:t #r13:2 239                            loop1
                                                                       loop1(#r7:2,#U10) 216
jump #r9:2 241, 241                                                    loop1(#r7:2,Rs) 216

jumpr                                                            lsl
    if ([!]Pu) jumpr Rs 228                                            Rd=lsl(#s6,Rt) 658
    if ([!]Pu[.new]) jumpr:<hint> Rs        228                        Rd=lsl(Rs,Rt) 658
    jumpr Rs 228                                                       Rdd=lsl(Rss,Rt) 659
                                                                       Rx[&|]=lsl(Rs,Rt) 665
K                                                                      Rx[+-]=lsl(Rs,Rt) 661
                                                                       Rxx^=lsl(Rss,Rt) 665
k0lock                                                                 Rxx[&|]=lsl(Rss,Rt) 665
    k0lock   340                                                       Rxx[+-]=lsl(Rss,Rt) 662


k0unlock                                                         lsr
    k0unlock   341                                                     Rd=lsr(Rs,#u5) 645
                                                                       Rd=lsr(Rs,Rt) 659
L                                                                      Rdd=lsr(Rss,#u6) 645
                                                                       Rdd=lsr(Rss,Rt) 659
                                                                       Rx^=lsr(Rs,#u5) 651
l2cleanidx                                                             Rx[&|]=lsr(Rs,#u5) 651
    l2cleanidx(Rs)      348                                            Rx[&|]=lsr(Rs,Rt) 665
                                                                       Rx[+-]=lsr(Rs,#u5) 647
l2cleaninvidx                                                          Rx[+-]=lsr(Rs,Rt) 662
    l2cleaninvidx(Rs)         348                                      Rx=add(#u8,lsr(Rx,#U5)) 647
                                                                       Rx=and(#u8,lsr(Rx,#U5)) 651
l2fetch                                                                Rx=or(#u8,lsr(Rx,#U5)) 651
                                                                       Rx=sub(#u8,lsr(Rx,#U5)) 647
    l2fetch(Rs,Rt) 382
                                                                       Rxx^=lsr(Rss,#u6) 652
    l2fetch(Rs,Rtt) 382
                                                                       Rxx^=lsr(Rss,Rt) 665
                                                                       Rxx[&|]=lsr(Rss,#u6) 652
l2gclean                                                               Rxx[&|]=lsr(Rss,Rt) 665
    l2gclean 349                                                       Rxx[+-]=lsr(Rss,#u6) 647
    l2gclean(Rtt)       349                                            Rxx[+-]=lsr(Rss,Rt) 662

l2gcleaninv                                                      M
    l2gcleaninv 349
    l2gcleaninv(Rtt)       349                                   mask
                                                                       Rdd=mask(Pt)   632
l2gunlock
    l2gunlock     349                                            max
                                                                       Rd=max(Rs,Rt) 403
l2invidx                                                               Rdd=max(Rss,Rtt) 404
    l2invidx(Rs)     348




80-N2040-36 B                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   688
Hexagon V62 Programmer's Reference Manual                                                        Instruction Index


maxu                                                     membh
    Rd=maxu(Rs,Rt) 403                                       Rd=membh(Re=#U6) 277
    Rdd=maxu(Rss,Rtt) 404                                    Rd=membh(Rs) 277
                                                             Rd=membh(Rs+#s11:1) 277
memb                                                         Rd=membh(Rt<<#u2+#U6) 277
    if ([!]Pt[.new]) Rd=memb(#u6) 248                        Rd=membh(Rx++#s4:1:circ(Mu)) 277
    if ([!]Pt[.new]) Rd=memb(Rs+#u6:0) 248                   Rd=membh(Rx++#s4:1) 277
    if ([!]Pt[.new]) Rd=memb(Rx++#s4:0) 248                  Rd=membh(Rx++I:circ(Mu)) 277
    if ([!]Pv[.new]) memb(#u6)=Nt.new 295                    Rd=membh(Rx++Mu:brev) 278
    if ([!]Pv[.new]) memb(#u6)=Rt 314                        Rd=membh(Rx++Mu) 278
    if ([!]Pv[.new]) memb(Rs+#u6:0)=#S6 314                  Rdd=membh(Re=#U6) 279
    if ([!]Pv[.new]) memb(Rs+#u6:0)=Nt.new 295               Rdd=membh(Rs) 279
    if ([!]Pv[.new]) memb(Rs+#u6:0)=Rt 314                   Rdd=membh(Rs+#s11:2) 279
    if ([!]Pv[.new]) memb(Rs+Ru<<#u2)=Nt.new 295             Rdd=membh(Rt<<#u2+#U6) 280
    if ([!]Pv[.new]) memb(Rs+Ru<<#u2)=Rt 314                 Rdd=membh(Rx++#s4:2:circ(Mu)) 280
    if ([!]Pv[.new]) memb(Rx++#s4:0)=Nt.new 295              Rdd=membh(Rx++#s4:2) 280
    if ([!]Pv[.new]) memb(Rx++#s4:0)=Rt 314                  Rdd=membh(Rx++I:circ(Mu)) 280
    if ([!]Pv[.new]) Rd=memb(Rs+Rt<<#u2) 248                 Rdd=membh(Rx++Mu:brev) 280
    memb(gp+#u16:0)=Nt.new 293                               Rdd=membh(Rx++Mu) 280
    memb(gp+#u16:0)=Rt 312
    memb(Re=#U6)=Nt.new 293                              memd
    memb(Re=#U6)=Rt 312                                      if ([!]Pt[.new]) Rdd=memd(#u6) 244
    memb(Rs+#s11:0)=Nt.new 293                               if ([!]Pt[.new]) Rdd=memd(Rs+#u6:3) 244
    memb(Rs+#s11:0)=Rt 312                                   if ([!]Pt[.new]) Rdd=memd(Rx++#s4:3) 244
    memb(Rs+#u6:0)[+-]=#U5 286                               if ([!]Pv[.new]) memd(#u6)=Rtt 310
    memb(Rs+#u6:0)[+-|&]=Rt 286                              if ([!]Pv[.new]) memd(Rs+#u6:3)=Rtt 310
    memb(Rs+#u6:0)=#S8 312                                   if ([!]Pv[.new]) memd(Rs+Ru<<#u2)=Rtt 310
    memb(Rs+Ru<<#u2)=Nt.new 293                              if ([!]Pv[.new]) memd(Rx++#s4:3)=Rtt 310
    memb(Rs+Ru<<#u2)=Rt 312                                  if ([!]Pv[.new]) Rdd=memd(Rs+Rt<<#u2) 244
    memb(Ru<<#u2+#U6)=Nt.new 293                             memd(gp+#u16:3)=Rtt 308
    memb(Ru<<#u2+#U6)=Rt 312                                 memd(Re=#U6)=Rtt 308
    memb(Rx++#s4:0:circ(Mu))=Nt.new 293                      memd(Rs+#s11:3)=Rtt 308
    memb(Rx++#s4:0:circ(Mu))=Rt 312                          memd(Rs+Ru<<#u2)=Rtt 308
    memb(Rx++#s4:0)=Nt.new 293                               memd(Ru<<#u2+#U6)=Rtt 308
    memb(Rx++#s4:0)=Rt 312                                   memd(Rx++#s4:3:circ(Mu))=Rtt 308
    memb(Rx++I:circ(Mu))=Nt.new 293                          memd(Rx++#s4:3)=Rtt 308
    memb(Rx++I:circ(Mu))=Rt 312                              memd(Rx++I:circ(Mu))=Rtt 308
    memb(Rx++Mu:brev)=Nt.new 293                             memd(Rx++Mu:brev)=Rtt 308
    memb(Rx++Mu:brev)=Rt 312                                 memd(Rx++Mu)=Rtt 308
    memb(Rx++Mu)=Nt.new 293                                  Rdd=memd(gp+#u16:3) 242
    memb(Rx++Mu)=Rt 312                                      Rdd=memd(Re=#U6) 242
    Rd=memb(gp+#u16:0) 246                                   Rdd=memd(Rs+#s11:3) 242
    Rd=memb(Re=#U6) 246                                      Rdd=memd(Rs+Rt<<#u2) 242
    Rd=memb(Rs+#s11:0) 246                                   Rdd=memd(Rt<<#u2+#U6) 242
    Rd=memb(Rs+Rt<<#u2) 246                                  Rdd=memd(Rx++#s4:3:circ(Mu)) 242
    Rd=memb(Rt<<#u2+#U6) 246                                 Rdd=memd(Rx++#s4:3) 242
    Rd=memb(Rx++#s4:0:circ(Mu)) 246                          Rdd=memd(Rx++I:circ(Mu)) 242
    Rd=memb(Rx++#s4:0) 246                                   Rdd=memd(Rx++Mu:brev) 242
    Rd=memb(Rx++I:circ(Mu)) 246                              Rdd=memd(Rx++Mu) 242
    Rd=memb(Rx++Mu:brev) 246
    Rd=memb(Rx++Mu) 246                                  memd_locked
                                                             memd_locked(Rs,Pd)=Rtt 372
memb_fifo                                                    Rdd=memd_locked(Rs) 371
    Ryy=memb_fifo(Re=#U6) 250
    Ryy=memb_fifo(Rs) 250
    Ryy=memb_fifo(Rs+#s11:0) 250
    Ryy=memb_fifo(Rt<<#u2+#U6) 250
    Ryy=memb_fifo(Rx++#s4:0:circ(Mu))   251
    Ryy=memb_fifo(Rx++#s4:0) 251
    Ryy=memb_fifo(Rx++I:circ(Mu)) 251
    Ryy=memb_fifo(Rx++Mu:brev) 251
    Ryy=memb_fifo(Rx++Mu) 251




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       689
Hexagon V62 Programmer's Reference Manual                                                        Instruction Index


memh                                                     memh_fifo
    if ([!]Pt[.new]) Rd=memh(#u6) 258                        Ryy=memh_fifo(Re=#U6) 253
    if ([!]Pt[.new]) Rd=memh(Rs+#u6:1) 258                   Ryy=memh_fifo(Rs) 253
    if ([!]Pt[.new]) Rd=memh(Rx++#s4:1) 258                  Ryy=memh_fifo(Rs+#s11:1) 253
    if ([!]Pv[.new]) memh(#u6)=Nt.new 300                    Ryy=memh_fifo(Rt<<#u2+#U6) 253
    if ([!]Pv[.new]) memh(#u6)=Rt 320                        Ryy=memh_fifo(Rx++#s4:1:circ(Mu))   254
    if ([!]Pv[.new]) memh(#u6)=Rt.H 320                      Ryy=memh_fifo(Rx++#s4:1) 254
    if ([!]Pv[.new]) memh(Rs+#u6:1)=#S6 320                  Ryy=memh_fifo(Rx++I:circ(Mu)) 254
    if ([!]Pv[.new]) memh(Rs+#u6:1)=Nt.new 300               Ryy=memh_fifo(Rx++Mu:brev) 254
    if ([!]Pv[.new]) memh(Rs+#u6:1)=Rt 321                   Ryy=memh_fifo(Rx++Mu) 254
    if ([!]Pv[.new]) memh(Rs+#u6:1)=Rt.H 320
    if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Nt.new 300         memub
    if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Rt 321                 if ([!]Pt[.new]) Rd=memub(#u6) 262
    if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Rt.H 321               if ([!]Pt[.new]) Rd=memub(Rs+#u6:0) 262
    if ([!]Pv[.new]) memh(Rx++#s4:1)=Nt.new 300              if ([!]Pt[.new]) Rd=memub(Rx++#s4:0) 262
    if ([!]Pv[.new]) memh(Rx++#s4:1)=Rt 321                  if ([!]Pv[.new]) Rd=memub(Rs+Rt<<#u2) 262
    if ([!]Pv[.new]) memh(Rx++#s4:1)=Rt.H 321                Rd=memub(gp+#u16:0) 260
    if ([!]Pv[.new]) Rd=memh(Rs+Rt<<#u2) 258                 Rd=memub(Re=#U6) 260
    memh(gp+#u16:1)=Nt.new 298                               Rd=memub(Rs+#s11:0) 260
    memh(gp+#u16:1)=Rt 318                                   Rd=memub(Rs+Rt<<#u2) 260
    memh(gp+#u16:1)=Rt.H 318                                 Rd=memub(Rt<<#u2+#U6) 260
    memh(Re=#U6)=Nt.new 298                                  Rd=memub(Rx++#s4:0:circ(Mu)) 260
    memh(Re=#U6)=Rt 317                                      Rd=memub(Rx++#s4:0) 260
    memh(Re=#U6)=Rt.H 317                                    Rd=memub(Rx++I:circ(Mu)) 260
    memh(Rs+#s11:1)=Nt.new 298                               Rd=memub(Rx++Mu:brev) 260
    memh(Rs+#s11:1)=Rt 317                                   Rd=memub(Rx++Mu) 260
    memh(Rs+#s11:1)=Rt.H 317
    memh(Rs+#u6:1)[+-]=#U5 287
    memh(Rs+#u6:1)[+-|&]=Rt 287
                                                         memubh
    memh(Rs+#u6:1)=#S8 317                                   Rd=memubh(Re=#U6) 278
    memh(Rs+Ru<<#u2)=Nt.new 298                              Rd=memubh(Rs+#s11:1) 278
    memh(Rs+Ru<<#u2)=Rt 317                                  Rd=memubh(Rt<<#u2+#U6) 278
    memh(Rs+Ru<<#u2)=Rt.H 317                                Rd=memubh(Rx++#s4:1:circ(Mu)) 279
    memh(Ru<<#u2+#U6)=Nt.new 298                             Rd=memubh(Rx++#s4:1) 278
    memh(Ru<<#u2+#U6)=Rt 317                                 Rd=memubh(Rx++I:circ(Mu)) 279
    memh(Ru<<#u2+#U6)=Rt.H 317                               Rd=memubh(Rx++Mu:brev) 279
    memh(Rx++#s4:1:circ(Mu))=Nt.new 298                      Rd=memubh(Rx++Mu) 279
    memh(Rx++#s4:1:circ(Mu))=Rt 317                          Rdd=memubh(Re=#U6) 281
    memh(Rx++#s4:1:circ(Mu))=Rt.H 317                        Rdd=memubh(Rs+#s11:2) 281
    memh(Rx++#s4:1)=Nt.new 298                               Rdd=memubh(Rt<<#u2+#U6) 281
    memh(Rx++#s4:1)=Rt 317                                   Rdd=memubh(Rx++#s4:2:circ(Mu)) 282
    memh(Rx++#s4:1)=Rt.H 317                                 Rdd=memubh(Rx++#s4:2) 282
    memh(Rx++I:circ(Mu))=Nt.new 298                          Rdd=memubh(Rx++I:circ(Mu)) 282
    memh(Rx++I:circ(Mu))=Rt 317                              Rdd=memubh(Rx++Mu:brev) 282
    memh(Rx++I:circ(Mu))=Rt.H 317                            Rdd=memubh(Rx++Mu) 282
    memh(Rx++Mu:brev)=Nt.new 298
    memh(Rx++Mu:brev)=Rt 318                             memuh
    memh(Rx++Mu:brev)=Rt.H 318                               if ([!]Pt[.new]) Rd=memuh(#u6) 266
    memh(Rx++Mu)=Nt.new 298                                  if ([!]Pt[.new]) Rd=memuh(Rs+#u6:1) 266
    memh(Rx++Mu)=Rt 318                                      if ([!]Pt[.new]) Rd=memuh(Rx++#s4:1) 266
    memh(Rx++Mu)=Rt.H 318                                    if ([!]Pv[.new]) Rd=memuh(Rs+Rt<<#u2) 266
    Rd=memh(gp+#u16:1) 256                                   Rd=memuh(gp+#u16:1) 264
    Rd=memh(Re=#U6) 256                                      Rd=memuh(Re=#U6) 264
    Rd=memh(Rs+#s11:1) 256                                   Rd=memuh(Rs+#s11:1) 264
    Rd=memh(Rs+Rt<<#u2) 256                                  Rd=memuh(Rs+Rt<<#u2) 264
    Rd=memh(Rt<<#u2+#U6) 256                                 Rd=memuh(Rt<<#u2+#U6) 264
    Rd=memh(Rx++#s4:1:circ(Mu)) 256                          Rd=memuh(Rx++#s4:1:circ(Mu)) 264
    Rd=memh(Rx++#s4:1) 256                                   Rd=memuh(Rx++#s4:1) 264
    Rd=memh(Rx++I:circ(Mu)) 256                              Rd=memuh(Rx++I:circ(Mu)) 264
    Rd=memh(Rx++Mu:brev) 256                                 Rd=memuh(Rx++Mu:brev) 264
    Rd=memh(Rx++Mu) 256                                      Rd=memuh(Rx++Mu) 264




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       690
Hexagon V62 Programmer's Reference Manual                                                           Instruction Index


memw                                                         mpy
      if ([!]Pt[.new]) Rd=memw(#u6) 270                            Rd=mpy(Rs,Rt.H):<<1:rnd:sat 567
      if ([!]Pt[.new]) Rd=memw(Rs+#u6:2) 270                       Rd=mpy(Rs,Rt.H):<<1:sat 567
      if ([!]Pt[.new]) Rd=memw(Rx++#s4:2) 270                      Rd=mpy(Rs,Rt.L):<<1:rnd:sat 567
      if ([!]Pv[.new]) memw(#u6)=Nt.new 305                        Rd=mpy(Rs,Rt.L):<<1:sat 567
      if ([!]Pv[.new]) memw(#u6)=Rt 326                            Rd=mpy(Rs,Rt) 567
      if ([!]Pv[.new]) memw(Rs+#u6:2)=#S6 326                      Rd=mpy(Rs,Rt):<<1 567
      if ([!]Pv[.new]) memw(Rs+#u6:2)=Nt.new 305                   Rd=mpy(Rs,Rt):<<1:sat 567
      if ([!]Pv[.new]) memw(Rs+#u6:2)=Rt 326                       Rd=mpy(Rs,Rt):rnd 567
      if ([!]Pv[.new]) memw(Rs+Ru<<#u2)=Nt.new 305                 Rd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat]   550
      if ([!]Pv[.new]) memw(Rs+Ru<<#u2)=Rt 326                     Rdd=mpy(Rs,Rt) 570
      if ([!]Pv[.new]) memw(Rx++#s4:2)=Nt.new 305                  Rdd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd] 550
      if ([!]Pv[.new]) memw(Rx++#s4:2)=Rt 326                      Rx+=mpy(Rs,Rt):<<1:sat 567
      if ([!]Pv[.new]) Rd=memw(Rs+Rt<<#u2) 270                     Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat] 550
      memw(gp+#u16:2)=Nt.new 303                                   Rx-=mpy(Rs,Rt):<<1:sat 567
      memw(gp+#u16:2)=Rt 324                                       Rx-=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat] 550
      memw(Re=#U6)=Nt.new 303                                      Rxx[+-]=mpy(Rs,Rt) 570
      memw(Re=#U6)=Rt 324                                          Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1] 550
      memw(Rs+#s11:2)=Nt.new 303                                   Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<1] 550
      memw(Rs+#s11:2)=Rt 324
      memw(Rs+#u6:2)[+-]=#U5 288                             mpyi
      memw(Rs+#u6:2)[+-|&]=Rt 288                                  Rd=+mpyi(Rs,#u8) 539
      memw(Rs+#u6:2)=#S8 324                                       Rd=mpyi(Rs,#m9) 540
      memw(Rs+Ru<<#u2)=Nt.new 303                                  Rd=-mpyi(Rs,#u8) 539
      memw(Rs+Ru<<#u2)=Rt 324                                      Rd=mpyi(Rs,Rt) 540
      memw(Ru<<#u2+#U6)=Nt.new 303                                 Rx+=mpyi(Rs,#u8) 540
      memw(Ru<<#u2+#U6)=Rt 324                                     Rx+=mpyi(Rs,Rt) 540
      memw(Rx++#s4:2:circ(Mu))=Nt.new 303                          Rx-=mpyi(Rs,#u8) 540
      memw(Rx++#s4:2:circ(Mu))=Rt 324
      memw(Rx++#s4:2)=Nt.new 303
      memw(Rx++#s4:2)=Rt 324
                                                             mpysu
      memw(Rx++I:circ(Mu))=Nt.new 303                              Rd=mpysu(Rs,Rt)   567
      memw(Rx++I:circ(Mu))=Rt 324
      memw(Rx++Mu:brev)=Nt.new 303                           mpyu
      memw(Rx++Mu:brev)=Rt 324                                     Rd=mpyu(Rs,Rt) 567
      memw(Rx++Mu)=Nt.new 303                                      Rd=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
      memw(Rx++Mu)=Rt 324                                          Rdd=mpyu(Rs,Rt) 570
      Rd=memw(gp+#u16:2) 268                                       Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
      Rd=memw(Re=#U6) 268                                          Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
      Rd=memw(Rs+#s11:2) 268                                       Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
      Rd=memw(Rs+Rt<<#u2) 268                                      Rxx[+-]=mpyu(Rs,Rt) 570
      Rd=memw(Rt<<#u2+#U6) 268                                     Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
      Rd=memw(Rx++#s4:2:circ(Mu)) 268                              Rxx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
      Rd=memw(Rx++#s4:2) 268
      Rd=memw(Rx++I:circ(Mu)) 268                            mpyui
      Rd=memw(Rx++Mu:brev) 268                                     Rd=mpyui(Rs,Rt)   540
      Rd=memw(Rx++Mu) 268

                                                             mux
memw_locked                                                        Rd=mux(Pu,#s8,#S8) 191
      memw_locked(Rs,Pd)=Rt 372                                    Rd=mux(Pu,#s8,Rs) 191
      Rd=memw_locked(Rs) 371                                       Rd=mux(Pu,Rs,#s8) 191
                                                                   Rd=mux(Pu,Rs,Rt) 191
memw_phys
      Rd=memw_phys(Rs,Rt)   355                              N
min                                                          neg
      Rd=min(Rt,Rs) 405                                            Rd=neg(Rs) 175
      Rdd=min(Rtt,Rss) 406                                         Rd=neg(Rs):sat 408
                                                                   Rdd=neg(Rss) 408
minu
      Rd=minu(Rt,Rs) 405                                     nmi
      Rdd=minu(Rtt,Rss) 406                                        nmi(Rs)   356

modwrap
      Rd=modwrap(Rs,Rt)   407




80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          691
Hexagon V62 Programmer's Reference Manual                                                                 Instruction Index


no mnemonic                                                      pmpyw
   Cd=Rs 223                                                           Rdd=pmpyw(Rs,Rt) 563
   Cdd=Rss 223                                                         Rxx^=pmpyw(Rs,Rt) 563
   Gd=Rs 331
   Gdd=Rss 331                                                   popcount
      if ([!]Pu[.new]) Rd=#s12 206                                     Rd=popcount(Rss)     465
      if ([!]Pu[.new]) Rd=Rs 206
      if ([!]Pu[.new]) Rdd=Rss 206                               R
      Pd=Ps 221
      Pd=Rs 634
      Rd=#s16 180                                                resume
      Rd=Cs 223                                                        resume(Rs)   357
      Rd=Gs 331
      Rd=Ps 634                                                  rol
      Rd=Rs 182                                                        Rd=rol(Rs,#u5) 645
      Rd=Ss 368                                                        Rdd=rol(Rss,#u6) 645
      Rdd=#s8 180                                                      Rx^=rol(Rs,#u5) 651
      Rdd=Css 223                                                      Rx[&|]=rol(Rs,#u5) 651
      Rdd=Gss 331                                                      Rx[+-]=rol(Rs,#u5) 647
      Rdd=Rss 182                                                      Rxx^=rol(Rss,#u6) 652
      Rdd=Sss 368                                                      Rxx[&|]=rol(Rss,#u6) 652
      Rx.[HL]=#u16 180                                                 Rxx[+-]=rol(Rss,#u6) 647
      Sd=Rs 368
      Sdd=Rss 368                                                round
                                                                       Rd=round(Rs,#u5)[:sat] 409
nop                                                                    Rd=round(Rs,Rt)[:sat] 409
      nop   176                                                        Rd=round(Rss):sat 409

normamt                                                          rte
      Rd=normamt(Rs) 463                                               rte   358
      Rd=normamt(Rss) 463
                                                                 rteunlock
not                                                                    rteunlock   359
      Pd=not(Ps) 221
      Rd=not(Rs) 173                                             S
      Rdd=not(Rss) 398

O                                                                sat
                                                                       Rd=sat(Rss)   599
or                                                               satb
      if ([!]Pu[.new]) Rd=or(Rs,Rt)      201                           Rd=satb(Rs)   599
      Pd=and(Ps,or(Pt,[!]Pu)) 221
      Pd=or(Ps,and(Pt,[!]Pu)) 221
      Pd=or(Ps,or(Pt,[!]Pu)) 221                                 sath
      Pd=or(Pt,[!]Ps) 221                                              Rd=sath(Rs)   599
      Rd=or(Rs,#s10) 173
      Rd=or(Rs,Rt) 173                                           satub
      Rd=or(Rt,~Rs) 173                                                Rd=satub(Rs)   599
      Rdd=or(Rss,Rtt) 398
      Rdd=or(Rtt,~Rss) 398                                       satuh
      Rx[&|^]=or(Rs,Rt) 401
                                                                       Rd=satuh(Rs)   599
      Rx=or(Ru,and(Rx,#s10)) 401
      Rx|=or(Rs,#s10) 401
                                                                 setbit
P                                                                      memb(Rs+#u6:0)=setbit(#U5)   286
                                                                       memh(Rs+#u6:1)=setbit(#U5)   287
                                                                       memw(Rs+#u6:2)=setbit(#U5)   288
packhl                                                                 Rd=setbit(Rs,#u5) 476
      Rdd=packhl(Rs,Rt)    195                                         Rd=setbit(Rs,Rt) 476

parity                                                           setimask
      Rd=parity(Rs,Rt) 474                                             setimask(Pt,Rs)     360
      Rd=parity(Rss,Rtt) 474

                                                                 sfadd
pause                                                                  Rd=sfadd(Rs,Rt)     516
      pause(#u8)   384
                                                                 sfclass
pc                                                                     Pd=sfclass(Rs,#u5)    517
      Rd=add(pc,#u6)     218




80-N2040-36 B                  MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        692
Hexagon V62 Programmer's Reference Manual                                                                  Instruction Index


sfcmp.eq                                                        shuffob
      Pd=sfcmp.eq(Rs,Rt)     519                                      Rdd=shuffob(Rtt,Rss)   611

sfcmp.ge                                                        shuffoh
      Pd=sfcmp.ge(Rs,Rt)     519                                      Rdd=shuffoh(Rtt,Rss)   611

sfcmp.gt                                                        siad
      Pd=sfcmp.gt(Rs,Rt)     519                                      siad(Rs)   361

sfcmp.uo                                                        sp1loop0
      Pd=sfcmp.uo(Rs,Rt)     519                                      p3=sp1loop0(#r7:2,#U10) 219
                                                                      p3=sp1loop0(#r7:2,Rs) 219
sffixupd
      Rd=sffixupd(Rs,Rt)     527                                sp2loop0
                                                                      p3=sp2loop0(#r7:2,#U10) 219
sffixupn                                                              p3=sp2loop0(#r7:2,Rs) 219
      Rd=sffixupn(Rs,Rt)     527
                                                                sp3loop0
sffixupr                                                              p3=sp3loop0(#r7:2,#U10) 219
      Rd=sffixupr(Rs)   527                                           p3=sp3loop0(#r7:2,Rs) 219


sfinvsqrta                                                      start
      Rd,Pe=sfinvsqrta(Rs)     530                                    start(Rs)   362

sfmake                                                          stop
      Rd=sfmake(#u10):neg     533                                     stop(Rs)   363
      Rd=sfmake(#u10):pos     533
                                                                sub
sfmax                                                                 if ([!]Pu[.new]) Rd=sub(Rt,Rs) 203
      Rd=sfmax(Rs,Rt)   534                                           Rd=add(Rs,sub(#s6,Ru)) 390
                                                                      Rd=sub(#s10,Rs) 177
                                                                      Rd=sub(Rt,Rs) 177
sfmin                                                                 Rd=sub(Rt,Rs):sat 177
      Rd=sfmin(Rs,Rt)   535                                           Rd=sub(Rt,Rs):sat:deprecated 411
                                                                      Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<<16   413
sfmpy                                                                 Rd=sub(Rt.L,Rs.[HL])[:sat] 413
      Rd=sfmpy(Rs,Rt) 536                                             Rdd=sub(Rss,Rtt,Px):carry 397
      Rx+=sfmpy(Rs,Rt,Pu):scale       529                             Rdd=sub(Rtt,Rss) 411
      Rx+=sfmpy(Rs,Rt) 528                                            Rx+=sub(Rt,Rs) 412
      Rx+=sfmpy(Rs,Rt):lib 531
      Rx-=sfmpy(Rs,Rt) 528                                      swi
      Rx-=sfmpy(Rs,Rt):lib 531                                        swi(Rs)   364
sfrecipa                                                        swiz
      Rd,Pe=sfrecipa(Rs,Rt)     537                                   Rd=swiz(Rs)     601
sfsub                                                           sxtb
      Rd=sfsub(Rs,Rt)   538                                           if ([!]Pu[.new]) Rd=sxtb(Rs)   204
                                                                      Rd=sxtb(Rs) 179
sgp
      crswap(Rx,sgp)   334                                      sxth
                                                                      if ([!]Pu[.new]) Rd=sxth(Rs)   204
sgp0                                                                  Rd=sxth(Rs) 179
      crswap(Rx,sgp0)   334
                                                                sxtw
sgp1                                                                  Rdd=sxtw(Rs)     416
      0
          crswap(Rxx,sgp1:0)        334                         syncht
      crswap(Rx,sgp1) 334
                                                                      syncht   385
shuffeb                                                         T
      Rdd=shuffeb(Rss,Rtt)     611
                                                                tableidxb
shuffeh                                                               Rx=tableidxb(Rs,#u4,#S6):raw   481
      Rdd=shuffeh(Rss,Rtt)     611                                    Rx=tableidxb(Rs,#u4,#U5) 481




80-N2040-36 B                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          693
Hexagon V62 Programmer's Reference Manual                                                                 Instruction Index


tableidxd                                                      vabsdiffw
    Rx=tableidxd(Rs,#u4,#S6):raw         481                       Rdd=vabsdiffw(Rtt,Rss)     421
    Rx=tableidxd(Rs,#u4,#U5) 481
                                                               vabsh
tableidxh                                                          Rdd=vabsh(Rss) 417
    Rx=tableidxh(Rs,#u4,#S6):raw         481                       Rdd=vabsh(Rss):sat   417
    Rx=tableidxh(Rs,#u4,#U5) 481
                                                               vabsw
tableidxw                                                          Rdd=vabsw(Rss) 418
    Rx=tableidxw(Rs,#u4,#S6):raw         481                       Rdd=vabsw(Rss):sat   418
    Rx=tableidxw(Rs,#u4,#U5) 481
                                                               vacsh
tlbinvasid                                                         Rxx,Pe=vacsh(Rss,Rtt)   423
    tlbinvasid(Rs)     366
                                                               vaddb
tlblock                                                            Rdd=vaddb(Rss,Rtt)   432
    tlblock   340
                                                               vaddh
tlbmatch                                                           Rd=vaddh(Rs,Rt)[:sat] 183
    Pd=tlbmatch(Rss,Rt)      633                                   Rdd=vaddh(Rss,Rtt)[:sat] 425

tlboc                                                          vaddhub
    Rd=tlboc(Rss)     366                                          Rd=vaddhub(Rss,Rtt):sat    427

tlbp                                                           vaddub
    Rd=tlbp(Rs)     366                                            Rdd=vaddub(Rss,Rtt)[:sat]     432

tlbr                                                           vadduh
    Rdd=tlbr(Rs)    366                                            Rd=vadduh(Rs,Rt):sat 183
                                                                   Rdd=vadduh(Rss,Rtt):sat 425
tlbunlock
    tlbunlock   341                                            vaddw
                                                                   Rdd=vaddw(Rss,Rtt)[:sat]    433
tlbw
    tlbw(Rss,Rt)    366                                        valignb
                                                                   Rdd=valignb(Rtt,Rss,#u3) 602
togglebit                                                          Rdd=valignb(Rtt,Rss,Pu) 602
    Rd=togglebit(Rs,#u5) 476
    Rd=togglebit(Rs,Rt) 476                                    vaslh
                                                                   Rdd=vaslh(Rss,#u4) 670
trace                                                              Rdd=vaslh(Rss,Rt) 676
    trace(Rs)   386
                                                               vaslw
trap0                                                              Rdd=vaslw(Rss,#u5) 678
    trap0(#u8)   387                                               Rdd=vaslw(Rss,Rt) 680


trap1                                                          vasrh
    trap1(#u8)   387                                               Rdd=vasrh(Rss,#u4) 670
                                                                   Rdd=vasrh(Rss,#u4):raw     672
                                                                   Rdd=vasrh(Rss,#u4):rnd     672
tstbit                                                             Rdd=vasrh(Rss,Rt) 676
    if ([!]tstbit(Ns.new,#0)) jump:<hint> #r9:2      290
    p[01]=tstbit(Rs,#0) 232
    Pd=[!]tstbit(Rs,#u5) 635
                                                               vasrhub
    Pd=[!]tstbit(Rs,Rt) 635                                        Rd=vasrhub(Rss,#u4):raw 674
                                                                   Rd=vasrhub(Rss,#u4):rnd:sat      674
V                                                                  Rd=vasrhub(Rss,#u4):sat 674


vabsdiffb                                                      vasrw
                                                                   Rd=vasrw(Rss,#u5) 682
    Rdd=vabsdiffb(Rtt,Rss)      419
                                                                   Rd=vasrw(Rss,Rt) 682
                                                                   Rdd=vasrw(Rss,#u5) 678
vabsdiffh                                                          Rdd=vasrw(Rss,Rt) 680
    Rdd=vabsdiffh(Rtt,Rss)      420

vabsdiffub
    Rdd=vabsdiffub(Rtt,Rss)        419



80-N2040-36 B                MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          694
Hexagon V62 Programmer's Reference Manual                                                       Instruction Index


vavgh                                                    vcnegh
    Rd=vavgh(Rs,Rt) 184                                      Rdd=vcnegh(Rss,Rt)   439
    Rd=vavgh(Rs,Rt):rnd 184
    Rdd=vavgh(Rss,Rtt) 434                               vconj
    Rdd=vavgh(Rss,Rtt):crnd 434                              Rdd=vconj(Rss):sat   500
    Rdd=vavgh(Rss,Rtt):rnd 434

                                                         vcrotate
vavgub                                                       Rdd=vcrotate(Rss,Rt)   501
    Rdd=vavgub(Rss,Rtt) 436
    Rdd=vavgub(Rss,Rtt):rnd   436
                                                         vdmpy
                                                             Rd=vdmpy(Rss,Rtt)[:<<1]:rnd:sat   575
vavguh                                                       Rdd=vdmpy(Rss,Rtt):<<1:sat 573
    Rdd=vavguh(Rss,Rtt) 434                                  Rdd=vdmpy(Rss,Rtt):sat 573
    Rdd=vavguh(Rss,Rtt):rnd   434                            Rxx+=vdmpy(Rss,Rtt):<<1:sat 573
                                                             Rxx+=vdmpy(Rss,Rtt):sat 573
vavguw
    Rdd=vavguw(Rss,Rtt)[:rnd]     437                    vdmpybsu
                                                             Rdd=vdmpybsu(Rss,Rtt):sat 580
vavgw                                                        Rxx+=vdmpybsu(Rss,Rtt):sat 580
    Rdd=vavgw(Rss,Rtt):crnd 437
    Rdd=vavgw(Rss,Rtt)[:rnd] 437                         vitpack
                                                             Rd=vitpack(Ps,Pt)   643
vcmpb.eq
    Pd=any8(vcmpb.eq(Rss,Rtt))    638                    vlslh
    Pd=vcmpb.eq(Rss,#u8) 639                                 Rdd=vlslh(Rss,Rt)   676
    Pd=vcmpb.eq(Rss,Rtt) 639

                                                         vlslw
vcmpb.gt                                                     Rdd=vlslw(Rss,Rt)   680
    Pd=vcmpb.gt(Rss,#s8)   639
    Pd=vcmpb.gt(Rss,Rtt)   639
                                                         vlsrh
                                                             Rdd=vlsrh(Rss,#u4) 670
vcmpb.gtu                                                    Rdd=vlsrh(Rss,Rt) 676
    Pd=vcmpb.gtu(Rss,#u7)   639
    Pd=vcmpb.gtu(Rss,Rtt)   639
                                                         vlsrw
                                                             Rdd=vlsrw(Rss,#u5) 678
vcmph.eq                                                     Rdd=vlsrw(Rss,Rt) 680
    Pd=vcmph.eq(Rss,#s8)   636
    Pd=vcmph.eq(Rss,Rtt)   636
                                                         vmaxb
                                                             Rdd=vmaxb(Rtt,Rss)   441
vcmph.gt
    Pd=vcmph.gt(Rss,#s8)   636
    Pd=vcmph.gt(Rss,Rtt)   636                           vmaxh
                                                             Rdd=vmaxh(Rtt,Rss)   442
vcmph.gtu
    Pd=vcmph.gtu(Rss,#u7)   636                          vmaxub
    Pd=vcmph.gtu(Rss,Rtt)   636                              Rdd=vmaxub(Rtt,Rss)   441

vcmpw.eq                                                 vmaxuh
    Pd=vcmpw.eq(Rss,#s8)   641                               Rdd=vmaxuh(Rtt,Rss)   442
    Pd=vcmpw.eq(Rss,Rtt)   641
                                                         vmaxuw
vcmpw.gt                                                     Rdd=vmaxuw(Rtt,Rss)   447
    Pd=vcmpw.gt(Rss,#s8)   641
    Pd=vcmpw.gt(Rss,Rtt)   641                           vmaxw
                                                             Rdd=vmaxw(Rtt,Rss)   447
vcmpw.gtu
    Pd=vcmpw.gtu(Rss,#u7)   641                          vminb
    Pd=vcmpw.gtu(Rss,Rtt)   641                              Rdd=vminb(Rtt,Rss)   448

vcmpyi                                                   vminh
    Rdd=vcmpyi(Rss,Rtt)[:<<1]:sat       498                  Rdd=vminh(Rtt,Rss)   450
    Rxx+=vcmpyi(Rss,Rtt):sat 498
                                                         vminub
vcmpyr                                                       Rdd,Pe=vminub(Rtt,Rss) 448
    Rdd=vcmpyr(Rss,Rtt)[:<<1]:sat       498                  Rdd=vminub(Rtt,Rss) 448
    Rxx+=vcmpyr(Rss,Rtt):sat 498




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      695
Hexagon V62 Programmer's Reference Manual                                                         Instruction Index


vminuh                                                     vnavgw
    Rdd=vminuh(Rtt,Rss)   450                                  Rdd=vnavgw(Rtt,Rss) 437
                                                               Rdd=vnavgw(Rtt,Rss):crnd:sat 437
vminuw                                                         Rdd=vnavgw(Rtt,Rss):rnd:sat 437
    Rdd=vminuw(Rtt,Rss)   455
                                                           vpmpyh
vminw                                                          Rdd=vpmpyh(Rs,Rt) 595
    Rdd=vminw(Rtt,Rss)   455                                   Rxx^=vpmpyh(Rs,Rt) 595


vmpybsu                                                    vraddh
    Rdd=vmpybsu(Rs,Rt) 592                                     Rd=vraddh(Rss,Rtt)   430
    Rxx+=vmpybsu(Rs,Rt) 592
                                                           vraddub
vmpybu                                                         Rdd=vraddub(Rss,Rtt) 428
    Rdd=vmpybu(Rs,Rt) 592                                      Rxx+=vraddub(Rss,Rtt) 428
    Rxx+=vmpybu(Rs,Rt) 592
                                                           vradduh
vmpyeh                                                         Rd=vradduh(Rss,Rtt)   430
    Rdd=vmpyeh(Rss,Rtt):<<1:sat 582
    Rdd=vmpyeh(Rss,Rtt):sat 582                            vrcmpyi
    Rxx+=vmpyeh(Rss,Rtt) 582                                   Rdd=vrcmpyi(Rss,Rtt) 503
    Rxx+=vmpyeh(Rss,Rtt):<<1:sat 582                           Rdd=vrcmpyi(Rss,Rtt*) 503
    Rxx+=vmpyeh(Rss,Rtt):sat 582                               Rxx+=vrcmpyi(Rss,Rtt) 504
                                                               Rxx+=vrcmpyi(Rss,Rtt*) 504
vmpyh
    Rd=vmpyh(Rs,Rt)[:<<1]:rnd:sat 586                      vrcmpyr
    Rdd=vmpyh(Rs,Rt)[:<<1]:sat 584                             Rdd=vrcmpyr(Rss,Rtt) 503
    Rxx+=vmpyh(Rs,Rt) 584                                      Rdd=vrcmpyr(Rss,Rtt*) 504
    Rxx+=vmpyh(Rs,Rt)[:<<1]:sat 584                            Rxx+=vrcmpyr(Rss,Rtt) 504
                                                               Rxx+=vrcmpyr(Rss,Rtt*) 504
vmpyhsu
    Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat 588                       vrcmpys
    Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat 588                          Rd=vrcmpys(Rss,Rt):<<1:rnd:sat 510
                                                               Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi 510
vmpyweh                                                        Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo 510
    Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat 543                     Rdd=vrcmpys(Rss,Rt):<<1:sat 507
    Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat 543                         Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi 507
    Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat 543                    Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo 507
    Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat 543                        Rxx+=vrcmpys(Rss,Rt):<<1:sat 507
                                                               Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi 507
                                                               Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo 507
vmpyweuh
    Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat 547
    Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat 547
                                                           vrcnegh
    Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat 547                   Rxx+=vrcnegh(Rss,Rt)   439
    Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sat 547
                                                           vrcrotate
vmpywoh                                                        Rdd=vrcrotate(Rss,Rt,#u2) 513
    Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat 543                     Rxx+=vrcrotate(Rss,Rt,#u2) 513
    Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat 543
    Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat 543                vrmaxh
    Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat 543                        Rxx=vrmaxh(Rss,Ru)   443

vmpywouh                                                   vrmaxuh
    Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat 547                    Rxx=vrmaxuh(Rss,Ru)   443
    Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat 547
    Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat 547               vrmaxuw
    Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sat 547                       Rxx=vrmaxuw(Rss,Ru)   445
vmux                                                       vrmaxw
    Rdd=vmux(Pu,Rss,Rtt)   644                                 Rxx=vrmaxw(Rss,Ru)   445
vnavgh                                                     vrminh
    Rd=vnavgh(Rt,Rs) 184                                       Rxx=vrminh(Rss,Ru)   451
    Rdd=vnavgh(Rtt,Rss) 434
    Rdd=vnavgh(Rtt,Rss):crnd:sat 434
    Rdd=vnavgh(Rtt,Rss):rnd:sat 434
                                                           vrminuh
                                                               Rxx=vrminuh(Rss,Ru)   451



80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      696
Hexagon V62 Programmer's Reference Manual                                                             Instruction Index


vrminuw                                                       vsubh
    Rxx=vrminuw(Rss,Ru)     453                                   Rd=vsubh(Rt,Rs)[:sat] 185
                                                                  Rdd=vsubh(Rtt,Rss)[:sat] 458
vrminw
    Rxx=vrminw(Rss,Ru)   453                                  vsubub
                                                                  Rdd=vsubub(Rtt,Rss)[:sat]     460
vrmpybsu
    Rdd=vrmpybsu(Rss,Rtt) 578                                 vsubuh
    Rxx+=vrmpybsu(Rss,Rtt) 578                                    Rd=vsubuh(Rt,Rs):sat 185
                                                                  Rdd=vsubuh(Rtt,Rss):sat 458
vrmpybu
    Rdd=vrmpybu(Rss,Rtt) 578                                  vsubw
    Rxx+=vrmpybu(Rss,Rtt) 578                                     Rdd=vsubw(Rtt,Rss)[:sat]   461

vrmpyh                                                        vsxtbh
    Rdd=vrmpyh(Rss,Rtt) 590                                       Rdd=vsxtbh(Rs)   616
    Rxx+=vrmpyh(Rss,Rtt) 590
                                                              vsxthw
vrmpyweh                                                          Rdd=vsxthw(Rs)   616
    Rdd=vrmpyweh(Rss,Rtt)[:<<1] 565
    Rxx+=vrmpyweh(Rss,Rtt)[:<<1] 565                          vtrunehb
                                                                  Rd=vtrunehb(Rss) 618
vrmpywoh                                                          Rdd=vtrunehb(Rss,Rtt)   619
    Rdd=vrmpywoh(Rss,Rtt)[:<<1] 565
    Rxx+=vrmpywoh(Rss,Rtt)[:<<1] 565                          vtrunewh
                                                                  Rdd=vtrunewh(Rss,Rtt)   619
vrndwh
    Rd=vrndwh(Rss) 604                                        vtrunohb
    Rd=vrndwh(Rss):sat   604                                      Rd=vtrunohb(Rss) 619
                                                                  Rdd=vtrunohb(Rss,Rtt)   619
vrsadub
    Rdd=vrsadub(Rss,Rtt) 456                                  vtrunowh
    Rxx+=vrsadub(Rss,Rtt) 456                                     Rdd=vtrunowh(Rss,Rtt)   619
vsathb                                                        vxaddsubh
    Rd=vsathb(Rs) 607                                             Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat   484
    Rd=vsathb(Rss) 607                                            Rdd=vxaddsubh(Rss,Rtt):sat 484
    Rdd=vsathb(Rss) 609

                                                              vxaddsubw
vsathub                                                           Rdd=vxaddsubw(Rss,Rtt):sat    486
    Rd=vsathub(Rs) 607
    Rd=vsathub(Rss) 607
    Rdd=vsathub(Rss) 609
                                                              vxsubaddh
                                                                  Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat   484
                                                                  Rdd=vxsubaddh(Rss,Rtt):sat 484
vsatwh
    Rd=vsatwh(Rss) 607
    Rdd=vsatwh(Rss) 609
                                                              vxsubaddw
                                                                  Rdd=vxsubaddw(Rss,Rtt):sat    486
vsatwuh
    Rd=vsatwuh(Rss) 607
                                                              vzxtbh
    Rdd=vsatwuh(Rss) 609                                          Rdd=vzxtbh(Rs)   621

vsplatb                                                       vzxthw
    Rd=vsplatb(Rs) 613                                            Rdd=vzxthw(Rs)   621
    Rdd=vsplatb(Rs) 613
                                                              W
vsplath
    Rdd=vsplath(Rs)   614                                     wait
                                                                  wait(Rs)   370
vspliceb
    Rdd=vspliceb(Rss,Rtt,#u3) 615
    Rdd=vspliceb(Rss,Rtt,Pu) 615

vsubb
    Rdd=vsubb(Rss,Rtt)   460




80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       697
Hexagon V62 Programmer's Reference Manual                                                  Instruction Index



X
xor
      if ([!]Pu[.new]) Rd=xor(Rs,Rt)   201
      Pd=xor(Ps,Pt) 221
      Rd=xor(Rs,Rt) 173
      Rdd=xor(Rss,Rtt) 398
      Rx[&|^]=xor(Rs,Rt) 401
      Rxx^=xor(Rss,Rtt) 400

Z
zxtb
      if ([!]Pu[.new]) Rd=zxtb(Rs)   207
      Rd=zxtb(Rs) 187

zxth
      if ([!]Pu[.new]) Rd=zxth(Rs)   207
      Rd=zxth(Rs) 187




80-N2040-36 B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                698
Intrinsics Index


A
abs
Rd=abs(Rs)                          Word32 Q6_R_abs_R(Word32 Rs)                                   389
Rd=abs(Rs):sat                      Word32 Q6_R_abs_R_sat(Word32 Rs)                               389
Rdd=abs(Rss)                        Word64 Q6_P_abs_P(Word64 Rss)                                  388

add
Rd=add(#u6,mpyi(Rs,#U6))            Word32 Q6_R_add_mpyi_IRI(Word32 Iu6, Word32 Rs, Word32 IU6)    540
Rd=add(#u6,mpyi(Rs,Rt))             Word32 Q6_R_add_mpyi_IRR(Word32 Iu6, Word32 Rs, Word32 Rt)     540
Rd=add(Rs,#s16)                     Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)                     171
Rd=add(Rs,add(Ru,#s6))              Word32 Q6_R_add_add_RRI(Word32 Rs, Word32 Ru, Word32 Is6)      390
Rd=add(Rs,Rt)                       Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)                       171
Rd=add(Rs,Rt):sat                   Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)                   171
Rd=add(Rt.H,Rs.H):<<16              Word32 Q6_R_add_RhRh_s16(Word32 Rt, Word32 Rs)                 395
Rd=add(Rt.H,Rs.H):sat:<<16          Word32 Q6_R_add_RhRh_sat_s16(Word32 Rt, Word32 Rs)             395
Rd=add(Rt.H,Rs.L):<<16              Word32 Q6_R_add_RhRl_s16(Word32 Rt, Word32 Rs)                 395
Rd=add(Rt.H,Rs.L):sat:<<16          Word32 Q6_R_add_RhRl_sat_s16(Word32 Rt, Word32 Rs)             395
Rd=add(Rt.L,Rs.H)                   Word32 Q6_R_add_RlRh(Word32 Rt, Word32 Rs)                     395
Rd=add(Rt.L,Rs.H):<<16              Word32 Q6_R_add_RlRh_s16(Word32 Rt, Word32 Rs)                 395
Rd=add(Rt.L,Rs.H):sat               Word32 Q6_R_add_RlRh_sat(Word32 Rt, Word32 Rs)                 395
Rd=add(Rt.L,Rs.H):sat:<<16          Word32 Q6_R_add_RlRh_sat_s16(Word32 Rt, Word32 Rs)             395
Rd=add(Rt.L,Rs.L)                   Word32 Q6_R_add_RlRl(Word32 Rt, Word32 Rs)                     395
Rd=add(Rt.L,Rs.L):<<16              Word32 Q6_R_add_RlRl_s16(Word32 Rt, Word32 Rs)                 395
Rd=add(Rt.L,Rs.L):sat               Word32 Q6_R_add_RlRl_sat(Word32 Rt, Word32 Rs)                 395
Rd=add(Rt.L,Rs.L):sat:<<16          Word32 Q6_R_add_RlRl_sat_s16(Word32 Rt, Word32 Rs)             395
Rd=add(Ru,mpyi(#u6:2,Rs))           Word32 Q6_R_add_mpyi_RIR(Word32 Ru, Word32 Iu6_2, Word32 Rs)   540
Rd=add(Ru,mpyi(Rs,#u6))             Word32 Q6_R_add_mpyi_RRI(Word32 Ru, Word32 Rs, Word32 Iu6)     540
Rdd=add(Rs,Rtt)                     Word64 Q6_P_add_RP(Word32 Rs, Word64 Rtt)                      392
Rdd=add(Rss,Rtt)                    Word64 Q6_P_add_PP(Word64 Rss, Word64 Rtt)                     392
Rdd=add(Rss,Rtt):sat                Word64 Q6_P_add_PP_sat(Word64 Rss, Word64 Rtt)                 392
Rx+=add(Rs,#s8)                     Word32 Q6_R_addacc_RI(Word32 Rx, Word32 Rs, Word32 Is8)        390
Rx+=add(Rs,Rt)                      Word32 Q6_R_addacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)         390
Rx-=add(Rs,#s8)                     Word32 Q6_R_addnac_RI(Word32 Rx, Word32 Rs, Word32 Is8)        390
Rx-=add(Rs,Rt)                      Word32 Q6_R_addnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)         390
Ry=add(Ru,mpyi(Ry,Rs))              Word32 Q6_R_add_mpyi_RRR(Word32 Ru, Word32 Ry, Word32 Rs)      540

addasl
Rd=addasl(Rt,Rs,#u3)                Word32 Q6_R_addasl_RRI(Word32 Rt, Word32 Rs, Word32 Iu3)       650

all8
Pd=all8(Ps)                         Byte Q6_p_all8_p(Byte Ps)                                      215




80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION         699
Hexagon V62 Programmer's Reference Manual                                                        Intrinsics Index



and
Pd=and(Ps,and(Pt,!Pu))              Byte Q6_p_and_and_ppnp(Byte Ps, Byte Pt, Byte Pu)                       221
Pd=and(Ps,and(Pt,Pu))               Byte Q6_p_and_and_ppp(Byte Ps, Byte Pt, Byte Pu)                        221
Pd=and(Pt,!Ps)                      Byte Q6_p_and_pnp(Byte Pt, Byte Ps)                                     221
Pd=and(Pt,Ps)                       Byte Q6_p_and_pp(Byte Pt, Byte Ps)                                      221
Rd=and(Rs,#s10)                     Word32 Q6_R_and_RI(Word32 Rs, Word32 Is10)                              173
Rd=and(Rs,Rt)                       Word32 Q6_R_and_RR(Word32 Rs, Word32 Rt)                                173
Rd=and(Rt,~Rs)                      Word32 Q6_R_and_RnR(Word32 Rt, Word32 Rs)                               173
Rdd=and(Rss,Rtt)                    Word64 Q6_P_and_PP(Word64 Rss, Word64 Rtt)                              398
Rdd=and(Rtt,~Rss)                   Word64 Q6_P_and_PnP(Word64 Rtt, Word64 Rss)                             398
Rx^=and(Rs,~Rt)                     Word32 Q6_R_andxacc_RnR(Word32 Rx, Word32 Rs, Word32 Rt)                401
Rx^=and(Rs,Rt)                      Word32 Q6_R_andxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 401
Rx&=and(Rs,~Rt)                     Word32 Q6_R_andand_RnR(Word32 Rx, Word32 Rs, Word32 Rt)                 401
Rx&=and(Rs,Rt)                      Word32 Q6_R_andand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  401
Rx|=and(Rs,#s10)                    Word32 Q6_R_andor_RI(Word32 Rx, Word32 Rs, Word32 Is10)                 401
Rx|=and(Rs,~Rt)                     Word32 Q6_R_andor_RnR(Word32 Rx, Word32 Rs, Word32 Rt)                  402
Rx|=and(Rs,Rt)                      Word32 Q6_R_andor_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   402

any8
Pd=any8(Ps)                         Byte Q6_p_any8_p(Byte Ps)                                               215

asl
Rd=asl(Rs,#u5)                      Word32 Q6_R_asl_RI(Word32 Rs, Word32 Iu5)                               646
Rd=asl(Rs,#u5):sat                  Word32 Q6_R_asl_RI_sat(Word32 Rs, Word32 Iu5)                           657
Rd=asl(Rs,Rt)                       Word32 Q6_R_asl_RR(Word32 Rs, Word32 Rt)                                659
Rd=asl(Rs,Rt):sat                   Word32 Q6_R_asl_RR_sat(Word32 Rs, Word32 Rt)                            668
Rdd=asl(Rss,#u6)                    Word64 Q6_P_asl_PI(Word64 Rss, Word32 Iu6)                              646
Rdd=asl(Rss,Rt)                     Word64 Q6_P_asl_PR(Word64 Rss, Word32 Rt)                               659
Rx^=asl(Rs,#u5)                     Word32 Q6_R_aslxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                652
Rx&=asl(Rs,#u5)                     Word32 Q6_R_asland_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 652
Rx&=asl(Rs,Rt)                      Word32 Q6_R_asland_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  666
Rx+=asl(Rs,#u5)                     Word32 Q6_R_aslacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 648
Rx+=asl(Rs,Rt)                      Word32 Q6_R_aslacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  662
Rx=add(#u8,asl(Rx,#U5))             Word32 Q6_R_add_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              648
Rx=and(#u8,asl(Rx,#U5))             Word32 Q6_R_and_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              652
Rx-=asl(Rs,#u5)                     Word32 Q6_R_aslnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 648
Rx-=asl(Rs,Rt)                      Word32 Q6_R_aslnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  662
Rx=or(#u8,asl(Rx,#U5))              Word32 Q6_R_or_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)               652
Rx=sub(#u8,asl(Rx,#U5))             Word32 Q6_R_sub_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              648
Rx|=asl(Rs,#u5)                     Word32 Q6_R_aslor_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                  652
Rx|=asl(Rs,Rt)                      Word32 Q6_R_aslor_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   666
Rxx^=asl(Rss,#u6)                   Word64 Q6_P_aslxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              653
Rxx^=asl(Rss,Rt)                    Word64 Q6_P_aslxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               666
Rxx&=asl(Rss,#u6)                   Word64 Q6_P_asland_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               652
Rxx&=asl(Rss,Rt)                    Word64 Q6_P_asland_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                666
Rxx+=asl(Rss,#u6)                   Word64 Q6_P_aslacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx+=asl(Rss,Rt)                    Word64 Q6_P_aslacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                662
Rxx-=asl(Rss,#u6)                   Word64 Q6_P_aslnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx-=asl(Rss,Rt)                    Word64 Q6_P_aslnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                663
Rxx|=asl(Rss,#u6)                   Word64 Q6_P_aslor_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)                653
Rxx|=asl(Rss,Rt)                    Word64 Q6_P_aslor_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                 666

aslh
Rd=aslh(Rs)                         Word32 Q6_R_aslh_R(Word32 Rs)                                           193



80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   700
Hexagon V62 Programmer's Reference Manual                                                      Intrinsics Index



asr
Rd=asr(Rs,#u5)                     Word32 Q6_R_asr_RI(Word32 Rs, Word32 Iu5)                              646
Rd=asr(Rs,#u5):rnd                 Word32 Q6_R_asr_RI_rnd(Word32 Rs, Word32 Iu5)                          656
Rd=asr(Rs,Rt)                      Word32 Q6_R_asr_RR(Word32 Rs, Word32 Rt)                               659
Rd=asr(Rs,Rt):sat                  Word32 Q6_R_asr_RR_sat(Word32 Rs, Word32 Rt)                           668
Rdd=asr(Rss,#u6)                   Word64 Q6_P_asr_PI(Word64 Rss, Word32 Iu6)                             646
Rdd=asr(Rss,#u6):rnd               Word64 Q6_P_asr_PI_rnd(Word64 Rss, Word32 Iu6)                         656
Rdd=asr(Rss,Rt)                    Word64 Q6_P_asr_PR(Word64 Rss, Word32 Rt)                              659
Rx&=asr(Rs,#u5)                    Word32 Q6_R_asrand_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                652
Rx&=asr(Rs,Rt)                     Word32 Q6_R_asrand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 666
Rx+=asr(Rs,#u5)                    Word32 Q6_R_asracc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                648
Rx+=asr(Rs,Rt)                     Word32 Q6_R_asracc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 662
Rx-=asr(Rs,#u5)                    Word32 Q6_R_asrnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                648
Rx-=asr(Rs,Rt)                     Word32 Q6_R_asrnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 662
Rx|=asr(Rs,#u5)                    Word32 Q6_R_asror_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 652
Rx|=asr(Rs,Rt)                     Word32 Q6_R_asror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  666
Rxx^=asr(Rss,Rt)                   Word64 Q6_P_asrxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)              666
Rxx&=asr(Rss,#u6)                  Word64 Q6_P_asrand_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              653
Rxx&=asr(Rss,Rt)                   Word64 Q6_P_asrand_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               666
Rxx+=asr(Rss,#u6)                  Word64 Q6_P_asracc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              648
Rxx+=asr(Rss,Rt)                   Word64 Q6_P_asracc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               662
Rxx-=asr(Rss,#u6)                  Word64 Q6_P_asrnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              648
Rxx-=asr(Rss,Rt)                   Word64 Q6_P_asrnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               663
Rxx|=asr(Rss,#u6)                  Word64 Q6_P_asror_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               653
Rxx|=asr(Rss,Rt)                   Word64 Q6_P_asror_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                666

asrh
Rd=asrh(Rs)                        Word32 Q6_R_asrh_R(Word32 Rs)                                          193

asrrnd
Rd=asrrnd(Rs,#u5)                  Word32 Q6_R_asrrnd_RI(Word32 Rs, Word32 Iu5)                           656
Rdd=asrrnd(Rss,#u6)                Word64 Q6_P_asrrnd_PI(Word64 Rss, Word32 Iu6)                          656

B
bitsclr
Pd=!bitsclr(Rs,#u6)                Byte Q6_p_not_bitsclr_RI(Word32 Rs, Word32 Iu6)                        630
Pd=!bitsclr(Rs,Rt)                 Byte Q6_p_not_bitsclr_RR(Word32 Rs, Word32 Rt)                         630
Pd=bitsclr(Rs,#u6)                 Byte Q6_p_bitsclr_RI(Word32 Rs, Word32 Iu6)                            630
Pd=bitsclr(Rs,Rt)                  Byte Q6_p_bitsclr_RR(Word32 Rs, Word32 Rt)                             630

bitsplit
Rdd=bitsplit(Rs,#u5)               Word64 Q6_P_bitsplit_RI(Word32 Rs, Word32 Iu5)                         478
Rdd=bitsplit(Rs,Rt)                Word64 Q6_P_bitsplit_RR(Word32 Rs, Word32 Rt)                          478

bitsset
Pd=!bitsset(Rs,Rt)                 Byte Q6_p_not_bitsset_RR(Word32 Rs, Word32 Rt)                         630
Pd=bitsset(Rs,Rt)                  Byte Q6_p_bitsset_RR(Word32 Rs, Word32 Rt)                             630

boundscheck
Pd=boundscheck(Rs,Rtt)             Byte Q6_p_boundscheck_RP(Word32 Rs, Word64 Rtt)                        623

brev
Rd=brev(Rs)                        Word32 Q6_R_brev_R(Word32 Rs)                                          475



80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  701
Hexagon V62 Programmer's Reference Manual                                                 Intrinsics Index


Rdd=brev(Rss)                    Word64 Q6_P_brev_P(Word64 Rss)                                      475

C
cl0
Rd=cl0(Rs)                       Word32 Q6_R_cl0_R(Word32 Rs)                                        463
Rd=cl0(Rss)                      Word32 Q6_R_cl0_P(Word64 Rss)                                       463

cl1
Rd=cl1(Rs)                       Word32 Q6_R_cl1_R(Word32 Rs)                                        463
Rd=cl1(Rss)                      Word32 Q6_R_cl1_P(Word64 Rss)                                       463

clb
Rd=add(clb(Rs),#s6)              Word32 Q6_R_add_clb_RI(Word32 Rs, Word32 Is6)                       463
Rd=add(clb(Rss),#s6)             Word32 Q6_R_add_clb_PI(Word64 Rss, Word32 Is6)                      463
Rd=clb(Rs)                       Word32 Q6_R_clb_R(Word32 Rs)                                        463
Rd=clb(Rss)                      Word32 Q6_R_clb_P(Word64 Rss)                                       463

clrbit
Rd=clrbit(Rs,#u5)                Word32 Q6_R_clrbit_RI(Word32 Rs, Word32 Iu5)                        476
Rd=clrbit(Rs,Rt)                 Word32 Q6_R_clrbit_RR(Word32 Rs, Word32 Rt)                         476

cmp.eq
Pd=!cmp.eq(Rs,#s10)              Byte Q6_p_not_cmp_eq_RI(Word32 Rs, Word32 Is10)                     209
Pd=!cmp.eq(Rs,Rt)                Byte Q6_p_not_cmp_eq_RR(Word32 Rs, Word32 Rt)                       209
Pd=cmp.eq(Rs,#s10)               Byte Q6_p_cmp_eq_RI(Word32 Rs, Word32 Is10)                         210
Pd=cmp.eq(Rs,Rt)                 Byte Q6_p_cmp_eq_RR(Word32 Rs, Word32 Rt)                           210
Pd=cmp.eq(Rss,Rtt)               Byte Q6_p_cmp_eq_PP(Word64 Rss, Word64 Rtt)                         629
Rd=!cmp.eq(Rs,#s8)               Word32 Q6_R_not_cmp_eq_RI(Word32 Rs, Word32 Is8)                    211
Rd=!cmp.eq(Rs,Rt)                Word32 Q6_R_not_cmp_eq_RR(Word32 Rs, Word32 Rt)                     211
Rd=cmp.eq(Rs,#s8)                Word32 Q6_R_cmp_eq_RI(Word32 Rs, Word32 Is8)                        211
Rd=cmp.eq(Rs,Rt)                 Word32 Q6_R_cmp_eq_RR(Word32 Rs, Word32 Rt)                         211

cmp.ge
Pd=cmp.ge(Rs,#s8)                Byte Q6_p_cmp_ge_RI(Word32 Rs, Word32 Is8)                          210

cmp.geu
Pd=cmp.geu(Rs,#u8)               Byte Q6_p_cmp_geu_RI(Word32 Rs, Word32 Iu8)                         210

cmp.gt
Pd=!cmp.gt(Rs,#s10)              Byte Q6_p_not_cmp_gt_RI(Word32 Rs, Word32 Is10)                     209
Pd=!cmp.gt(Rs,Rt)                Byte Q6_p_not_cmp_gt_RR(Word32 Rs, Word32 Rt)                       209
Pd=cmp.gt(Rs,#s10)               Byte Q6_p_cmp_gt_RI(Word32 Rs, Word32 Is10)                         210
Pd=cmp.gt(Rs,Rt)                 Byte Q6_p_cmp_gt_RR(Word32 Rs, Word32 Rt)                           210
Pd=cmp.gt(Rss,Rtt)               Byte Q6_p_cmp_gt_PP(Word64 Rss, Word64 Rtt)                         629

cmp.gtu
Pd=!cmp.gtu(Rs,#u9)              Byte Q6_p_not_cmp_gtu_RI(Word32 Rs, Word32 Iu9)                     209
Pd=!cmp.gtu(Rs,Rt)               Byte Q6_p_not_cmp_gtu_RR(Word32 Rs, Word32 Rt)                      209
Pd=cmp.gtu(Rs,#u9)               Byte Q6_p_cmp_gtu_RI(Word32 Rs, Word32 Iu9)                         210
Pd=cmp.gtu(Rs,Rt)                Byte Q6_p_cmp_gtu_RR(Word32 Rs, Word32 Rt)                          210
Pd=cmp.gtu(Rss,Rtt)              Byte Q6_p_cmp_gtu_PP(Word64 Rss, Word64 Rtt)                        629




80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               702
Hexagon V62 Programmer's Reference Manual                                                           Intrinsics Index



cmp.lt
Pd=cmp.lt(Rs,Rt)                     Byte Q6_p_cmp_lt_RR(Word32 Rs, Word32 Rt)                                 210

cmp.ltu
Pd=cmp.ltu(Rs,Rt)                    Byte Q6_p_cmp_ltu_RR(Word32 Rs, Word32 Rt)                                210

cmpb.eq
Pd=cmpb.eq(Rs,#u8)                   Byte Q6_p_cmpb_eq_RI(Word32 Rs, Word32 Iu8)                               625
Pd=cmpb.eq(Rs,Rt)                    Byte Q6_p_cmpb_eq_RR(Word32 Rs, Word32 Rt)                                625

cmpb.gt
Pd=cmpb.gt(Rs,#s8)                   Byte Q6_p_cmpb_gt_RI(Word32 Rs, Word32 Is8)                               625
Pd=cmpb.gt(Rs,Rt)                    Byte Q6_p_cmpb_gt_RR(Word32 Rs, Word32 Rt)                                625

cmpb.gtu
Pd=cmpb.gtu(Rs,#u7)                  Byte Q6_p_cmpb_gtu_RI(Word32 Rs, Word32 Iu7)                              625
Pd=cmpb.gtu(Rs,Rt)                   Byte Q6_p_cmpb_gtu_RR(Word32 Rs, Word32 Rt)                               625

cmph.eq
Pd=cmph.eq(Rs,#s8)                   Byte Q6_p_cmph_eq_RI(Word32 Rs, Word32 Is8)                               627
Pd=cmph.eq(Rs,Rt)                    Byte Q6_p_cmph_eq_RR(Word32 Rs, Word32 Rt)                                627

cmph.gt
Pd=cmph.gt(Rs,#s8)                   Byte Q6_p_cmph_gt_RI(Word32 Rs, Word32 Is8)                               627
Pd=cmph.gt(Rs,Rt)                    Byte Q6_p_cmph_gt_RR(Word32 Rs, Word32 Rt)                                627

cmph.gtu
Pd=cmph.gtu(Rs,#u7)                  Byte Q6_p_cmph_gtu_RI(Word32 Rs, Word32 Iu7)                              627
Pd=cmph.gtu(Rs,Rt)                   Byte Q6_p_cmph_gtu_RR(Word32 Rs, Word32 Rt)                               627

cmpy
Rd=cmpy(Rs,Rt):<<1:rnd:sat           Word32 Q6_R_cmpy_RR_s1_rnd_sat(Word32 Rs, Word32 Rt)                      494
Rd=cmpy(Rs,Rt):rnd:sat               Word32 Q6_R_cmpy_RR_rnd_sat(Word32 Rs, Word32 Rt)                         494
Rd=cmpy(Rs,Rt*):<<1:rnd:sat          Word32 Q6_R_cmpy_RR_conj_s1_rnd_sat(Word32 Rs, Word32 Rt)                 494
Rd=cmpy(Rs,Rt*):rnd:sat              Word32 Q6_R_cmpy_RR_conj_rnd_sat(Word32 Rs, Word32 Rt)                    494
Rdd=cmpy(Rs,Rt):<<1:sat              Word64 Q6_P_cmpy_RR_s1_sat(Word32 Rs, Word32 Rt)                          489
Rdd=cmpy(Rs,Rt):sat                  Word64 Q6_P_cmpy_RR_sat(Word32 Rs, Word32 Rt)                             489
Rdd=cmpy(Rs,Rt*):<<1:sat             Word64 Q6_P_cmpy_RR_conj_s1_sat(Word32 Rs, Word32 Rt)                     489
Rdd=cmpy(Rs,Rt*):sat                 Word64 Q6_P_cmpy_RR_conj_sat(Word32 Rs, Word32 Rt)                        489
Rxx+=cmpy(Rs,Rt):<<1:sat             Word64 Q6_P_cmpyacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)           489
Rxx+=cmpy(Rs,Rt):sat                 Word64 Q6_P_cmpyacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)              489
Rxx+=cmpy(Rs,Rt*):<<1:sat            Word64 Q6_P_cmpyacc_RR_conj_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)      489
Rxx+=cmpy(Rs,Rt*):sat                Word64 Q6_P_cmpyacc_RR_conj_sat(Word64 Rxx, Word32 Rs, Word32 Rt)         490
Rxx-=cmpy(Rs,Rt):<<1:sat             Word64 Q6_P_cmpynac_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)           490
Rxx-=cmpy(Rs,Rt):sat                 Word64 Q6_P_cmpynac_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)              490
Rxx-=cmpy(Rs,Rt*):<<1:sat            Word64 Q6_P_cmpynac_RR_conj_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)      490
Rxx-=cmpy(Rs,Rt*):sat                Word64 Q6_P_cmpynac_RR_conj_sat(Word64 Rxx, Word32 Rs, Word32 Rt)         490

cmpyi
Rdd=cmpyi(Rs,Rt)                     Word64 Q6_P_cmpyi_RR(Word32 Rs, Word32 Rt)                                492
Rxx+=cmpyi(Rs,Rt)                    Word64 Q6_P_cmpyiacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                 492

cmpyiwh
Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat       Word32 Q6_R_cmpyiwh_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)                  496



80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     703
Hexagon V62 Programmer's Reference Manual                                                          Intrinsics Index


Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat    Word32 Q6_R_cmpyiwh_PR_conj_s1_rnd_sat(Word64 Rss, Word32 Rt)              496

cmpyr
Rdd=cmpyr(Rs,Rt)                   Word64 Q6_P_cmpyr_RR(Word32 Rs, Word32 Rt)                                 492
Rxx+=cmpyr(Rs,Rt)                  Word64 Q6_P_cmpyracc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                  492

cmpyrwh
Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat     Word32 Q6_R_cmpyrwh_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)                   496
Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat    Word32 Q6_R_cmpyrwh_PR_conj_s1_rnd_sat(Word64 Rss, Word32 Rt)              496

combine
Rd=combine(Rt.H,Rs.H)              Word32 Q6_R_combine_RhRh(Word32 Rt, Word32 Rs)                             189
Rd=combine(Rt.H,Rs.L)              Word32 Q6_R_combine_RhRl(Word32 Rt, Word32 Rs)                             189
Rd=combine(Rt.L,Rs.H)              Word32 Q6_R_combine_RlRh(Word32 Rt, Word32 Rs)                             189
Rd=combine(Rt.L,Rs.L)              Word32 Q6_R_combine_RlRl(Word32 Rt, Word32 Rs)                             189
Rdd=combine(#s8,#S8)               Word64 Q6_P_combine_II(Word32 Is8, Word32 IS8)                             189
Rdd=combine(#s8,Rs)                Word64 Q6_P_combine_IR(Word32 Is8, Word32 Rs)                              189
Rdd=combine(Rs,#s8)                Word64 Q6_P_combine_RI(Word32 Rs, Word32 Is8)                              189
Rdd=combine(Rs,Rt)                 Word64 Q6_P_combine_RR(Word32 Rs, Word32 Rt)                               189

convert_d2df
Rdd=convert_d2df(Rss)              Word64 Q6_P_convert_d2df_P(Word64 Rss)                                     522

convert_d2sf
Rd=convert_d2sf(Rss)               Word32 Q6_R_convert_d2sf_P(Word64 Rss)                                     522

convert_df2d
Rdd=convert_df2d(Rss)              Word64 Q6_P_convert_df2d_P(Word64 Rss)                                     525
Rdd=convert_df2d(Rss):chop         Word64 Q6_P_convert_df2d_P_chop(Word64 Rss)                                525

convert_df2sf
Rd=convert_df2sf(Rss)              Word32 Q6_R_convert_df2sf_P(Word64 Rss)                                    521

convert_df2ud
Rdd=convert_df2ud(Rss)             Word64 Q6_P_convert_df2ud_P(Word64 Rss)                                    525
Rdd=convert_df2ud(Rss):chop        Word64 Q6_P_convert_df2ud_P_chop(Word64 Rss)                               525

convert_df2uw
Rd=convert_df2uw(Rss)              Word32 Q6_R_convert_df2uw_P(Word64 Rss)                                    525
Rd=convert_df2uw(Rss):chop         Word32 Q6_R_convert_df2uw_P_chop(Word64 Rss)                               525

convert_df2w
Rd=convert_df2w(Rss)               Word32 Q6_R_convert_df2w_P(Word64 Rss)                                     525
Rd=convert_df2w(Rss):chop          Word32 Q6_R_convert_df2w_P_chop(Word64 Rss)                                525

convert_sf2d
Rdd=convert_sf2d(Rs)               Word64 Q6_P_convert_sf2d_R(Word32 Rs)                                      525
Rdd=convert_sf2d(Rs):chop          Word64 Q6_P_convert_sf2d_R_chop(Word32 Rs)                                 525

convert_sf2df
Rdd=convert_sf2df(Rs)              Word64 Q6_P_convert_sf2df_R(Word32 Rs)                                     521

convert_sf2ud
Rdd=convert_sf2ud(Rs)              Word64 Q6_P_convert_sf2ud_R(Word32 Rs)                                     525



80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      704
Hexagon V62 Programmer's Reference Manual                                                     Intrinsics Index


Rdd=convert_sf2ud(Rs):chop           Word64 Q6_P_convert_sf2ud_R_chop(Word32 Rs)                         525

convert_sf2uw
Rd=convert_sf2uw(Rs)                 Word32 Q6_R_convert_sf2uw_R(Word32 Rs)                              525
Rd=convert_sf2uw(Rs):chop            Word32 Q6_R_convert_sf2uw_R_chop(Word32 Rs)                         525

convert_sf2w
Rd=convert_sf2w(Rs)                  Word32 Q6_R_convert_sf2w_R(Word32 Rs)                               525
Rd=convert_sf2w(Rs):chop             Word32 Q6_R_convert_sf2w_R_chop(Word32 Rs)                          525

convert_ud2df
Rdd=convert_ud2df(Rss)               Word64 Q6_P_convert_ud2df_P(Word64 Rss)                             522

convert_ud2sf
Rd=convert_ud2sf(Rss)                Word32 Q6_R_convert_ud2sf_P(Word64 Rss)                             522

convert_uw2df
Rdd=convert_uw2df(Rs)                Word64 Q6_P_convert_uw2df_R(Word32 Rs)                              522

convert_uw2sf
Rd=convert_uw2sf(Rs)                 Word32 Q6_R_convert_uw2sf_R(Word32 Rs)                              522

convert_w2df
Rdd=convert_w2df(Rs)                 Word64 Q6_P_convert_w2df_R(Word32 Rs)                               522

convert_w2sf
Rd=convert_w2sf(Rs)                  Word32 Q6_R_convert_w2sf_R(Word32 Rs)                               522

cround
Rd=cround(Rs,#u5)                    Word32 Q6_R_cround_RI(Word32 Rs, Word32 Iu5)                        409
Rd=cround(Rs,Rt)                     Word32 Q6_R_cround_RR(Word32 Rs, Word32 Rt)                         409

ct0
Rd=ct0(Rs)                           Word32 Q6_R_ct0_R(Word32 Rs)                                        466
Rd=ct0(Rss)                          Word32 Q6_R_ct0_P(Word64 Rss)                                       466

ct1
Rd=ct1(Rs)                           Word32 Q6_R_ct1_R(Word32 Rs)                                        466
Rd=ct1(Rss)                          Word32 Q6_R_ct1_P(Word64 Rss)                                       466

D
dcfetch
dcfetch(Rs)                          void Q6_dcfetch_A(Address a)                                        377

deinterleave
Rdd=deinterleave(Rss)                Word64 Q6_P_deinterleave_P(Word64 Rss)                              472

dfclass
Pd=dfclass(Rss,#u5)                  Byte Q6_p_dfclass_PI(Word64 Rss, Word32 Iu5)                        517

dfcmp.eq
Pd=dfcmp.eq(Rss,Rtt)                 Byte Q6_p_dfcmp_eq_PP(Word64 Rss, Word64 Rtt)                       519




80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               705
Hexagon V62 Programmer's Reference Manual                                                              Intrinsics Index



dfcmp.ge
Pd=dfcmp.ge(Rss,Rtt)                 Byte Q6_p_dfcmp_ge_PP(Word64 Rss, Word64 Rtt)                                519

dfcmp.gt
Pd=dfcmp.gt(Rss,Rtt)                 Byte Q6_p_dfcmp_gt_PP(Word64 Rss, Word64 Rtt)                                519

dfcmp.uo
Pd=dfcmp.uo(Rss,Rtt)                 Byte Q6_p_dfcmp_uo_PP(Word64 Rss, Word64 Rtt)                                519

dfmake
Rdd=dfmake(#u10):neg                 Word64 Q6_P_dfmake_I_neg(Word32 Iu10)                                        533
Rdd=dfmake(#u10):pos                 Word64 Q6_P_dfmake_I_pos(Word32 Iu10)                                        533

E
extract
Rd=extract(Rs,#u5,#U5)               Word32 Q6_R_extract_RII(Word32 Rs, Word32 Iu5, Word32 IU5)                   468
Rd=extract(Rs,Rtt)                   Word32 Q6_R_extract_RP(Word32 Rs, Word64 Rtt)                                468
Rdd=extract(Rss,#u6,#U6)             Word64 Q6_P_extract_PII(Word64 Rss, Word32 Iu6, Word32 IU6)                  469
Rdd=extract(Rss,Rtt)                 Word64 Q6_P_extract_PP(Word64 Rss, Word64 Rtt)                               469

extractu
Rd=extractu(Rs,#u5,#U5)              Word32 Q6_R_extractu_RII(Word32 Rs, Word32 Iu5, Word32 IU5)                  468
Rd=extractu(Rs,Rtt)                  Word32 Q6_R_extractu_RP(Word32 Rs, Word64 Rtt)                               469
Rdd=extractu(Rss,#u6,#U6)            Word64 Q6_P_extractu_PII(Word64 Rss, Word32 Iu6, Word32 IU6)                 469
Rdd=extractu(Rss,Rtt)                Word64 Q6_P_extractu_PP(Word64 Rss, Word64 Rtt)                              469

F
fastcorner9
Pd=!fastcorner9(Ps,Pt)               Byte Q6_p_not_fastcorner9_pp(Byte Ps, Byte Pt)                               214
Pd=fastcorner9(Ps,Pt)                Byte Q6_p_fastcorner9_pp(Byte Ps, Byte Pt)                                   214

I
insert
Rx=insert(Rs,#u5,#U5)                Word32 Q6_R_insert_RII(Word32 Rx, Word32 Rs, Word32 Iu5, Word32 IU5)         471
Rx=insert(Rs,Rtt)                    Word32 Q6_R_insert_RP(Word32 Rx, Word32 Rs, Word64 Rtt)                      471
Rxx=insert(Rss,#u6,#U6)              Word64 Q6_P_insert_PII(Word64 Rxx, Word64 Rss, Word32 Iu6, Word32 IU6)       471
Rxx=insert(Rss,Rtt)                  Word64 Q6_P_insert_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                    471

interleave
Rdd=interleave(Rss)                  Word64 Q6_P_interleave_P(Word64 Rss)                                         472

L
lfs
Rdd=lfs(Rss,Rtt)                     Word64 Q6_P_lfs_PP(Word64 Rss, Word64 Rtt)                                   473

lsl
Rd=lsl(#s6,Rt)                       Word32 Q6_R_lsl_IR(Word32 Is6, Word32 Rt)                                    659
Rd=lsl(Rs,Rt)                        Word32 Q6_R_lsl_RR(Word32 Rs, Word32 Rt)                                     659
Rdd=lsl(Rss,Rt)                      Word64 Q6_P_lsl_PR(Word64 Rss, Word32 Rt)                                    659
Rx&=lsl(Rs,Rt)                       Word32 Q6_R_lsland_RR(Word32 Rx, Word32 Rs, Word32 Rt)                       666
Rx+=lsl(Rs,Rt)                       Word32 Q6_R_lslacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                       662




80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        706
Hexagon V62 Programmer's Reference Manual                                                        Intrinsics Index


Rx-=lsl(Rs,Rt)                      Word32 Q6_R_lslnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  662
Rx|=lsl(Rs,Rt)                      Word32 Q6_R_lslor_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   666
Rxx^=lsl(Rss,Rt)                    Word64 Q6_P_lslxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               666
Rxx&=lsl(Rss,Rt)                    Word64 Q6_P_lsland_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                666
Rxx+=lsl(Rss,Rt)                    Word64 Q6_P_lslacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                662
Rxx-=lsl(Rss,Rt)                    Word64 Q6_P_lslnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                663
Rxx|=lsl(Rss,Rt)                    Word64 Q6_P_lslor_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                 666

lsr
Rd=lsr(Rs,#u5)                      Word32 Q6_R_lsr_RI(Word32 Rs, Word32 Iu5)                               646
Rd=lsr(Rs,Rt)                       Word32 Q6_R_lsr_RR(Word32 Rs, Word32 Rt)                                659
Rdd=lsr(Rss,#u6)                    Word64 Q6_P_lsr_PI(Word64 Rss, Word32 Iu6)                              646
Rdd=lsr(Rss,Rt)                     Word64 Q6_P_lsr_PR(Word64 Rss, Word32 Rt)                               659
Rx^=lsr(Rs,#u5)                     Word32 Q6_R_lsrxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                652
Rx&=lsr(Rs,#u5)                     Word32 Q6_R_lsrand_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 652
Rx&=lsr(Rs,Rt)                      Word32 Q6_R_lsrand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  666
Rx+=lsr(Rs,#u5)                     Word32 Q6_R_lsracc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 648
Rx+=lsr(Rs,Rt)                      Word32 Q6_R_lsracc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  662
Rx=add(#u8,lsr(Rx,#U5))             Word32 Q6_R_add_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              648
Rx=and(#u8,lsr(Rx,#U5))             Word32 Q6_R_and_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              652
Rx-=lsr(Rs,#u5)                     Word32 Q6_R_lsrnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 648
Rx-=lsr(Rs,Rt)                      Word32 Q6_R_lsrnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  662
Rx=or(#u8,lsr(Rx,#U5))              Word32 Q6_R_or_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)               652
Rx=sub(#u8,lsr(Rx,#U5))             Word32 Q6_R_sub_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              648
Rx|=lsr(Rs,#u5)                     Word32 Q6_R_lsror_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                  652
Rx|=lsr(Rs,Rt)                      Word32 Q6_R_lsror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   666
Rxx^=lsr(Rss,#u6)                   Word64 Q6_P_lsrxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              653
Rxx^=lsr(Rss,Rt)                    Word64 Q6_P_lsrxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               666
Rxx&=lsr(Rss,#u6)                   Word64 Q6_P_lsrand_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               653
Rxx&=lsr(Rss,Rt)                    Word64 Q6_P_lsrand_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                666
Rxx+=lsr(Rss,#u6)                   Word64 Q6_P_lsracc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx+=lsr(Rss,Rt)                    Word64 Q6_P_lsracc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                663
Rxx-=lsr(Rss,#u6)                   Word64 Q6_P_lsrnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx-=lsr(Rss,Rt)                    Word64 Q6_P_lsrnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                663
Rxx|=lsr(Rss,#u6)                   Word64 Q6_P_lsror_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)                653
Rxx|=lsr(Rss,Rt)                    Word64 Q6_P_lsror_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                 666

M
mask
Rdd=mask(Pt)                        Word64 Q6_P_mask_p(Byte Pt)                                             632

max
Rd=max(Rs,Rt)                       Word32 Q6_R_max_RR(Word32 Rs, Word32 Rt)                                403
Rdd=max(Rss,Rtt)                    Word64 Q6_P_max_PP(Word64 Rss, Word64 Rtt)                              404

maxu
Rd=maxu(Rs,Rt)                      UWord32 Q6_R_maxu_RR(Word32 Rs, Word32 Rt)                              403
Rdd=maxu(Rss,Rtt)                   UWord64 Q6_P_maxu_PP(Word64 Rss, Word64 Rtt)                            404

min
Rd=min(Rt,Rs)                       Word32 Q6_R_min_RR(Word32 Rt, Word32 Rs)                                405
Rdd=min(Rtt,Rss)                    Word64 Q6_P_min_PP(Word64 Rtt, Word64 Rss)                              406




80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   707
Hexagon V62 Programmer's Reference Manual                                                      Intrinsics Index



minu
Rd=minu(Rt,Rs)                        UWord32 Q6_R_minu_RR(Word32 Rt, Word32 Rs)                          405
Rdd=minu(Rtt,Rss)                     UWord64 Q6_P_minu_PP(Word64 Rtt, Word64 Rss)                        406

modwrap
Rd=modwrap(Rs,Rt)                     Word32 Q6_R_modwrap_RR(Word32 Rs, Word32 Rt)                        407

mpy
Rd=mpy(Rs,Rt.H):<<1:rnd:sat           Word32 Q6_R_mpy_RRh_s1_rnd_sat(Word32 Rs, Word32 Rt)                568
Rd=mpy(Rs,Rt.H):<<1:sat               Word32 Q6_R_mpy_RRh_s1_sat(Word32 Rs, Word32 Rt)                    568
Rd=mpy(Rs,Rt.L):<<1:rnd:sat           Word32 Q6_R_mpy_RRl_s1_rnd_sat(Word32 Rs, Word32 Rt)                568
Rd=mpy(Rs,Rt.L):<<1:sat               Word32 Q6_R_mpy_RRl_s1_sat(Word32 Rs, Word32 Rt)                    568
Rd=mpy(Rs,Rt)                         Word32 Q6_R_mpy_RR(Word32 Rs, Word32 Rt)                            568
Rd=mpy(Rs,Rt):<<1                     Word32 Q6_R_mpy_RR_s1(Word32 Rs, Word32 Rt)                         568
Rd=mpy(Rs,Rt):<<1:sat                 Word32 Q6_R_mpy_RR_s1_sat(Word32 Rs, Word32 Rt)                     568
Rd=mpy(Rs,Rt):rnd                     Word32 Q6_R_mpy_RR_rnd(Word32 Rs, Word32 Rt)                        568
Rd=mpy(Rs.H,Rt.H)                     Word32 Q6_R_mpy_RhRh(Word32 Rs, Word32 Rt)                          551
Rd=mpy(Rs.H,Rt.H):<<1                 Word32 Q6_R_mpy_RhRh_s1(Word32 Rs, Word32 Rt)                       551
Rd=mpy(Rs.H,Rt.H):<<1:rnd             Word32 Q6_R_mpy_RhRh_s1_rnd(Word32 Rs, Word32 Rt)                   551
Rd=mpy(Rs.H,Rt.H):<<1:rnd:sat         Word32 Q6_R_mpy_RhRh_s1_rnd_sat(Word32 Rs, Word32 Rt)               551
Rd=mpy(Rs.H,Rt.H):<<1:sat             Word32 Q6_R_mpy_RhRh_s1_sat(Word32 Rs, Word32 Rt)                   551
Rd=mpy(Rs.H,Rt.H):rnd                 Word32 Q6_R_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)                      551
Rd=mpy(Rs.H,Rt.H):rnd:sat             Word32 Q6_R_mpy_RhRh_rnd_sat(Word32 Rs, Word32 Rt)                  551
Rd=mpy(Rs.H,Rt.H):sat                 Word32 Q6_R_mpy_RhRh_sat(Word32 Rs, Word32 Rt)                      551
Rd=mpy(Rs.H,Rt.L)                     Word32 Q6_R_mpy_RhRl(Word32 Rs, Word32 Rt)                          551
Rd=mpy(Rs.H,Rt.L):<<1                 Word32 Q6_R_mpy_RhRl_s1(Word32 Rs, Word32 Rt)                       551
Rd=mpy(Rs.H,Rt.L):<<1:rnd             Word32 Q6_R_mpy_RhRl_s1_rnd(Word32 Rs, Word32 Rt)                   551
Rd=mpy(Rs.H,Rt.L):<<1:rnd:sat         Word32 Q6_R_mpy_RhRl_s1_rnd_sat(Word32 Rs, Word32 Rt)               551
Rd=mpy(Rs.H,Rt.L):<<1:sat             Word32 Q6_R_mpy_RhRl_s1_sat(Word32 Rs, Word32 Rt)                   551
Rd=mpy(Rs.H,Rt.L):rnd                 Word32 Q6_R_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)                      551
Rd=mpy(Rs.H,Rt.L):rnd:sat             Word32 Q6_R_mpy_RhRl_rnd_sat(Word32 Rs, Word32 Rt)                  551
Rd=mpy(Rs.H,Rt.L):sat                 Word32 Q6_R_mpy_RhRl_sat(Word32 Rs, Word32 Rt)                      551
Rd=mpy(Rs.L,Rt.H)                     Word32 Q6_R_mpy_RlRh(Word32 Rs, Word32 Rt)                          551
Rd=mpy(Rs.L,Rt.H):<<1                 Word32 Q6_R_mpy_RlRh_s1(Word32 Rs, Word32 Rt)                       551
Rd=mpy(Rs.L,Rt.H):<<1:rnd             Word32 Q6_R_mpy_RlRh_s1_rnd(Word32 Rs, Word32 Rt)                   551
Rd=mpy(Rs.L,Rt.H):<<1:rnd:sat         Word32 Q6_R_mpy_RlRh_s1_rnd_sat(Word32 Rs, Word32 Rt)               551
Rd=mpy(Rs.L,Rt.H):<<1:sat             Word32 Q6_R_mpy_RlRh_s1_sat(Word32 Rs, Word32 Rt)                   552
Rd=mpy(Rs.L,Rt.H):rnd                 Word32 Q6_R_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)                      552
Rd=mpy(Rs.L,Rt.H):rnd:sat             Word32 Q6_R_mpy_RlRh_rnd_sat(Word32 Rs, Word32 Rt)                  552
Rd=mpy(Rs.L,Rt.H):sat                 Word32 Q6_R_mpy_RlRh_sat(Word32 Rs, Word32 Rt)                      552
Rd=mpy(Rs.L,Rt.L)                     Word32 Q6_R_mpy_RlRl(Word32 Rs, Word32 Rt)                          552
Rd=mpy(Rs.L,Rt.L):<<1                 Word32 Q6_R_mpy_RlRl_s1(Word32 Rs, Word32 Rt)                       552
Rd=mpy(Rs.L,Rt.L):<<1:rnd             Word32 Q6_R_mpy_RlRl_s1_rnd(Word32 Rs, Word32 Rt)                   552
Rd=mpy(Rs.L,Rt.L):<<1:rnd:sat         Word32 Q6_R_mpy_RlRl_s1_rnd_sat(Word32 Rs, Word32 Rt)               552
Rd=mpy(Rs.L,Rt.L):<<1:sat             Word32 Q6_R_mpy_RlRl_s1_sat(Word32 Rs, Word32 Rt)                   552
Rd=mpy(Rs.L,Rt.L):rnd                 Word32 Q6_R_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)                      552
Rd=mpy(Rs.L,Rt.L):rnd:sat             Word32 Q6_R_mpy_RlRl_rnd_sat(Word32 Rs, Word32 Rt)                  552
Rd=mpy(Rs.L,Rt.L):sat                 Word32 Q6_R_mpy_RlRl_sat(Word32 Rs, Word32 Rt)                      552
Rdd=mpy(Rs,Rt)                        Word64 Q6_P_mpy_RR(Word32 Rs, Word32 Rt)                            570
Rdd=mpy(Rs.H,Rt.H)                    Word64 Q6_P_mpy_RhRh(Word32 Rs, Word32 Rt)                          552
Rdd=mpy(Rs.H,Rt.H):<<1                Word64 Q6_P_mpy_RhRh_s1(Word32 Rs, Word32 Rt)                       552
Rdd=mpy(Rs.H,Rt.H):<<1:rnd            Word64 Q6_P_mpy_RhRh_s1_rnd(Word32 Rs, Word32 Rt)                   552
Rdd=mpy(Rs.H,Rt.H):rnd                Word64 Q6_P_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)                      552
Rdd=mpy(Rs.H,Rt.L)                    Word64 Q6_P_mpy_RhRl(Word32 Rs, Word32 Rt)                          552



80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               708
Hexagon V62 Programmer's Reference Manual                                                             Intrinsics Index


Rdd=mpy(Rs.H,Rt.L):<<1              Word64 Q6_P_mpy_RhRl_s1(Word32 Rs, Word32 Rt)                                552
Rdd=mpy(Rs.H,Rt.L):<<1:rnd          Word64 Q6_P_mpy_RhRl_s1_rnd(Word32 Rs, Word32 Rt)                            552
Rdd=mpy(Rs.H,Rt.L):rnd              Word64 Q6_P_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)                               552
Rdd=mpy(Rs.L,Rt.H)                  Word64 Q6_P_mpy_RlRh(Word32 Rs, Word32 Rt)                                   552
Rdd=mpy(Rs.L,Rt.H):<<1              Word64 Q6_P_mpy_RlRh_s1(Word32 Rs, Word32 Rt)                                552
Rdd=mpy(Rs.L,Rt.H):<<1:rnd          Word64 Q6_P_mpy_RlRh_s1_rnd(Word32 Rs, Word32 Rt)                            552
Rdd=mpy(Rs.L,Rt.H):rnd              Word64 Q6_P_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)                               552
Rdd=mpy(Rs.L,Rt.L)                  Word64 Q6_P_mpy_RlRl(Word32 Rs, Word32 Rt)                                   552
Rdd=mpy(Rs.L,Rt.L):<<1              Word64 Q6_P_mpy_RlRl_s1(Word32 Rs, Word32 Rt)                                553
Rdd=mpy(Rs.L,Rt.L):<<1:rnd          Word64 Q6_P_mpy_RlRl_s1_rnd(Word32 Rs, Word32 Rt)                            553
Rdd=mpy(Rs.L,Rt.L):rnd              Word64 Q6_P_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)                               553
Rx+=mpy(Rs,Rt):<<1:sat              Word32 Q6_R_mpyacc_RR_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)                568
Rx+=mpy(Rs.H,Rt.H)                  Word32 Q6_R_mpyacc_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx+=mpy(Rs.H,Rt.H):<<1              Word32 Q6_R_mpyacc_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx+=mpy(Rs.H,Rt.H):<<1:sat          Word32 Q6_R_mpyacc_RhRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx+=mpy(Rs.H,Rt.H):sat              Word32 Q6_R_mpyacc_RhRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rx+=mpy(Rs.H,Rt.L)                  Word32 Q6_R_mpyacc_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx+=mpy(Rs.H,Rt.L):<<1              Word32 Q6_R_mpyacc_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx+=mpy(Rs.H,Rt.L):<<1:sat          Word32 Q6_R_mpyacc_RhRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx+=mpy(Rs.H,Rt.L):sat              Word32 Q6_R_mpyacc_RhRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rx+=mpy(Rs.L,Rt.H)                  Word32 Q6_R_mpyacc_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx+=mpy(Rs.L,Rt.H):<<1              Word32 Q6_R_mpyacc_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx+=mpy(Rs.L,Rt.H):<<1:sat          Word32 Q6_R_mpyacc_RlRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx+=mpy(Rs.L,Rt.H):sat              Word32 Q6_R_mpyacc_RlRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rx+=mpy(Rs.L,Rt.L)                  Word32 Q6_R_mpyacc_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx+=mpy(Rs.L,Rt.L):<<1              Word32 Q6_R_mpyacc_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx+=mpy(Rs.L,Rt.L):<<1:sat          Word32 Q6_R_mpyacc_RlRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx+=mpy(Rs.L,Rt.L):sat              Word32 Q6_R_mpyacc_RlRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rx-=mpy(Rs,Rt):<<1:sat              Word32 Q6_R_mpynac_RR_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)                568
Rx-=mpy(Rs.H,Rt.H)                  Word32 Q6_R_mpynac_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx-=mpy(Rs.H,Rt.H):<<1              Word32 Q6_R_mpynac_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx-=mpy(Rs.H,Rt.H):<<1:sat          Word32 Q6_R_mpynac_RhRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx-=mpy(Rs.H,Rt.H):sat              Word32 Q6_R_mpynac_RhRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rx-=mpy(Rs.H,Rt.L)                  Word32 Q6_R_mpynac_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx-=mpy(Rs.H,Rt.L):<<1              Word32 Q6_R_mpynac_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  554
Rx-=mpy(Rs.H,Rt.L):<<1:sat          Word32 Q6_R_mpynac_RhRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              554
Rx-=mpy(Rs.H,Rt.L):sat              Word32 Q6_R_mpynac_RhRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 554
Rx-=mpy(Rs.L,Rt.H)                  Word32 Q6_R_mpynac_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                     554
Rx-=mpy(Rs.L,Rt.H):<<1              Word32 Q6_R_mpynac_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  554
Rx-=mpy(Rs.L,Rt.H):<<1:sat          Word32 Q6_R_mpynac_RlRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              554
Rx-=mpy(Rs.L,Rt.H):sat              Word32 Q6_R_mpynac_RlRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 554
Rx-=mpy(Rs.L,Rt.L)                  Word32 Q6_R_mpynac_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                     554
Rx-=mpy(Rs.L,Rt.L):<<1              Word32 Q6_R_mpynac_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  554
Rx-=mpy(Rs.L,Rt.L):<<1:sat          Word32 Q6_R_mpynac_RlRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              554
Rx-=mpy(Rs.L,Rt.L):sat              Word32 Q6_R_mpynac_RlRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 554
Rxx+=mpy(Rs,Rt)                     Word64 Q6_P_mpyacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                      570
Rxx+=mpy(Rs.H,Rt.H)                 Word64 Q6_P_mpyacc_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                    554
Rxx+=mpy(Rs.H,Rt.H):<<1             Word64 Q6_P_mpyacc_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)                 554
Rxx+=mpy(Rs.H,Rt.L)                 Word64 Q6_P_mpyacc_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                    554
Rxx+=mpy(Rs.H,Rt.L):<<1             Word64 Q6_P_mpyacc_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)                 554
Rxx+=mpy(Rs.L,Rt.H)                 Word64 Q6_P_mpyacc_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                    554
Rxx+=mpy(Rs.L,Rt.H):<<1             Word64 Q6_P_mpyacc_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)                 554
Rxx+=mpy(Rs.L,Rt.L)                 Word64 Q6_P_mpyacc_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                    554
Rxx+=mpy(Rs.L,Rt.L):<<1             Word64 Q6_P_mpyacc_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)                 554



80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        709
Hexagon V62 Programmer's Reference Manual                                                          Intrinsics Index


Rxx-=mpy(Rs,Rt)                     Word64 Q6_P_mpynac_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                   570
Rxx-=mpy(Rs.H,Rt.H)                 Word64 Q6_P_mpynac_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 554
Rxx-=mpy(Rs.H,Rt.H):<<1             Word64 Q6_P_mpynac_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              554
Rxx-=mpy(Rs.H,Rt.L)                 Word64 Q6_P_mpynac_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 554
Rxx-=mpy(Rs.H,Rt.L):<<1             Word64 Q6_P_mpynac_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              555
Rxx-=mpy(Rs.L,Rt.H)                 Word64 Q6_P_mpynac_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 555
Rxx-=mpy(Rs.L,Rt.H):<<1             Word64 Q6_P_mpynac_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              555
Rxx-=mpy(Rs.L,Rt.L)                 Word64 Q6_P_mpynac_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 555
Rxx-=mpy(Rs.L,Rt.L):<<1             Word64 Q6_P_mpynac_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              555

mpyi
Rd=mpyi(Rs,#m9)                     Word32 Q6_R_mpyi_RI(Word32 Rs, Word32 Im9)                                540
Rd=mpyi(Rs,Rt)                      Word32 Q6_R_mpyi_RR(Word32 Rs, Word32 Rt)                                 540
Rx+=mpyi(Rs,#u8)                    Word32 Q6_R_mpyiacc_RI(Word32 Rx, Word32 Rs, Word32 Iu8)                  540
Rx+=mpyi(Rs,Rt)                     Word32 Q6_R_mpyiacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   540
Rx-=mpyi(Rs,#u8)                    Word32 Q6_R_mpyinac_RI(Word32 Rx, Word32 Rs, Word32 Iu8)                  540

mpysu
Rd=mpysu(Rs,Rt)                     Word32 Q6_R_mpysu_RR(Word32 Rs, Word32 Rt)                                568

mpyu
Rd=mpyu(Rs,Rt)                      UWord32 Q6_R_mpyu_RR(Word32 Rs, Word32 Rt)                                568
Rd=mpyu(Rs.H,Rt.H)                  UWord32 Q6_R_mpyu_RhRh(Word32 Rs, Word32 Rt)                              559
Rd=mpyu(Rs.H,Rt.H):<<1              UWord32 Q6_R_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)                           559
Rd=mpyu(Rs.H,Rt.L)                  UWord32 Q6_R_mpyu_RhRl(Word32 Rs, Word32 Rt)                              559
Rd=mpyu(Rs.H,Rt.L):<<1              UWord32 Q6_R_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)                           559
Rd=mpyu(Rs.L,Rt.H)                  UWord32 Q6_R_mpyu_RlRh(Word32 Rs, Word32 Rt)                              559
Rd=mpyu(Rs.L,Rt.H):<<1              UWord32 Q6_R_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)                           559
Rd=mpyu(Rs.L,Rt.L)                  UWord32 Q6_R_mpyu_RlRl(Word32 Rs, Word32 Rt)                              559
Rd=mpyu(Rs.L,Rt.L):<<1              UWord32 Q6_R_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)                           559
Rdd=mpyu(Rs,Rt)                     UWord64 Q6_P_mpyu_RR(Word32 Rs, Word32 Rt)                                570
Rdd=mpyu(Rs.H,Rt.H)                 UWord64 Q6_P_mpyu_RhRh(Word32 Rs, Word32 Rt)                              559
Rdd=mpyu(Rs.H,Rt.H):<<1             UWord64 Q6_P_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)                           559
Rdd=mpyu(Rs.H,Rt.L)                 UWord64 Q6_P_mpyu_RhRl(Word32 Rs, Word32 Rt)                              559
Rdd=mpyu(Rs.H,Rt.L):<<1             UWord64 Q6_P_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)                           559
Rdd=mpyu(Rs.L,Rt.H)                 UWord64 Q6_P_mpyu_RlRh(Word32 Rs, Word32 Rt)                              559
Rdd=mpyu(Rs.L,Rt.H):<<1             UWord64 Q6_P_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)                           559
Rdd=mpyu(Rs.L,Rt.L)                 UWord64 Q6_P_mpyu_RlRl(Word32 Rs, Word32 Rt)                              559
Rdd=mpyu(Rs.L,Rt.L):<<1             UWord64 Q6_P_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)                           559
Rx+=mpyu(Rs.H,Rt.H)                 Word32 Q6_R_mpyuacc_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                 559
Rx+=mpyu(Rs.H,Rt.H):<<1             Word32 Q6_R_mpyuacc_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)              559
Rx+=mpyu(Rs.H,Rt.L)                 Word32 Q6_R_mpyuacc_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                 559
Rx+=mpyu(Rs.H,Rt.L):<<1             Word32 Q6_R_mpyuacc_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)              559
Rx+=mpyu(Rs.L,Rt.H)                 Word32 Q6_R_mpyuacc_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                 559
Rx+=mpyu(Rs.L,Rt.H):<<1             Word32 Q6_R_mpyuacc_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)              560
Rx+=mpyu(Rs.L,Rt.L)                 Word32 Q6_R_mpyuacc_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                 560
Rx+=mpyu(Rs.L,Rt.L):<<1             Word32 Q6_R_mpyuacc_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)              560
Rx-=mpyu(Rs.H,Rt.H)                 Word32 Q6_R_mpyunac_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                 560
Rx-=mpyu(Rs.H,Rt.H):<<1             Word32 Q6_R_mpyunac_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)              560
Rx-=mpyu(Rs.H,Rt.L)                 Word32 Q6_R_mpyunac_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                 560
Rx-=mpyu(Rs.H,Rt.L):<<1             Word32 Q6_R_mpyunac_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)              560
Rx-=mpyu(Rs.L,Rt.H)                 Word32 Q6_R_mpyunac_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                 560
Rx-=mpyu(Rs.L,Rt.H):<<1             Word32 Q6_R_mpyunac_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)              560
Rx-=mpyu(Rs.L,Rt.L)                 Word32 Q6_R_mpyunac_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                 560



80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     710
Hexagon V62 Programmer's Reference Manual                                                            Intrinsics Index


Rx-=mpyu(Rs.L,Rt.L):<<1              Word32 Q6_R_mpyunac_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)               560
Rxx+=mpyu(Rs,Rt)                     Word64 Q6_P_mpyuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                   570
Rxx+=mpyu(Rs.H,Rt.H)                 Word64 Q6_P_mpyuacc_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 560
Rxx+=mpyu(Rs.H,Rt.H):<<1             Word64 Q6_P_mpyuacc_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              560
Rxx+=mpyu(Rs.H,Rt.L)                 Word64 Q6_P_mpyuacc_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 560
Rxx+=mpyu(Rs.H,Rt.L):<<1             Word64 Q6_P_mpyuacc_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              560
Rxx+=mpyu(Rs.L,Rt.H)                 Word64 Q6_P_mpyuacc_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 560
Rxx+=mpyu(Rs.L,Rt.H):<<1             Word64 Q6_P_mpyuacc_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              560
Rxx+=mpyu(Rs.L,Rt.L)                 Word64 Q6_P_mpyuacc_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 560
Rxx+=mpyu(Rs.L,Rt.L):<<1             Word64 Q6_P_mpyuacc_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              560
Rxx-=mpyu(Rs,Rt)                     Word64 Q6_P_mpyunac_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                   570
Rxx-=mpyu(Rs.H,Rt.H)                 Word64 Q6_P_mpyunac_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 560
Rxx-=mpyu(Rs.H,Rt.H):<<1             Word64 Q6_P_mpyunac_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              560
Rxx-=mpyu(Rs.H,Rt.L)                 Word64 Q6_P_mpyunac_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 560
Rxx-=mpyu(Rs.H,Rt.L):<<1             Word64 Q6_P_mpyunac_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              561
Rxx-=mpyu(Rs.L,Rt.H)                 Word64 Q6_P_mpyunac_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 561
Rxx-=mpyu(Rs.L,Rt.H):<<1             Word64 Q6_P_mpyunac_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              561
Rxx-=mpyu(Rs.L,Rt.L)                 Word64 Q6_P_mpyunac_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 561
Rxx-=mpyu(Rs.L,Rt.L):<<1             Word64 Q6_P_mpyunac_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              561

mpyui
Rd=mpyui(Rs,Rt)                      Word32 Q6_R_mpyui_RR(Word32 Rs, Word32 Rt)                                 540

mux
Rd=mux(Pu,#s8,#S8)                   Word32 Q6_R_mux_pII(Byte Pu, Word32 Is8, Word32 IS8)                       191
Rd=mux(Pu,#s8,Rs)                    Word32 Q6_R_mux_pIR(Byte Pu, Word32 Is8, Word32 Rs)                        191
Rd=mux(Pu,Rs,#s8)                    Word32 Q6_R_mux_pRI(Byte Pu, Word32 Rs, Word32 Is8)                        191
Rd=mux(Pu,Rs,Rt)                     Word32 Q6_R_mux_pRR(Byte Pu, Word32 Rs, Word32 Rt)                         191

N
neg
Rd=neg(Rs)                           Word32 Q6_R_neg_R(Word32 Rs)                                               175
Rd=neg(Rs):sat                       Word32 Q6_R_neg_R_sat(Word32 Rs)                                           408
Rdd=neg(Rss)                         Word64 Q6_P_neg_P(Word64 Rss)                                              408

no mnemonic
Pd=Ps                                Byte Q6_p_equals_p(Byte Ps)                                                221
Pd=Rs                                Byte Q6_p_equals_R(Word32 Rs)                                              634
Rd=#s16                              Word32 Q6_R_equals_I(Word32 Is16)                                          180
Rd=Ps                                Word32 Q6_R_equals_p(Byte Ps)                                              634
Rd=Rs                                Word32 Q6_R_equals_R(Word32 Rs)                                            182
Rdd=#s8                              Word64 Q6_P_equals_I(Word32 Is8)                                           180
Rdd=Rss                              Word64 Q6_P_equals_P(Word64 Rss)                                           182
Rx.H=#u16                            Word32 Q6_Rh_equals_I(Word32 Rx, Word32 Iu16)                              180
Rx.L=#u16                            Word32 Q6_Rl_equals_I(Word32 Rx, Word32 Iu16)                              180

normamt
Rd=normamt(Rs)                       Word32 Q6_R_normamt_R(Word32 Rs)                                           463
Rd=normamt(Rss)                      Word32 Q6_R_normamt_P(Word64 Rss)                                          463

not
Pd=not(Ps)                           Byte Q6_p_not_p(Byte Ps)                                                   221
Rd=not(Rs)                           Word32 Q6_R_not_R(Word32 Rs)                                               173



80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      711
Hexagon V62 Programmer's Reference Manual                                                       Intrinsics Index


Rdd=not(Rss)                       Word64 Q6_P_not_P(Word64 Rss)                                           398

O
or
Pd=and(Ps,or(Pt,!Pu))              Byte Q6_p_and_or_ppnp(Byte Ps, Byte Pt, Byte Pu)                        221
Pd=and(Ps,or(Pt,Pu))               Byte Q6_p_and_or_ppp(Byte Ps, Byte Pt, Byte Pu)                         221
Pd=or(Ps,and(Pt,!Pu))              Byte Q6_p_or_and_ppnp(Byte Ps, Byte Pt, Byte Pu)                        221
Pd=or(Ps,and(Pt,Pu))               Byte Q6_p_or_and_ppp(Byte Ps, Byte Pt, Byte Pu)                         221
Pd=or(Ps,or(Pt,!Pu))               Byte Q6_p_or_or_ppnp(Byte Ps, Byte Pt, Byte Pu)                         222
Pd=or(Ps,or(Pt,Pu))                Byte Q6_p_or_or_ppp(Byte Ps, Byte Pt, Byte Pu)                          222
Pd=or(Pt,!Ps)                      Byte Q6_p_or_pnp(Byte Pt, Byte Ps)                                      222
Pd=or(Pt,Ps)                       Byte Q6_p_or_pp(Byte Pt, Byte Ps)                                       222
Rd=or(Rs,#s10)                     Word32 Q6_R_or_RI(Word32 Rs, Word32 Is10)                               173
Rd=or(Rs,Rt)                       Word32 Q6_R_or_RR(Word32 Rs, Word32 Rt)                                 173
Rd=or(Rt,~Rs)                      Word32 Q6_R_or_RnR(Word32 Rt, Word32 Rs)                                173
Rdd=or(Rss,Rtt)                    Word64 Q6_P_or_PP(Word64 Rss, Word64 Rtt)                               398
Rdd=or(Rtt,~Rss)                   Word64 Q6_P_or_PnP(Word64 Rtt, Word64 Rss)                              398
Rx^=or(Rs,Rt)                      Word32 Q6_R_orxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  401
Rx&=or(Rs,Rt)                      Word32 Q6_R_orand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   401
Rx=or(Ru,and(Rx,#s10))             Word32 Q6_R_or_and_RRI(Word32 Ru, Word32 Rx, Word32 Is10)               401
Rx|=or(Rs,#s10)                    Word32 Q6_R_oror_RI(Word32 Rx, Word32 Rs, Word32 Is10)                  402
Rx|=or(Rs,Rt)                      Word32 Q6_R_oror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                    402

P
packhl
Rdd=packhl(Rs,Rt)                  Word64 Q6_P_packhl_RR(Word32 Rs, Word32 Rt)                             195

parity
Rd=parity(Rs,Rt)                   Word32 Q6_R_parity_RR(Word32 Rs, Word32 Rt)                             474
Rd=parity(Rss,Rtt)                 Word32 Q6_R_parity_PP(Word64 Rss, Word64 Rtt)                           474

pmpyw
Rdd=pmpyw(Rs,Rt)                   Word64 Q6_P_pmpyw_RR(Word32 Rs, Word32 Rt)                              564
Rxx^=pmpyw(Rs,Rt)                  Word64 Q6_P_pmpywxacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)              564

popcount
Rd=popcount(Rss)                   Word32 Q6_R_popcount_P(Word64 Rss)                                      465

R
rol
Rd=rol(Rs,#u5)                     Word32 Q6_R_rol_RI(Word32 Rs, Word32 Iu5)                               646
Rdd=rol(Rss,#u6)                   Word64 Q6_P_rol_PI(Word64 Rss, Word32 Iu6)                              646
Rx^=rol(Rs,#u5)                    Word32 Q6_R_rolxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                652
Rx&=rol(Rs,#u5)                    Word32 Q6_R_roland_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 652
Rx+=rol(Rs,#u5)                    Word32 Q6_R_rolacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 648
Rx-=rol(Rs,#u5)                    Word32 Q6_R_rolnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 648
Rx|=rol(Rs,#u5)                    Word32 Q6_R_rolor_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                  652
Rxx^=rol(Rss,#u6)                  Word64 Q6_P_rolxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              653
Rxx&=rol(Rss,#u6)                  Word64 Q6_P_roland_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               653
Rxx+=rol(Rss,#u6)                  Word64 Q6_P_rolacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx-=rol(Rss,#u6)                  Word64 Q6_P_rolnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx|=rol(Rss,#u6)                  Word64 Q6_P_rolor_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)                653



80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   712
Hexagon V62 Programmer's Reference Manual                                                 Intrinsics Index



round
Rd=round(Rs,#u5)                 Word32 Q6_R_round_RI(Word32 Rs, Word32 Iu5)                         409
Rd=round(Rs,#u5):sat             Word32 Q6_R_round_RI_sat(Word32 Rs, Word32 Iu5)                     409
Rd=round(Rs,Rt)                  Word32 Q6_R_round_RR(Word32 Rs, Word32 Rt)                          409
Rd=round(Rs,Rt):sat              Word32 Q6_R_round_RR_sat(Word32 Rs, Word32 Rt)                      409
Rd=round(Rss):sat                Word32 Q6_R_round_P_sat(Word64 Rss)                                 409

S
sat
Rd=sat(Rss)                      Word32 Q6_R_sat_P(Word64 Rss)                                       599

satb
Rd=satb(Rs)                      Word32 Q6_R_satb_R(Word32 Rs)                                       599

sath
Rd=sath(Rs)                      Word32 Q6_R_sath_R(Word32 Rs)                                       599

satub
Rd=satub(Rs)                     Word32 Q6_R_satub_R(Word32 Rs)                                      599

satuh
Rd=satuh(Rs)                     Word32 Q6_R_satuh_R(Word32 Rs)                                      599

setbit
Rd=setbit(Rs,#u5)                Word32 Q6_R_setbit_RI(Word32 Rs, Word32 Iu5)                        476
Rd=setbit(Rs,Rt)                 Word32 Q6_R_setbit_RR(Word32 Rs, Word32 Rt)                         476

sfadd
Rd=sfadd(Rs,Rt)                  Word32 Q6_R_sfadd_RR(Word32 Rs, Word32 Rt)                          516

sfclass
Pd=sfclass(Rs,#u5)               Byte Q6_p_sfclass_RI(Word32 Rs, Word32 Iu5)                         517

sfcmp.eq
Pd=sfcmp.eq(Rs,Rt)               Byte Q6_p_sfcmp_eq_RR(Word32 Rs, Word32 Rt)                         519

sfcmp.ge
Pd=sfcmp.ge(Rs,Rt)               Byte Q6_p_sfcmp_ge_RR(Word32 Rs, Word32 Rt)                         519

sfcmp.gt
Pd=sfcmp.gt(Rs,Rt)               Byte Q6_p_sfcmp_gt_RR(Word32 Rs, Word32 Rt)                         519

sfcmp.uo
Pd=sfcmp.uo(Rs,Rt)               Byte Q6_p_sfcmp_uo_RR(Word32 Rs, Word32 Rt)                         519

sffixupd
Rd=sffixupd(Rs,Rt)               Word32 Q6_R_sffixupd_RR(Word32 Rs, Word32 Rt)                       527

sffixupn
Rd=sffixupn(Rs,Rt)               Word32 Q6_R_sffixupn_RR(Word32 Rs, Word32 Rt)                       527

sffixupr
Rd=sffixupr(Rs)                  Word32 Q6_R_sffixupr_R(Word32 Rs)                                   527



80-N2040-36 B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               713
Hexagon V62 Programmer's Reference Manual                                                         Intrinsics Index



sfmake
Rd=sfmake(#u10):neg                Word32 Q6_R_sfmake_I_neg(Word32 Iu10)                                      533
Rd=sfmake(#u10):pos                Word32 Q6_R_sfmake_I_pos(Word32 Iu10)                                      533

sfmax
Rd=sfmax(Rs,Rt)                    Word32 Q6_R_sfmax_RR(Word32 Rs, Word32 Rt)                                 534

sfmin
Rd=sfmin(Rs,Rt)                    Word32 Q6_R_sfmin_RR(Word32 Rs, Word32 Rt)                                 535

sfmpy
Rd=sfmpy(Rs,Rt)                    Word32 Q6_R_sfmpy_RR(Word32 Rs, Word32 Rt)                                 536
Rx+=sfmpy(Rs,Rt,Pu):scale          Word32 Q6_R_sfmpyacc_RRp_scale(Word32 Rx, Word32 Rs, Word32 Rt, Byte Pu)   529
Rx+=sfmpy(Rs,Rt)                   Word32 Q6_R_sfmpyacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   528
Rx+=sfmpy(Rs,Rt):lib               Word32 Q6_R_sfmpyacc_RR_lib(Word32 Rx, Word32 Rs, Word32 Rt)               531
Rx-=sfmpy(Rs,Rt)                   Word32 Q6_R_sfmpynac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   528
Rx-=sfmpy(Rs,Rt):lib               Word32 Q6_R_sfmpynac_RR_lib(Word32 Rx, Word32 Rs, Word32 Rt)               531

sfsub
Rd=sfsub(Rs,Rt)                    Word32 Q6_R_sfsub_RR(Word32 Rs, Word32 Rt)                                 538

shuffeb
Rdd=shuffeb(Rss,Rtt)               Word64 Q6_P_shuffeb_PP(Word64 Rss, Word64 Rtt)                             612

shuffeh
Rdd=shuffeh(Rss,Rtt)               Word64 Q6_P_shuffeh_PP(Word64 Rss, Word64 Rtt)                             612

shuffob
Rdd=shuffob(Rtt,Rss)               Word64 Q6_P_shuffob_PP(Word64 Rtt, Word64 Rss)                             612

shuffoh
Rdd=shuffoh(Rtt,Rss)               Word64 Q6_P_shuffoh_PP(Word64 Rtt, Word64 Rss)                             612

sub
Rd=add(Rs,sub(#s6,Ru))             Word32 Q6_R_add_sub_RIR(Word32 Rs, Word32 Is6, Word32 Ru)                  390
Rd=sub(#s10,Rs)                    Word32 Q6_R_sub_IR(Word32 Is10, Word32 Rs)                                 177
Rd=sub(Rt,Rs)                      Word32 Q6_R_sub_RR(Word32 Rt, Word32 Rs)                                   177
Rd=sub(Rt,Rs):sat                  Word32 Q6_R_sub_RR_sat(Word32 Rt, Word32 Rs)                               177
Rd=sub(Rt.H,Rs.H):<<16             Word32 Q6_R_sub_RhRh_s16(Word32 Rt, Word32 Rs)                             414
Rd=sub(Rt.H,Rs.H):sat:<<16         Word32 Q6_R_sub_RhRh_sat_s16(Word32 Rt, Word32 Rs)                         414
Rd=sub(Rt.H,Rs.L):<<16             Word32 Q6_R_sub_RhRl_s16(Word32 Rt, Word32 Rs)                             414
Rd=sub(Rt.H,Rs.L):sat:<<16         Word32 Q6_R_sub_RhRl_sat_s16(Word32 Rt, Word32 Rs)                         414
Rd=sub(Rt.L,Rs.H)                  Word32 Q6_R_sub_RlRh(Word32 Rt, Word32 Rs)                                 414
Rd=sub(Rt.L,Rs.H):<<16             Word32 Q6_R_sub_RlRh_s16(Word32 Rt, Word32 Rs)                             414
Rd=sub(Rt.L,Rs.H):sat              Word32 Q6_R_sub_RlRh_sat(Word32 Rt, Word32 Rs)                             414
Rd=sub(Rt.L,Rs.H):sat:<<16         Word32 Q6_R_sub_RlRh_sat_s16(Word32 Rt, Word32 Rs)                         414
Rd=sub(Rt.L,Rs.L)                  Word32 Q6_R_sub_RlRl(Word32 Rt, Word32 Rs)                                 414
Rd=sub(Rt.L,Rs.L):<<16             Word32 Q6_R_sub_RlRl_s16(Word32 Rt, Word32 Rs)                             414
Rd=sub(Rt.L,Rs.L):sat              Word32 Q6_R_sub_RlRl_sat(Word32 Rt, Word32 Rs)                             414
Rd=sub(Rt.L,Rs.L):sat:<<16         Word32 Q6_R_sub_RlRl_sat_s16(Word32 Rt, Word32 Rs)                         414
Rdd=sub(Rtt,Rss)                   Word64 Q6_P_sub_PP(Word64 Rtt, Word64 Rss)                                 411
Rx+=sub(Rt,Rs)                     Word32 Q6_R_subacc_RR(Word32 Rx, Word32 Rt, Word32 Rs)                     412




80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     714
Hexagon V62 Programmer's Reference Manual                                                             Intrinsics Index



swiz
Rd=swiz(Rs)                          Word32 Q6_R_swiz_R(Word32 Rs)                                               601

sxtb
Rd=sxtb(Rs)                          Word32 Q6_R_sxtb_R(Word32 Rs)                                               179

sxth
Rd=sxth(Rs)                          Word32 Q6_R_sxth_R(Word32 Rs)                                               179

sxtw
Rdd=sxtw(Rs)                         Word64 Q6_P_sxtw_R(Word32 Rs)                                               416

T
tableidxb
Rx=tableidxb(Rs,#u4,#U5)             Word32 Q6_R_tableidxb_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)     481

tableidxd
Rx=tableidxd(Rs,#u4,#U5)             Word32 Q6_R_tableidxd_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)     481

tableidxh
Rx=tableidxh(Rs,#u4,#U5)             Word32 Q6_R_tableidxh_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)     481

tableidxw
Rx=tableidxw(Rs,#u4,#U5)             Word32 Q6_R_tableidxw_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)     481

tlbmatch
Pd=tlbmatch(Rss,Rt)                  Byte Q6_p_tlbmatch_PR(Word64 Rss, Word32 Rt)                                633

togglebit
Rd=togglebit(Rs,#u5)                 Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5)                             476
Rd=togglebit(Rs,Rt)                  Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt)                              476

tstbit
Pd=!tstbit(Rs,#u5)                   Byte Q6_p_not_tstbit_RI(Word32 Rs, Word32 Iu5)                              635
Pd=!tstbit(Rs,Rt)                    Byte Q6_p_not_tstbit_RR(Word32 Rs, Word32 Rt)                               635
Pd=tstbit(Rs,#u5)                    Byte Q6_p_tstbit_RI(Word32 Rs, Word32 Iu5)                                  635
Pd=tstbit(Rs,Rt)                     Byte Q6_p_tstbit_RR(Word32 Rs, Word32 Rt)                                   635

V
vabsdiffb
Rdd=vabsdiffb(Rtt,Rss)               Word64 Q6_P_vabsdiffb_PP(Word64 Rtt, Word64 Rss)                            419

vabsdiffh
Rdd=vabsdiffh(Rtt,Rss)               Word64 Q6_P_vabsdiffh_PP(Word64 Rtt, Word64 Rss)                            420

vabsdiffub
Rdd=vabsdiffub(Rtt,Rss)              Word64 Q6_P_vabsdiffub_PP(Word64 Rtt, Word64 Rss)                           419

vabsdiffw
Rdd=vabsdiffw(Rtt,Rss)               Word64 Q6_P_vabsdiffw_PP(Word64 Rtt, Word64 Rss)                            421

vabsh
Rdd=vabsh(Rss)                       Word64 Q6_P_vabsh_P(Word64 Rss)                                             417


80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       715
Hexagon V62 Programmer's Reference Manual                                                          Intrinsics Index


Rdd=vabsh(Rss):sat                   Word64 Q6_P_vabsh_P_sat(Word64 Rss)                                      417

vabsw
Rdd=vabsw(Rss)                       Word64 Q6_P_vabsw_P(Word64 Rss)                                          418
Rdd=vabsw(Rss):sat                   Word64 Q6_P_vabsw_P_sat(Word64 Rss)                                      418

vaddb
Rdd=vaddb(Rss,Rtt)                   Word64 Q6_P_vaddb_PP(Word64 Rss, Word64 Rtt)                             432

vaddh
Rd=vaddh(Rs,Rt)                      Word32 Q6_R_vaddh_RR(Word32 Rs, Word32 Rt)                               183
Rd=vaddh(Rs,Rt):sat                  Word32 Q6_R_vaddh_RR_sat(Word32 Rs, Word32 Rt)                           183
Rdd=vaddh(Rss,Rtt)                   Word64 Q6_P_vaddh_PP(Word64 Rss, Word64 Rtt)                             425
Rdd=vaddh(Rss,Rtt):sat               Word64 Q6_P_vaddh_PP_sat(Word64 Rss, Word64 Rtt)                         425

vaddhub
Rd=vaddhub(Rss,Rtt):sat              Word32 Q6_R_vaddhub_PP_sat(Word64 Rss, Word64 Rtt)                       427

vaddub
Rdd=vaddub(Rss,Rtt)                  Word64 Q6_P_vaddub_PP(Word64 Rss, Word64 Rtt)                            432
Rdd=vaddub(Rss,Rtt):sat              Word64 Q6_P_vaddub_PP_sat(Word64 Rss, Word64 Rtt)                        432

vadduh
Rd=vadduh(Rs,Rt):sat                 Word32 Q6_R_vadduh_RR_sat(Word32 Rs, Word32 Rt)                          183
Rdd=vadduh(Rss,Rtt):sat              Word64 Q6_P_vadduh_PP_sat(Word64 Rss, Word64 Rtt)                        425

vaddw
Rdd=vaddw(Rss,Rtt)                   Word64 Q6_P_vaddw_PP(Word64 Rss, Word64 Rtt)                             433
Rdd=vaddw(Rss,Rtt):sat               Word64 Q6_P_vaddw_PP_sat(Word64 Rss, Word64 Rtt)                         433

valignb
Rdd=valignb(Rtt,Rss,#u3)             Word64 Q6_P_valignb_PPI(Word64 Rtt, Word64 Rss, Word32 Iu3)              602
Rdd=valignb(Rtt,Rss,Pu)              Word64 Q6_P_valignb_PPp(Word64 Rtt, Word64 Rss, Byte Pu)                 602

vaslh
Rdd=vaslh(Rss,#u4)                   Word64 Q6_P_vaslh_PI(Word64 Rss, Word32 Iu4)                             670
Rdd=vaslh(Rss,Rt)                    Word64 Q6_P_vaslh_PR(Word64 Rss, Word32 Rt)                              677

vaslw
Rdd=vaslw(Rss,#u5)                   Word64 Q6_P_vaslw_PI(Word64 Rss, Word32 Iu5)                             678
Rdd=vaslw(Rss,Rt)                    Word64 Q6_P_vaslw_PR(Word64 Rss, Word32 Rt)                              681

vasrh
Rdd=vasrh(Rss,#u4)                   Word64 Q6_P_vasrh_PI(Word64 Rss, Word32 Iu4)                             670
Rdd=vasrh(Rss,#u4):rnd               Word64 Q6_P_vasrh_PI_rnd(Word64 Rss, Word32 Iu4)                         672
Rdd=vasrh(Rss,Rt)                    Word64 Q6_P_vasrh_PR(Word64 Rss, Word32 Rt)                              677

vasrhub
Rd=vasrhub(Rss,#u4):rnd:sat          Word32 Q6_R_vasrhub_PI_rnd_sat(Word64 Rss, Word32 Iu4)                   675
Rd=vasrhub(Rss,#u4):sat              Word32 Q6_R_vasrhub_PI_sat(Word64 Rss, Word32 Iu4)                       675

vasrw
Rd=vasrw(Rss,#u5)                    Word32 Q6_R_vasrw_PI(Word64 Rss, Word32 Iu5)                             682
Rd=vasrw(Rss,Rt)                     Word32 Q6_R_vasrw_PR(Word64 Rss, Word32 Rt)                              682



80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    716
Hexagon V62 Programmer's Reference Manual                                                    Intrinsics Index


Rdd=vasrw(Rss,#u5)                  Word64 Q6_P_vasrw_PI(Word64 Rss, Word32 Iu5)                        678
Rdd=vasrw(Rss,Rt)                   Word64 Q6_P_vasrw_PR(Word64 Rss, Word32 Rt)                         681

vavgh
Rd=vavgh(Rs,Rt)                     Word32 Q6_R_vavgh_RR(Word32 Rs, Word32 Rt)                          184
Rd=vavgh(Rs,Rt):rnd                 Word32 Q6_R_vavgh_RR_rnd(Word32 Rs, Word32 Rt)                      184
Rdd=vavgh(Rss,Rtt)                  Word64 Q6_P_vavgh_PP(Word64 Rss, Word64 Rtt)                        435
Rdd=vavgh(Rss,Rtt):crnd             Word64 Q6_P_vavgh_PP_crnd(Word64 Rss, Word64 Rtt)                   435
Rdd=vavgh(Rss,Rtt):rnd              Word64 Q6_P_vavgh_PP_rnd(Word64 Rss, Word64 Rtt)                    435

vavgub
Rdd=vavgub(Rss,Rtt)                 Word64 Q6_P_vavgub_PP(Word64 Rss, Word64 Rtt)                       436
Rdd=vavgub(Rss,Rtt):rnd             Word64 Q6_P_vavgub_PP_rnd(Word64 Rss, Word64 Rtt)                   436

vavguh
Rdd=vavguh(Rss,Rtt)                 Word64 Q6_P_vavguh_PP(Word64 Rss, Word64 Rtt)                       435
Rdd=vavguh(Rss,Rtt):rnd             Word64 Q6_P_vavguh_PP_rnd(Word64 Rss, Word64 Rtt)                   435

vavguw
Rdd=vavguw(Rss,Rtt)                 Word64 Q6_P_vavguw_PP(Word64 Rss, Word64 Rtt)                       438
Rdd=vavguw(Rss,Rtt):rnd             Word64 Q6_P_vavguw_PP_rnd(Word64 Rss, Word64 Rtt)                   438

vavgw
Rdd=vavgw(Rss,Rtt)                  Word64 Q6_P_vavgw_PP(Word64 Rss, Word64 Rtt)                        438
Rdd=vavgw(Rss,Rtt):crnd             Word64 Q6_P_vavgw_PP_crnd(Word64 Rss, Word64 Rtt)                   438
Rdd=vavgw(Rss,Rtt):rnd              Word64 Q6_P_vavgw_PP_rnd(Word64 Rss, Word64 Rtt)                    438

vcmpb.eq
Pd=any8(vcmpb.eq(Rss,Rtt))          Byte Q6_p_any8_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)                  638
Pd=vcmpb.eq(Rss,#u8)                Byte Q6_p_vcmpb_eq_PI(Word64 Rss, Word32 Iu8)                       640
Pd=vcmpb.eq(Rss,Rtt)                Byte Q6_p_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)                       640

vcmpb.gt
Pd=vcmpb.gt(Rss,#s8)                Byte Q6_p_vcmpb_gt_PI(Word64 Rss, Word32 Is8)                       640
Pd=vcmpb.gt(Rss,Rtt)                Byte Q6_p_vcmpb_gt_PP(Word64 Rss, Word64 Rtt)                       640

vcmpb.gtu
Pd=vcmpb.gtu(Rss,#u7)               Byte Q6_p_vcmpb_gtu_PI(Word64 Rss, Word32 Iu7)                      640
Pd=vcmpb.gtu(Rss,Rtt)               Byte Q6_p_vcmpb_gtu_PP(Word64 Rss, Word64 Rtt)                      640

vcmph.eq
Pd=vcmph.eq(Rss,#s8)                Byte Q6_p_vcmph_eq_PI(Word64 Rss, Word32 Is8)                       637
Pd=vcmph.eq(Rss,Rtt)                Byte Q6_p_vcmph_eq_PP(Word64 Rss, Word64 Rtt)                       637

vcmph.gt
Pd=vcmph.gt(Rss,#s8)                Byte Q6_p_vcmph_gt_PI(Word64 Rss, Word32 Is8)                       637
Pd=vcmph.gt(Rss,Rtt)                Byte Q6_p_vcmph_gt_PP(Word64 Rss, Word64 Rtt)                       637

vcmph.gtu
Pd=vcmph.gtu(Rss,#u7)               Byte Q6_p_vcmph_gtu_PI(Word64 Rss, Word32 Iu7)                      637
Pd=vcmph.gtu(Rss,Rtt)               Byte Q6_p_vcmph_gtu_PP(Word64 Rss, Word64 Rtt)                      637

vcmpw.eq
Pd=vcmpw.eq(Rss,#s8)                Byte Q6_p_vcmpw_eq_PI(Word64 Rss, Word32 Is8)                       642



80-N2040-36 B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               717
Hexagon V62 Programmer's Reference Manual                                                               Intrinsics Index


Pd=vcmpw.eq(Rss,Rtt)                  Byte Q6_p_vcmpw_eq_PP(Word64 Rss, Word64 Rtt)                                642

vcmpw.gt
Pd=vcmpw.gt(Rss,#s8)                  Byte Q6_p_vcmpw_gt_PI(Word64 Rss, Word32 Is8)                                642
Pd=vcmpw.gt(Rss,Rtt)                  Byte Q6_p_vcmpw_gt_PP(Word64 Rss, Word64 Rtt)                                642

vcmpw.gtu
Pd=vcmpw.gtu(Rss,#u7)                 Byte Q6_p_vcmpw_gtu_PI(Word64 Rss, Word32 Iu7)                               642
Pd=vcmpw.gtu(Rss,Rtt)                 Byte Q6_p_vcmpw_gtu_PP(Word64 Rss, Word64 Rtt)                               642

vcmpyi
Rdd=vcmpyi(Rss,Rtt):<<1:sat           Word64 Q6_P_vcmpyi_PP_s1_sat(Word64 Rss, Word64 Rtt)                         498
Rdd=vcmpyi(Rss,Rtt):sat               Word64 Q6_P_vcmpyi_PP_sat(Word64 Rss, Word64 Rtt)                            498
Rxx+=vcmpyi(Rss,Rtt):sat              Word64 Q6_P_vcmpyiacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)             498

vcmpyr
Rdd=vcmpyr(Rss,Rtt):<<1:sat           Word64 Q6_P_vcmpyr_PP_s1_sat(Word64 Rss, Word64 Rtt)                         498
Rdd=vcmpyr(Rss,Rtt):sat               Word64 Q6_P_vcmpyr_PP_sat(Word64 Rss, Word64 Rtt)                            498
Rxx+=vcmpyr(Rss,Rtt):sat              Word64 Q6_P_vcmpyracc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)             498

vcnegh
Rdd=vcnegh(Rss,Rt)                    Word64 Q6_P_vcnegh_PR(Word64 Rss, Word32 Rt)                                 439

vconj
Rdd=vconj(Rss):sat                    Word64 Q6_P_vconj_P_sat(Word64 Rss)                                          500

vcrotate
Rdd=vcrotate(Rss,Rt)                  Word64 Q6_P_vcrotate_PR(Word64 Rss, Word32 Rt)                               502

vdmpy
Rd=vdmpy(Rss,Rtt):<<1:rnd:sat         Word32 Q6_R_vdmpy_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                      576
Rd=vdmpy(Rss,Rtt):rnd:sat             Word32 Q6_R_vdmpy_PP_rnd_sat(Word64 Rss, Word64 Rtt)                         576
Rdd=vdmpy(Rss,Rtt):<<1:sat            Word64 Q6_P_vdmpy_PP_s1_sat(Word64 Rss, Word64 Rtt)                          573
Rdd=vdmpy(Rss,Rtt):sat                Word64 Q6_P_vdmpy_PP_sat(Word64 Rss, Word64 Rtt)                             573
Rxx+=vdmpy(Rss,Rtt):<<1:sat           Word64 Q6_P_vdmpyacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)           573
Rxx+=vdmpy(Rss,Rtt):sat               Word64 Q6_P_vdmpyacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)              573

vdmpybsu
Rdd=vdmpybsu(Rss,Rtt):sat             Word64 Q6_P_vdmpybsu_PP_sat(Word64 Rss, Word64 Rtt)                          581
Rxx+=vdmpybsu(Rss,Rtt):sat            Word64 Q6_P_vdmpybsuacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)           581

vitpack
Rd=vitpack(Ps,Pt)                     Word32 Q6_R_vitpack_pp(Byte Ps, Byte Pt)                                     643

vlslh
Rdd=vlslh(Rss,Rt)                     Word64 Q6_P_vlslh_PR(Word64 Rss, Word32 Rt)                                  677

vlslw
Rdd=vlslw(Rss,Rt)                     Word64 Q6_P_vlslw_PR(Word64 Rss, Word32 Rt)                                  681

vlsrh
Rdd=vlsrh(Rss,#u4)                    Word64 Q6_P_vlsrh_PI(Word64 Rss, Word32 Iu4)                                 670
Rdd=vlsrh(Rss,Rt)                     Word64 Q6_P_vlsrh_PR(Word64 Rss, Word32 Rt)                                  677




80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        718
Hexagon V62 Programmer's Reference Manual                                                           Intrinsics Index



vlsrw
Rdd=vlsrw(Rss,#u5)                   Word64 Q6_P_vlsrw_PI(Word64 Rss, Word32 Iu5)                              678
Rdd=vlsrw(Rss,Rt)                    Word64 Q6_P_vlsrw_PR(Word64 Rss, Word32 Rt)                               681

vmaxb
Rdd=vmaxb(Rtt,Rss)                   Word64 Q6_P_vmaxb_PP(Word64 Rtt, Word64 Rss)                              441

vmaxh
Rdd=vmaxh(Rtt,Rss)                   Word64 Q6_P_vmaxh_PP(Word64 Rtt, Word64 Rss)                              442

vmaxub
Rdd=vmaxub(Rtt,Rss)                  Word64 Q6_P_vmaxub_PP(Word64 Rtt, Word64 Rss)                             441

vmaxuh
Rdd=vmaxuh(Rtt,Rss)                  Word64 Q6_P_vmaxuh_PP(Word64 Rtt, Word64 Rss)                             442

vmaxuw
Rdd=vmaxuw(Rtt,Rss)                  Word64 Q6_P_vmaxuw_PP(Word64 Rtt, Word64 Rss)                             447

vmaxw
Rdd=vmaxw(Rtt,Rss)                   Word64 Q6_P_vmaxw_PP(Word64 Rtt, Word64 Rss)                              447

vminb
Rdd=vminb(Rtt,Rss)                   Word64 Q6_P_vminb_PP(Word64 Rtt, Word64 Rss)                              448

vminh
Rdd=vminh(Rtt,Rss)                   Word64 Q6_P_vminh_PP(Word64 Rtt, Word64 Rss)                              450

vminub
Rdd=vminub(Rtt,Rss)                  Word64 Q6_P_vminub_PP(Word64 Rtt, Word64 Rss)                             448

vminuh
Rdd=vminuh(Rtt,Rss)                  Word64 Q6_P_vminuh_PP(Word64 Rtt, Word64 Rss)                             450

vminuw
Rdd=vminuw(Rtt,Rss)                  Word64 Q6_P_vminuw_PP(Word64 Rtt, Word64 Rss)                             455

vminw
Rdd=vminw(Rtt,Rss)                   Word64 Q6_P_vminw_PP(Word64 Rtt, Word64 Rss)                              455

vmpybsu
Rdd=vmpybsu(Rs,Rt)                   Word64 Q6_P_vmpybsu_RR(Word32 Rs, Word32 Rt)                              593
Rxx+=vmpybsu(Rs,Rt)                  Word64 Q6_P_vmpybsuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)               593

vmpybu
Rdd=vmpybu(Rs,Rt)                    Word64 Q6_P_vmpybu_RR(Word32 Rs, Word32 Rt)                               593
Rxx+=vmpybu(Rs,Rt)                   Word64 Q6_P_vmpybuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                593

vmpyeh
Rdd=vmpyeh(Rss,Rtt):<<1:sat          Word64 Q6_P_vmpyeh_PP_s1_sat(Word64 Rss, Word64 Rtt)                      583
Rdd=vmpyeh(Rss,Rtt):sat              Word64 Q6_P_vmpyeh_PP_sat(Word64 Rss, Word64 Rtt)                         583
Rxx+=vmpyeh(Rss,Rtt)                 Word64 Q6_P_vmpyehacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              583
Rxx+=vmpyeh(Rss,Rtt):<<1:sat         Word64 Q6_P_vmpyehacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)       583
Rxx+=vmpyeh(Rss,Rtt):sat             Word64 Q6_P_vmpyehacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)          583



80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     719
Hexagon V62 Programmer's Reference Manual                                                            Intrinsics Index



vmpyh
Rd=vmpyh(Rs,Rt):<<1:rnd:sat          Word32 Q6_R_vmpyh_RR_s1_rnd_sat(Word32 Rs, Word32 Rt)                      587
Rd=vmpyh(Rs,Rt):rnd:sat              Word32 Q6_R_vmpyh_RR_rnd_sat(Word32 Rs, Word32 Rt)                         587
Rdd=vmpyh(Rs,Rt):<<1:sat             Word64 Q6_P_vmpyh_RR_s1_sat(Word32 Rs, Word32 Rt)                          585
Rdd=vmpyh(Rs,Rt):sat                 Word64 Q6_P_vmpyh_RR_sat(Word32 Rs, Word32 Rt)                             585
Rxx+=vmpyh(Rs,Rt)                    Word64 Q6_P_vmpyhacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                  585
Rxx+=vmpyh(Rs,Rt):<<1:sat            Word64 Q6_P_vmpyhacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)           585
Rxx+=vmpyh(Rs,Rt):sat                Word64 Q6_P_vmpyhacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)              585

vmpyhsu
Rdd=vmpyhsu(Rs,Rt):<<1:sat           Word64 Q6_P_vmpyhsu_RR_s1_sat(Word32 Rs, Word32 Rt)                        588
Rdd=vmpyhsu(Rs,Rt):sat               Word64 Q6_P_vmpyhsu_RR_sat(Word32 Rs, Word32 Rt)                           588
Rxx+=vmpyhsu(Rs,Rt):<<1:sat          Word64 Q6_P_vmpyhsuacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)         588
Rxx+=vmpyhsu(Rs,Rt):sat              Word64 Q6_P_vmpyhsuacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)            588

vmpyweh
Rdd=vmpyweh(Rss,Rtt):<<1:rnd:sat     Word64 Q6_P_vmpyweh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                544
Rdd=vmpyweh(Rss,Rtt):<<1:sat         Word64 Q6_P_vmpyweh_PP_s1_sat(Word64 Rss, Word64 Rtt)                    544
Rdd=vmpyweh(Rss,Rtt):rnd:sat         Word64 Q6_P_vmpyweh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                   544
Rdd=vmpyweh(Rss,Rtt):sat             Word64 Q6_P_vmpyweh_PP_sat(Word64 Rss, Word64 Rtt)                       544
Rxx+=vmpyweh(Rss,Rtt):<<1:rnd:sat    Word64 Q6_P_vmpywehacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 544
Rxx+=vmpyweh(Rss,Rtt):<<1:sat        Word64 Q6_P_vmpywehacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)     544
Rxx+=vmpyweh(Rss,Rtt):rnd:sat        Word64 Q6_P_vmpywehacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)    544
Rxx+=vmpyweh(Rss,Rtt):sat            Word64 Q6_P_vmpywehacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)        544

vmpyweuh
Rdd=vmpyweuh(Rss,Rtt):<<1:rnd:sat    Word64 Q6_P_vmpyweuh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)              548
Rdd=vmpyweuh(Rss,Rtt):<<1:sat        Word64 Q6_P_vmpyweuh_PP_s1_sat(Word64 Rss, Word64 Rtt)                  548
Rdd=vmpyweuh(Rss,Rtt):rnd:sat      Word64 Q6_P_vmpyweuh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                   548
Rdd=vmpyweuh(Rss,Rtt):sat          Word64 Q6_P_vmpyweuh_PP_sat(Word64 Rss, Word64 Rtt)                       548
Rxx+=vmpyweuh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpyweuhacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 548
Rxx+=vmpyweuh(Rss,Rtt):<<1:sat     Word64 Q6_P_vmpyweuhacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)     548
Rxx+=vmpyweuh(Rss,Rtt):rnd:sat     Word64 Q6_P_vmpyweuhacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)    548
Rxx+=vmpyweuh(Rss,Rtt):sat         Word64 Q6_P_vmpyweuhacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)        548

vmpywoh
Rdd=vmpywoh(Rss,Rtt):<<1:rnd:sat     Word64 Q6_P_vmpywoh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                544
Rdd=vmpywoh(Rss,Rtt):<<1:sat         Word64 Q6_P_vmpywoh_PP_s1_sat(Word64 Rss, Word64 Rtt)                    544
Rdd=vmpywoh(Rss,Rtt):rnd:sat         Word64 Q6_P_vmpywoh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                   544
Rdd=vmpywoh(Rss,Rtt):sat             Word64 Q6_P_vmpywoh_PP_sat(Word64 Rss, Word64 Rtt)                       544
Rxx+=vmpywoh(Rss,Rtt):<<1:rnd:sat    Word64 Q6_P_vmpywohacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 544
Rxx+=vmpywoh(Rss,Rtt):<<1:sat        Word64 Q6_P_vmpywohacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)     544
Rxx+=vmpywoh(Rss,Rtt):rnd:sat        Word64 Q6_P_vmpywohacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)    544
Rxx+=vmpywoh(Rss,Rtt):sat            Word64 Q6_P_vmpywohacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)        544

vmpywouh
Rdd=vmpywouh(Rss,Rtt):<<1:rnd:sat    Word64 Q6_P_vmpywouh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)              548
Rdd=vmpywouh(Rss,Rtt):<<1:sat        Word64 Q6_P_vmpywouh_PP_s1_sat(Word64 Rss, Word64 Rtt)                  548
Rdd=vmpywouh(Rss,Rtt):rnd:sat      Word64 Q6_P_vmpywouh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                   548
Rdd=vmpywouh(Rss,Rtt):sat          Word64 Q6_P_vmpywouh_PP_sat(Word64 Rss, Word64 Rtt)                       548
Rxx+=vmpywouh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpywouhacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 548
Rxx+=vmpywouh(Rss,Rtt):<<1:sat     Word64 Q6_P_vmpywouhacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)     548
Rxx+=vmpywouh(Rss,Rtt):rnd:sat     Word64 Q6_P_vmpywouhacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)    548
Rxx+=vmpywouh(Rss,Rtt):sat         Word64 Q6_P_vmpywouhacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)        548



80-N2040-36 B              MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      720
Hexagon V62 Programmer's Reference Manual                                                             Intrinsics Index



vmux
Rdd=vmux(Pu,Rss,Rtt)                  Word64 Q6_P_vmux_pPP(Byte Pu, Word64 Rss, Word64 Rtt)                      644

vnavgh
Rd=vnavgh(Rt,Rs)                      Word32 Q6_R_vnavgh_RR(Word32 Rt, Word32 Rs)                                184
Rdd=vnavgh(Rtt,Rss)                   Word64 Q6_P_vnavgh_PP(Word64 Rtt, Word64 Rss)                              435
Rdd=vnavgh(Rtt,Rss):crnd:sat          Word64 Q6_P_vnavgh_PP_crnd_sat(Word64 Rtt, Word64 Rss)                     435
Rdd=vnavgh(Rtt,Rss):rnd:sat           Word64 Q6_P_vnavgh_PP_rnd_sat(Word64 Rtt, Word64 Rss)                      435

vnavgw
Rdd=vnavgw(Rtt,Rss)                   Word64 Q6_P_vnavgw_PP(Word64 Rtt, Word64 Rss)                              438
Rdd=vnavgw(Rtt,Rss):crnd:sat          Word64 Q6_P_vnavgw_PP_crnd_sat(Word64 Rtt, Word64 Rss)                     438
Rdd=vnavgw(Rtt,Rss):rnd:sat           Word64 Q6_P_vnavgw_PP_rnd_sat(Word64 Rtt, Word64 Rss)                      438

vpmpyh
Rdd=vpmpyh(Rs,Rt)                     Word64 Q6_P_vpmpyh_RR(Word32 Rs, Word32 Rt)                                595
Rxx^=vpmpyh(Rs,Rt)                    Word64 Q6_P_vpmpyhxacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                595

vraddh
Rd=vraddh(Rss,Rtt)                    Word32 Q6_R_vraddh_PP(Word64 Rss, Word64 Rtt)                              430

vraddub
Rdd=vraddub(Rss,Rtt)                  Word64 Q6_P_vraddub_PP(Word64 Rss, Word64 Rtt)                             428
Rxx+=vraddub(Rss,Rtt)                 Word64 Q6_P_vraddubacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              428

vradduh
Rd=vradduh(Rss,Rtt)                   Word32 Q6_R_vradduh_PP(Word64 Rss, Word64 Rtt)                             430

vrcmpyi
Rdd=vrcmpyi(Rss,Rtt)                  Word64 Q6_P_vrcmpyi_PP(Word64 Rss, Word64 Rtt)                             504
Rdd=vrcmpyi(Rss,Rtt*)                 Word64 Q6_P_vrcmpyi_PP_conj(Word64 Rss, Word64 Rtt)                        504
Rxx+=vrcmpyi(Rss,Rtt)                 Word64 Q6_P_vrcmpyiacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              504
Rxx+=vrcmpyi(Rss,Rtt*)                Word64 Q6_P_vrcmpyiacc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)         504

vrcmpyr
Rdd=vrcmpyr(Rss,Rtt)                  Word64 Q6_P_vrcmpyr_PP(Word64 Rss, Word64 Rtt)                             504
Rdd=vrcmpyr(Rss,Rtt*)                 Word64 Q6_P_vrcmpyr_PP_conj(Word64 Rss, Word64 Rtt)                        504
Rxx+=vrcmpyr(Rss,Rtt)                 Word64 Q6_P_vrcmpyracc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              504
Rxx+=vrcmpyr(Rss,Rtt*)                Word64 Q6_P_vrcmpyracc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)         504

vrcmpys
Rd=vrcmpys(Rss,Rt):<<1:rnd:sat        Word32 Q6_R_vrcmpys_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)                   510
Rdd=vrcmpys(Rss,Rt):<<1:sat           Word64 Q6_P_vrcmpys_PR_s1_sat(Word64 Rss, Word32 Rt)                       508
Rxx+=vrcmpys(Rss,Rt):<<1:sat          Word64 Q6_P_vrcmpysacc_PR_s1_sat(Word64 Rxx, Word64 Rss, Word32 Rt)        508

vrcnegh
Rxx+=vrcnegh(Rss,Rt)                  Word64 Q6_P_vrcneghacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               439

vrcrotate
Rdd=vrcrotate(Rss,Rt,#u2)             Word64 Q6_P_vrcrotate_PRI(Word64 Rss, Word32 Rt, Word32 Iu2)               513
Rxx+=vrcrotate(Rss,Rt,#u2)            Word64 Q6_P_vrcrotateacc_PRI(Word64 Rxx, Word64 Rss, Word32 Rt, Word32 Iu2) 513

vrmaxh
Rxx=vrmaxh(Rss,Ru)                    Word64 Q6_P_vrmaxh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                   443



80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      721
Hexagon V62 Programmer's Reference Manual                                                           Intrinsics Index



vrmaxuh
Rxx=vrmaxuh(Rss,Ru)                Word64 Q6_P_vrmaxuh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                   443

vrmaxuw
Rxx=vrmaxuw(Rss,Ru)                Word64 Q6_P_vrmaxuw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                   445

vrmaxw
Rxx=vrmaxw(Rss,Ru)                 Word64 Q6_P_vrmaxw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                    445

vrminh
Rxx=vrminh(Rss,Ru)                 Word64 Q6_P_vrminh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                    451

vrminuh
Rxx=vrminuh(Rss,Ru)                Word64 Q6_P_vrminuh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                   451

vrminuw
Rxx=vrminuw(Rss,Ru)                Word64 Q6_P_vrminuw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                   453

vrminw
Rxx=vrminw(Rss,Ru)                 Word64 Q6_P_vrminw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                    453

vrmpybsu
Rdd=vrmpybsu(Rss,Rtt)              Word64 Q6_P_vrmpybsu_PP(Word64 Rss, Word64 Rtt)                             578
Rxx+=vrmpybsu(Rss,Rtt)             Word64 Q6_P_vrmpybsuacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              578

vrmpybu
Rdd=vrmpybu(Rss,Rtt)               Word64 Q6_P_vrmpybu_PP(Word64 Rss, Word64 Rtt)                              578
Rxx+=vrmpybu(Rss,Rtt)              Word64 Q6_P_vrmpybuacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               578

vrmpyh
Rdd=vrmpyh(Rss,Rtt)                Word64 Q6_P_vrmpyh_PP(Word64 Rss, Word64 Rtt)                               590
Rxx+=vrmpyh(Rss,Rtt)               Word64 Q6_P_vrmpyhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                590

vrmpyweh
Rdd=vrmpyweh(Rss,Rtt)              Word64 Q6_P_vrmpyweh_PP(Word64 Rss, Word64 Rtt)                             566
Rdd=vrmpyweh(Rss,Rtt):<<1          Word64 Q6_P_vrmpyweh_PP_s1(Word64 Rss, Word64 Rtt)                          566
Rxx+=vrmpyweh(Rss,Rtt)             Word64 Q6_P_vrmpywehacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              566
Rxx+=vrmpyweh(Rss,Rtt):<<1         Word64 Q6_P_vrmpywehacc_PP_s1(Word64 Rxx, Word64 Rss, Word64 Rtt)           566

vrmpywoh
Rdd=vrmpywoh(Rss,Rtt)              Word64 Q6_P_vrmpywoh_PP(Word64 Rss, Word64 Rtt)                             566
Rdd=vrmpywoh(Rss,Rtt):<<1          Word64 Q6_P_vrmpywoh_PP_s1(Word64 Rss, Word64 Rtt)                          566
Rxx+=vrmpywoh(Rss,Rtt)             Word64 Q6_P_vrmpywohacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              566
Rxx+=vrmpywoh(Rss,Rtt):<<1         Word64 Q6_P_vrmpywohacc_PP_s1(Word64 Rxx, Word64 Rss, Word64 Rtt)           566

vrndwh
Rd=vrndwh(Rss)                     Word32 Q6_R_vrndwh_P(Word64 Rss)                                            604
Rd=vrndwh(Rss):sat                 Word32 Q6_R_vrndwh_P_sat(Word64 Rss)                                        604

vrsadub
Rdd=vrsadub(Rss,Rtt)               Word64 Q6_P_vrsadub_PP(Word64 Rss, Word64 Rtt)                              457
Rxx+=vrsadub(Rss,Rtt)              Word64 Q6_P_vrsadubacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               457




80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       722
Hexagon V62 Programmer's Reference Manual                                                            Intrinsics Index



vsathb
Rd=vsathb(Rs)                         Word32 Q6_R_vsathb_R(Word32 Rs)                                           607
Rd=vsathb(Rss)                        Word32 Q6_R_vsathb_P(Word64 Rss)                                          607
Rdd=vsathb(Rss)                       Word64 Q6_P_vsathb_P(Word64 Rss)                                          610

vsathub
Rd=vsathub(Rs)                        Word32 Q6_R_vsathub_R(Word32 Rs)                                          607
Rd=vsathub(Rss)                       Word32 Q6_R_vsathub_P(Word64 Rss)                                         607
Rdd=vsathub(Rss)                      Word64 Q6_P_vsathub_P(Word64 Rss)                                         610

vsatwh
Rd=vsatwh(Rss)                        Word32 Q6_R_vsatwh_P(Word64 Rss)                                          607
Rdd=vsatwh(Rss)                       Word64 Q6_P_vsatwh_P(Word64 Rss)                                          610

vsatwuh
Rd=vsatwuh(Rss)                       Word32 Q6_R_vsatwuh_P(Word64 Rss)                                         607
Rdd=vsatwuh(Rss)                      Word64 Q6_P_vsatwuh_P(Word64 Rss)                                         610

vsplatb
Rd=vsplatb(Rs)                        Word32 Q6_R_vsplatb_R(Word32 Rs)                                          613
Rdd=vsplatb(Rs)                       Word64 Q6_P_vsplatb_R(Word32 Rs)                                          613

vsplath
Rdd=vsplath(Rs)                       Word64 Q6_P_vsplath_R(Word32 Rs)                                          614

vspliceb
Rdd=vspliceb(Rss,Rtt,#u3)             Word64 Q6_P_vspliceb_PPI(Word64 Rss, Word64 Rtt, Word32 Iu3)              615
Rdd=vspliceb(Rss,Rtt,Pu)              Word64 Q6_P_vspliceb_PPp(Word64 Rss, Word64 Rtt, Byte Pu)                 615

vsubb
Rdd=vsubb(Rss,Rtt)                    Word64 Q6_P_vsubb_PP(Word64 Rss, Word64 Rtt)                              460

vsubh
Rd=vsubh(Rt,Rs)                       Word32 Q6_R_vsubh_RR(Word32 Rt, Word32 Rs)                                185
Rd=vsubh(Rt,Rs):sat                   Word32 Q6_R_vsubh_RR_sat(Word32 Rt, Word32 Rs)                            185
Rdd=vsubh(Rtt,Rss)                    Word64 Q6_P_vsubh_PP(Word64 Rtt, Word64 Rss)                              458
Rdd=vsubh(Rtt,Rss):sat                Word64 Q6_P_vsubh_PP_sat(Word64 Rtt, Word64 Rss)                          458

vsubub
Rdd=vsubub(Rtt,Rss)                   Word64 Q6_P_vsubub_PP(Word64 Rtt, Word64 Rss)                             460
Rdd=vsubub(Rtt,Rss):sat               Word64 Q6_P_vsubub_PP_sat(Word64 Rtt, Word64 Rss)                         460

vsubuh
Rd=vsubuh(Rt,Rs):sat                  Word32 Q6_R_vsubuh_RR_sat(Word32 Rt, Word32 Rs)                           185
Rdd=vsubuh(Rtt,Rss):sat               Word64 Q6_P_vsubuh_PP_sat(Word64 Rtt, Word64 Rss)                         458

vsubw
Rdd=vsubw(Rtt,Rss)                    Word64 Q6_P_vsubw_PP(Word64 Rtt, Word64 Rss)                              461
Rdd=vsubw(Rtt,Rss):sat                Word64 Q6_P_vsubw_PP_sat(Word64 Rtt, Word64 Rss)                          461

vsxtbh
Rdd=vsxtbh(Rs)                        Word64 Q6_P_vsxtbh_R(Word32 Rs)                                           616




80-N2040-36 B               MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     723
Hexagon V62 Programmer's Reference Manual                                                           Intrinsics Index



vsxthw
Rdd=vsxthw(Rs)                       Word64 Q6_P_vsxthw_R(Word32 Rs)                                           616

vtrunehb
Rd=vtrunehb(Rss)                     Word32 Q6_R_vtrunehb_P(Word64 Rss)                                        619
Rdd=vtrunehb(Rss,Rtt)                Word64 Q6_P_vtrunehb_PP(Word64 Rss, Word64 Rtt)                           619

vtrunewh
Rdd=vtrunewh(Rss,Rtt)                Word64 Q6_P_vtrunewh_PP(Word64 Rss, Word64 Rtt)                           619

vtrunohb
Rd=vtrunohb(Rss)                     Word32 Q6_R_vtrunohb_P(Word64 Rss)                                        619
Rdd=vtrunohb(Rss,Rtt)                Word64 Q6_P_vtrunohb_PP(Word64 Rss, Word64 Rtt)                           619

vtrunowh
Rdd=vtrunowh(Rss,Rtt)                Word64 Q6_P_vtrunowh_PP(Word64 Rss, Word64 Rtt)                           619

vxaddsubh
Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat   Word64 Q6_P_vxaddsubh_PP_rnd_rs1_sat(Word64 Rss, Word64 Rtt)              484
Rdd=vxaddsubh(Rss,Rtt):sat           Word64 Q6_P_vxaddsubh_PP_sat(Word64 Rss, Word64 Rtt)                      484

vxaddsubw
Rdd=vxaddsubw(Rss,Rtt):sat           Word64 Q6_P_vxaddsubw_PP_sat(Word64 Rss, Word64 Rtt)                      486

vxsubaddh
Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat   Word64 Q6_P_vxsubaddh_PP_rnd_rs1_sat(Word64 Rss, Word64 Rtt)              484
Rdd=vxsubaddh(Rss,Rtt):sat           Word64 Q6_P_vxsubaddh_PP_sat(Word64 Rss, Word64 Rtt)                      484

vxsubaddw
Rdd=vxsubaddw(Rss,Rtt):sat           Word64 Q6_P_vxsubaddw_PP_sat(Word64 Rss, Word64 Rtt)                      486

vzxtbh
Rdd=vzxtbh(Rs)                       Word64 Q6_P_vzxtbh_R(Word32 Rs)                                           621

vzxthw
Rdd=vzxthw(Rs)                       Word64 Q6_P_vzxthw_R(Word32 Rs)                                           621

X
xor
Pd=xor(Ps,Pt)                        Byte Q6_p_xor_pp(Byte Ps, Byte Pt)                                        222
Rd=xor(Rs,Rt)                        Word32 Q6_R_xor_RR(Word32 Rs, Word32 Rt)                                  173
Rdd=xor(Rss,Rtt)                     Word64 Q6_P_xor_PP(Word64 Rss, Word64 Rtt)                                398
Rx^=xor(Rs,Rt)                       Word32 Q6_R_xorxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   401
Rx&=xor(Rs,Rt)                       Word32 Q6_R_xorand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                    401
Rx|=xor(Rs,Rt)                       Word32 Q6_R_xoror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                     402
Rxx^=xor(Rss,Rtt)                    Word64 Q6_P_xorxacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                400

Z
zxtb
Rd=zxtb(Rs)                          Word32 Q6_R_zxtb_R(Word32 Rs)                                             187

zxth
Rd=zxth(Rs)                          Word32 Q6_R_zxth_R(Word32 Rs)                                             187


80-N2040-36 B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       724

